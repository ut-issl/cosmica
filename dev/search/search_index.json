{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udef0\ufe0f COnstellation Satellite siMulator for optIcal CommunicAtion (COSMICA)","text":"<p>COSMICA is a Python package for simulating optical communication satellite constellations. It is modular and extensible so that users can conduct various optical communication satellite constellation analyses. See COSMICA documentation for more details.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#examples","title":"Examples","text":"<ul> <li>See <code>examples</code> directory for how to use COSMICA in analyses.</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or higher</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>If you use pip, install COSMICA by running:</p> <pre><code>pip install cosmica\n</code></pre>"},{"location":"#structure","title":"Structure","text":"<p>The diagram below shows the structure of the simulator. Each green box is a Python submodule.</p> <p></p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under either of the MIT license or the Apache License 2.0 at your option.</p>"},{"location":"developers/releasing/","title":"Releasing COSMICA","text":"<p>This page describes the process of releasing a new version of the COSMICA.</p>"},{"location":"developers/releasing/#prerequisites","title":"Prerequisites","text":"<ul> <li> The build is passing on the <code>main</code> branch.</li> </ul>"},{"location":"developers/releasing/#release","title":"Release","text":"<p>COSMICA follows Semantic Versioning. Determine the new version number based on the changes since the last release:</p> <p>MAJOR version when you make incompatible API changes; MINOR version when you add functionality in a backward compatible manner; PATCH version when you make backward compatible bug fixes.</p>"},{"location":"developers/releasing/#create-a-release-branch","title":"Create a release branch","text":"<ol> <li>Create a new branch for the release (<code>git switch -c release/v&lt;version&gt;</code>). The branch name should be <code>release/v&lt;version&gt;</code>, where <code>&lt;version&gt;</code> is the new version number.</li> </ol>"},{"location":"developers/releasing/#bump-the-version-number","title":"Bump the version number","text":"<ol> <li>Bump the <code>project.version</code> field in the <code>pyproject.toml</code> file.</li> <li>Commit the changes by running <code>git commit -am \"Bump version to &lt;version&gt;\"</code>.</li> </ol>"},{"location":"developers/releasing/#merge-the-release-branch-into-main","title":"Merge the release branch into <code>main</code>","text":"<ol> <li>Create a pull request to merge the release branch into <code>main</code>.</li> <li>Wait for the CI to pass.</li> <li>Merge the pull request.</li> </ol>"},{"location":"developers/releasing/#create-a-git-tag","title":"Create a Git tag","text":"<ol> <li>Create a Git tag for the new version by running <code>git tag v&lt;version&gt;</code>.</li> <li>Push the tag to GitHub by running <code>git push origin v&lt;version&gt;</code>.</li> </ol>"},{"location":"developers/releasing/#create-a-github-release","title":"Create a GitHub release","text":"<ol> <li>Go to the GitHub releases page.</li> <li>Click \"Draft a new release\".</li> <li>Choose <code>v&lt;version&gt;</code> in the \"Choose a tag\" dropdown.</li> <li>Enter <code>v&lt;version&gt;</code> as the title of the release in the \"Release title\" field.</li> <li>Enter the release notes in the \"Write\" field. The release notes should be a summary of the changes in the new version. You can click \"Generate release notes\" to generate the release notes based on the pull requests merged since the last release.</li> <li>Click \"Publish release\".</li> </ol>"},{"location":"developers/releasing/#update-the-documentation","title":"Update the documentation","text":"<ol> <li>Run <code>uv run -- mike deploy --push --update-aliases &lt;version&gt; latest</code>.</li> </ol> <p>Tip</p> <p>The version in the <code>mike deploy</code> command is not prefixed with <code>v</code>.</p>"},{"location":"developers/setup/","title":"\ud83d\udee0\ufe0f Setup","text":""},{"location":"developers/setup/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<ul> <li>uv</li> </ul>"},{"location":"developers/setup/#recommended-tools","title":"\ud83d\udee0\ufe0f Recommended tools","text":"<p>The following tools are recommended (but not required) to work with this project:</p> <ul> <li>Visual Studio Code</li> <li>Various settings are already configured in <code>.vscode/settings.json</code></li> <li>Windows Subsystem for Linux (WSL) if you are using Windows</li> <li>On native Windows, the <code>${workspaceFolder}/.venv/bin/*</code> paths in <code>.vscode/settings.json</code> will not work. You will need to change them to <code>${workspaceFolder}/.venv/Scripts/*</code> instead.</li> </ul>"},{"location":"developers/setup/#installation","title":"\ud83d\ude80 Installation","text":"<ol> <li>Clone this repository \ud83d\udd04</li> <li>Run <code>uv sync</code> in the root directory of the repository</li> </ol>"},{"location":"developers/setup/#install-pre-commit-hooks","title":"Install pre-commit hooks","text":"<p>This project uses pre-commit to run checks on every commit. To install the pre-commit hooks, run the following command:</p> <pre><code>uv run pre-commit install\n</code></pre>"},{"location":"developers/tips/","title":"\ud83d\udcda Development rules and tips","text":""},{"location":"developers/tips/#rules","title":"Rules","text":"<ul> <li>Use SI units for all calculations. (e.g., radians instead of degrees, meters instead of kilometers)</li> <li>When generating random numbers, add an input argument of type <code>np.random.Generator</code> to the function and use it to generate random numbers. This will make the function deterministic and reproducible. See: NumPy Random Generator.</li> <li>Use type hints as much as possible. This will help you catch bugs early and make your code more readable.</li> <li>To add a new dependency, run <code>uv add &lt;package-name&gt;</code> in the root directory of the repository. This will automatically update the <code>pyproject.toml</code> file and install the package. DO NOT use <code>pip</code> to install packages.</li> <li>After adding a new dependency, change the version constraint to <code>&gt;=</code> in <code>pyproject.toml</code> unless you have a good reason not to.</li> </ul>"},{"location":"developers/tips/#linting","title":"Linting","text":"<ul> <li>Running <code>uv run ruff check .</code> in the root directory of the repository (after activating the virtual environment) will run various checks on the codebase. Running this before committing your changes is highly recommended. Running <code>uv run ruff format .</code> will also format the codebase. See Ruff for more information.</li> <li>If you develop on Visual Studio Code, you can also install the Ruff extension and see the results of <code>uv run ruff check .</code> in the editor.</li> <li>Running <code>uv run mypy .</code> in the root directory of the repository (after activating the virtual environment) will run static type checking on the codebase. Running this before committing your changes is recommended. See Mypy for more information.</li> <li>If you develop on Visual Studio Code, you can alternatively install the Pylance extension and see the results of type checking in the editor.</li> </ul>"},{"location":"developers/tips/#tips","title":"Tips","text":"<ul> <li>Run command with <code>uv run</code> to ensure that the command is run in the correct environment.</li> <li>Python can be very slow if implemented naively.</li> <li>Make sure to use Numpy arrays and vectorize your code as much as possible.</li> <li>Use <code>np.datetime64</code> instead of <code>datetime.datetime</code> for consistency.</li> <li>Avoid using <code>for</code> loops for hot code paths.</li> <li>Consider using Numba to speed up your code.</li> <li>Always leave room for future expansion. \ud83d\udd2d</li> <li>Use abstract base classes (ABCs) and abstract methods to define interfaces, and implement for the current specific use case in a concrete class.</li> </ul>"},{"location":"developers/tips/#useful-links","title":"\ud83d\udd17 Useful links","text":"<ul> <li>PyMap3D API Documentation</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cosmica<ul> <li>cli<ul> <li>main</li> <li>plot</li> </ul> </li> <li>comm_link<ul> <li>base</li> <li>coordinator</li> <li>gateway_to_gateway</li> <li>gateway_to_internet</li> <li>geometric</li> <li>rate_distance_calculator</li> <li>sat_to_ground</li> <li>sat_to_sat</li> <li>uncertainty</li> </ul> </li> <li>dtos<ul> <li>dynamics_data</li> </ul> </li> <li>dynamics<ul> <li>constellation</li> <li>orbit</li> <li>plotting</li> <li>sun_dynamics</li> </ul> </li> <li>experimental_packet_routing<ul> <li>calc_forwarding_table_from_graph</li> <li>case_definitions</li> <li>comm_data</li> <li>dtos</li> <li>forwarding_table</li> <li>forwarding_table_time_list</li> <li>lsa_case_definition</li> <li>node_knowledge</li> <li>routing_result_visualizer</li> <li>simulator</li> <li>space_time_graph</li> <li>use_node_knowledge</li> <li>utility</li> </ul> </li> <li>models<ul> <li>constellation</li> <li>demand</li> <li>gateway</li> <li>internet</li> <li>node</li> <li>orbit</li> <li>satellite</li> <li>scenario</li> <li>terminal</li> <li>user</li> </ul> </li> <li>scenario<ul> <li>maritime</li> <li>population</li> </ul> </li> <li>topology<ul> <li>gateway_to_gateway</li> <li>gateway_to_internet</li> <li>ground_to_constellation</li> <li>intra_constellation</li> <li>usersatellite_gateway_to_constellation</li> <li>usersatellite_to_constellation</li> </ul> </li> <li>utils<ul> <li>constants</li> <li>coordinates</li> <li>gauss_beam</li> <li>vector</li> </ul> </li> <li>visualization<ul> <li>equirectangular</li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/cosmica/","title":"cosmica","text":""},{"location":"reference/cosmica/#cosmica","title":"cosmica","text":""},{"location":"reference/cosmica/#cosmica.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = version('cosmica')\n</code></pre>"},{"location":"reference/cosmica/cli/","title":"cli","text":""},{"location":"reference/cosmica/cli/#cosmica.cli","title":"cosmica.cli","text":""},{"location":"reference/cosmica/cli/main/","title":"main","text":""},{"location":"reference/cosmica/cli/main/#cosmica.cli.main","title":"cosmica.cli.main","text":""},{"location":"reference/cosmica/cli/main/#cosmica.cli.main.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = Typer()\n</code></pre>"},{"location":"reference/cosmica/cli/main/#cosmica.cli.main.console_err","title":"console_err  <code>module-attribute</code>","text":"<pre><code>console_err = Console(stderr=True)\n</code></pre>"},{"location":"reference/cosmica/cli/main/#cosmica.cli.main.main","title":"main","text":"<pre><code>main(_version: bool | None = None) -&gt; None\n</code></pre> <p>COSMICA CLI.</p> <p>Warning: The 'cosmica' CLI will be deprecated in future versions.</p> Source code in <code>src/cosmica/cli/main.py</code> <pre><code>@app.callback()\ndef main(\n    _version: Annotated[\n        bool | None,\n        typer.Option(\"--version\", help=\"Show version information\", is_eager=True, callback=_version_callback),\n    ] = None,\n) -&gt; None:\n    \"\"\"COSMICA CLI.\n\n    Warning: The 'cosmica' CLI will be deprecated in future versions.\n    \"\"\"\n    # Show deprecation of cosmica CLI in future version\n    console_err.print(\n        \"[yellow]Warning: The 'cosmica' CLI will be deprecated in future versions.[/yellow]\",\n    )\n</code></pre>"},{"location":"reference/cosmica/cli/plot/","title":"plot","text":""},{"location":"reference/cosmica/cli/plot/#cosmica.cli.plot","title":"cosmica.cli.plot","text":""},{"location":"reference/cosmica/cli/plot/#cosmica.cli.plot.console","title":"console  <code>module-attribute</code>","text":"<pre><code>console = Console()\n</code></pre>"},{"location":"reference/cosmica/cli/plot/#cosmica.cli.plot.err_console","title":"err_console  <code>module-attribute</code>","text":"<pre><code>err_console = Console(stderr=True)\n</code></pre>"},{"location":"reference/cosmica/cli/plot/#cosmica.cli.plot.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/cli/plot/#cosmica.cli.plot.animate_graphs","title":"animate_graphs","text":"<pre><code>animate_graphs(\n    graphs: Sequence[Graph],\n    dynamics_data: DynamicsData,\n    output_file: Path | None = None,\n    *,\n    writer: str | None = None\n) -&gt; FuncAnimation\n</code></pre> Source code in <code>src/cosmica/cli/plot.py</code> <pre><code>def animate_graphs(\n    graphs: Sequence[nx.Graph],\n    dynamics_data: DynamicsData,\n    output_file: Path | None = None,\n    *,\n    writer: str | None = None,\n) -&gt; matplotlib.animation.FuncAnimation:\n    ## Plot\n    fig: Figure\n    ax: Axes\n    fig, ax = plt.subplots(figsize=(15, 8))\n\n    def animate(time_index: int) -&gt; None:\n        ax.clear()\n        draw_graph(graph=graphs[time_index], dynamics_data=dynamics_data[time_index], ax=ax)\n\n    ani = matplotlib.animation.FuncAnimation(fig, animate, frames=len(dynamics_data.time), interval=100)  # type: ignore[arg-type]\n    if output_file is not None:\n        writer = writer or \"imagemagick\"\n        progress_bar = tqdm(total=len(dynamics_data.time))\n        ani.save(\n            str(output_file),\n            writer=writer,\n            fps=10,\n            dpi=100,\n            progress_callback=lambda _i, _n: progress_bar.update(1),\n        )\n        progress_bar.close()\n\n    return ani\n</code></pre>"},{"location":"reference/cosmica/cli/plot/#cosmica.cli.plot.draw_graph","title":"draw_graph","text":"<pre><code>draw_graph(\n    graph: Graph,\n    dynamics_data: DynamicsData,\n    output_file: Path | None = None,\n    *,\n    ax: Axes | None = None\n) -&gt; Axes\n</code></pre> Source code in <code>src/cosmica/cli/plot.py</code> <pre><code>def draw_graph(\n    graph: nx.Graph,\n    dynamics_data: DynamicsData,\n    output_file: Path | None = None,\n    *,\n    ax: Axes | None = None,\n) -&gt; Axes:\n    if ax is None:\n        _fig, ax = plt.subplots(figsize=(15, 8))\n\n    ax.set_title(f\"Time: {np.datetime_as_string(dynamics_data.time, unit='s')}\")\n\n    draw_lat_lon_grid(ax=ax)\n    draw_countries(ax=ax)\n    draw_urban_areas(ax=ax)\n    draw_snapshot(graph=graph, dynamics_data=dynamics_data, ax=ax)\n\n    # Place the legend on the South Pacific Ocean\n    ax.legend(loc=\"lower left\")\n\n    if output_file is not None:\n        plt.savefig(output_file, bbox_inches=\"tight\")\n\n    return ax\n</code></pre>"},{"location":"reference/cosmica/cli/plot/#cosmica.cli.plot.main","title":"main","text":"<pre><code>main(\n    constellation_path: Path | None = None,\n    gateways_path: Path | None = None,\n    start_time_arg: datetime | None = None,\n    duration_arg: str | None = None,\n    time_step_arg: str = \"1m\",\n    check_links: bool = False,\n    output: Path | None = None,\n    seed: int | None = None,\n    inter_plane_offset: int = 0,\n    last_to_first_plane_offset: int = 0,\n    max_inter_satellite_distance_km: float = 6000,\n    lowest_altitude_km: float = 80,\n    max_relative_angular_velocity_dps: float = 1,\n    sun_exclusion_angle_deg: float = 5,\n) -&gt; NoReturn\n</code></pre> Source code in <code>src/cosmica/cli/plot.py</code> <pre><code>def main(  # noqa: C901, PLR0912, PLR0915\n    constellation_path: Annotated[\n        Path | None,\n        typer.Option(\n            \"--constellation\",\n            help=\"Path to the constellation TOML file. If not provided, no satellite will be shown\",\n        ),\n    ] = None,\n    gateways_path: Annotated[\n        Path | None,\n        typer.Option(\"--gateways\", help=\"Path to the gateways TOML file. If not provided, no gateway will be shown\"),\n    ] = None,\n    start_time_arg: Annotated[datetime | None, typer.Option(\"--time\", help=\"Start time of the plot\")] = None,\n    duration_arg: Annotated[\n        str | None,\n        typer.Option(\n            \"--duration\",\n            help=\"Duration of the plot. It will be parsed using `pandas.to_timedelta` (e.g., '1h', '30m'). \"\n            \" If not provided, only one frame will be plotted.\",\n        ),\n    ] = None,\n    time_step_arg: Annotated[\n        str,\n        typer.Option(\n            \"--time-step\",\n            help=\"Time step of the plot. It will be parsed using `pandas.to_timedelta` (e.g., '1m')\",\n        ),\n    ] = \"1m\",\n    check_links: Annotated[  # noqa: FBT002\n        bool,\n        typer.Option(..., help=\"Check link availability and show only the available link edges\"),\n    ] = False,\n    output: Annotated[Path | None, typer.Option(..., help=\"Path to the output file\")] = None,\n    seed: Annotated[int | None, typer.Option(\"--seed\", help=\"Seed for the random number generator\")] = None,\n    inter_plane_offset: Annotated[\n        int,\n        typer.Option(\n            \"--inter-plane-offset\",\n            help=\"Offset between the planes of the constellation\",\n            show_default=True,\n        ),\n    ] = 0,\n    last_to_first_plane_offset: Annotated[\n        int,\n        typer.Option(\n            \"--last-to-first-plane-offset\",\n            help=\"Offset between the last and the first planes of the constellation\",\n            show_default=True,\n        ),\n    ] = 0,\n    max_inter_satellite_distance_km: Annotated[\n        float,\n        typer.Option(\n            \"--max-inter-satellite-distance\",\n            help=\"Maximum distance between two satellites for communication (km). Used for link availability check.\",\n            show_default=True,\n        ),\n    ] = 6_000,\n    lowest_altitude_km: Annotated[\n        float,\n        typer.Option(\n            \"--lowest-altitude\",\n            help=\"Lowest altitude for communication (km). Used for link availability check.\",\n            show_default=True,\n        ),\n    ] = 80,\n    max_relative_angular_velocity_dps: Annotated[\n        float,\n        typer.Option(\n            \"--max-relative-angular-velocity\",\n            help=\"Maximum relative angular velocity between two satellites for communication (deg/s). \"\n            \"Used for link availability check.\",\n            show_default=True,\n        ),\n    ] = 1,\n    sun_exclusion_angle_deg: Annotated[\n        float,\n        typer.Option(\n            \"--sun-exclusion-angle\",\n            help=\"Sun exclusion angle (deg). Used for link availability check.\",\n            show_default=True,\n        ),\n    ] = 5,\n) -&gt; NoReturn:\n    # Sanitize the inputs\n    constellation = MultiOrbitalPlaneConstellation.from_toml_file(constellation_path) if constellation_path else None\n    gateways: list[Gateway[Any]] | None = Gateway.from_toml_file(gateways_path) if gateways_path else None\n\n    rng = np.random.default_rng(seed)\n\n    # Construct the time array\n    time: npt.NDArray[np.datetime64]\n    if duration_arg is None:\n        time = np.array([np.datetime64(start_time_arg)]) if start_time_arg else np.array([np.datetime64(\"now\")])\n    else:\n        start_time = np.datetime64(start_time_arg) if start_time_arg else np.datetime64(\"now\")\n        try:\n            duration = np.timedelta64(pd.to_timedelta(duration_arg))\n        except ValueError:\n            msg = \"It should be parsable by `pandas.to_timedelta`.\"\n            raise typer.BadParameter(\n                msg,\n                param_hint=\"--duration\",\n            ) from None\n        try:\n            time_step = np.timedelta64(pd.to_timedelta(time_step_arg))\n        except ValueError:\n            msg = \"It should be parsable by `pandas.to_timedelta`.\"\n            raise typer.BadParameter(\n                msg,\n                param_hint=\"--time-step\",\n            ) from None\n        time = np.arange(start_time, start_time + duration, time_step)\n\n    dcm_eci2ecef = calc_dcm_eci2ecef(time)\n    sun_dir_eci = get_sun_direction_eci(time)\n    sun_dir_ecef = np.stack(\n        [\n            dcm_eci2ecef_t @ sun_dir_eci_t  # type: ignore[operator]\n            for dcm_eci2ecef_t, sun_dir_eci_t in zip(dcm_eci2ecef, sun_dir_eci, strict=True)\n        ],\n    )\n    if constellation is not None:\n        graph_c = ManhattanTopologyBuilder(\n            inter_plane_offset=inter_plane_offset,\n            last_to_first_plane_offset=last_to_first_plane_offset,\n        ).build(constellation=constellation)\n\n        # Calculate the dynamics data\n        result = constellation.propagate(time)\n        position_ecef = {satellite: result[satellite].calc_position_ecef(dcm_eci2ecef) for satellite in result}\n        # attitude angular velocity is assumed to be the same as the orbital angular velocity\n        satellite_attitude_angular_velocity = {\n            satellite: np.cross(state.position_eci, state.velocity_eci)\n            / rowwise_innerdot(state.position_eci, state.position_eci, keepdims=True)\n            for satellite, state in result.items()\n        }\n\n        dynamics_data = DynamicsData(\n            time=time,\n            dcm_eci2ecef=dcm_eci2ecef,\n            satellite_position_eci={satellite: state.position_eci for satellite, state in result.items()},\n            satellite_velocity_eci={satellite: state.velocity_eci for satellite, state in result.items()},\n            satellite_position_ecef=position_ecef,\n            satellite_attitude_angular_velocity_eci=satellite_attitude_angular_velocity,\n            sun_direction_eci=sun_dir_eci,\n            sun_direction_ecef=sun_dir_ecef,\n        )\n\n        graphs_g2c = ElevationBasedG2CTopologyBuilder().build(\n            constellation=constellation,\n            ground_nodes=gateways if gateways is not None else [],\n            dynamics_data=dynamics_data,\n        )\n        graphs = [nx.compose(graph_c, graph_g2c) for graph_g2c in graphs_g2c]\n    else:\n        if gateways is None:\n            msg = \"Either `constellation` or `gateways` must be provided.\"\n            raise typer.BadParameter(msg)\n        graph_g = nx.Graph()\n        graph_g.add_nodes_from(gateways)\n        graphs = [graph_g for _ in time]\n        dynamics_data = DynamicsData(\n            time=time,\n            dcm_eci2ecef=dcm_eci2ecef,\n            satellite_position_eci={},\n            satellite_velocity_eci={},\n            satellite_position_ecef={},\n            satellite_attitude_angular_velocity_eci={},\n            sun_direction_eci=sun_dir_eci,\n            sun_direction_ecef=sun_dir_ecef,\n        )\n\n    if check_links:\n        s2s_calculator = SatToSatBinaryCommLinkCalculator(\n            inter_satellite_link_capacity=1e9,  # 1 Gbps\n            max_inter_satellite_distance=max_inter_satellite_distance_km * 1e3,\n            lowest_altitude=lowest_altitude_km * 1e3,\n            max_relative_angular_velocity=np.deg2rad(max_relative_angular_velocity_dps),\n            sun_exclusion_angle=np.deg2rad(sun_exclusion_angle_deg),\n        )\n        s2g_calculator = SatToGatewayBinaryCommLinkCalculator(\n            satellite_to_gateway_link_capacity=1e9,  # 1 Gbps\n        )\n        coordinator = CommLinkCalculationCoordinator(\n            calculator_assignment={\n                (ConstellationSatellite, ConstellationSatellite): MemorylessCommLinkCalculatorWrapper(s2s_calculator),\n                (ConstellationSatellite, Gateway): MemorylessCommLinkCalculatorWrapper(s2g_calculator),\n            },\n        )\n\n        link_performance = coordinator.calc(\n            [graph.edges for graph in graphs],\n            dynamics_data=dynamics_data,\n            rng=rng,\n        )\n        for graph, performance in zip(graphs, link_performance, strict=True):\n            nx.set_edge_attributes(graph, performance)\n            unavailable_edges = [edge for edge, perf in performance.items() if not perf[\"link_available\"]]\n            graph.remove_edges_from(unavailable_edges)\n\n    if duration_arg is None:\n        # Plot only one frame\n        # The axis is assigned to a variable to prevent it from being garbage collected (just in case)\n        _ax = draw_graph(graph=graphs[0], dynamics_data=dynamics_data[0], output_file=output)\n        if output is None:\n            plt.show()\n    else:\n        # The animation should be assigned to a variable to prevent it from being garbage collected\n        _ani = animate_graphs(graphs=graphs, dynamics_data=dynamics_data)\n        if output is None:\n            plt.show()\n\n    raise typer.Exit\n</code></pre>"},{"location":"reference/cosmica/comm_link/","title":"comm_link","text":""},{"location":"reference/cosmica/comm_link/#cosmica.comm_link","title":"cosmica.comm_link","text":""},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"ApertureAveragedLogNormalScintillationModel\",\n    \"AtmosphericScintillationModel\",\n    \"BinaryCloudModel\",\n    \"CloudStates\",\n    \"CommLinkCalculationCoordinator\",\n    \"CommLinkCalculator\",\n    \"CommLinkPerformance\",\n    \"EdgeFailureModel\",\n    \"ExpEdgeModel\",\n    \"GatewayToGatewayCommLinkCalculator\",\n    \"GatewayToInternetCommLinkCalculator\",\n    \"GeometricCommLinkCalculator\",\n    \"MemorylessCommLinkCalculator\",\n    \"MemorylessCommLinkCalculatorWrapper\",\n    \"OTC2OTCBinaryCommLinkCalculator\",\n    \"SatToGatewayBinaryCommLinkCalculator\",\n    \"SatToGatewayBinaryCommLinkCalculatorWithScintillation\",\n    \"SatToGatewayBinaryMemoryCommLinkCalculator\",\n    \"SatToGatewayStochasticBinaryCommLinkCalculator\",\n    \"SatToSatBinaryCommLinkCalculator\",\n    \"SatToSatBinaryCommLinkCalculatorWithRateCalc\",\n    \"SatToSatBinaryMemoryCommLinkCalculator\",\n]\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ApertureAveragedLogNormalScintillationModel","title":"ApertureAveragedLogNormalScintillationModel  <code>dataclass</code>","text":"<pre><code>ApertureAveragedLogNormalScintillationModel(\n    *,\n    default_rytov_variance: float,\n    wavelength: float,\n    aperture_diameter: float\n)\n</code></pre> <p>               Bases: <code>AtmosphericScintillationModel[bool_]</code></p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ApertureAveragedLogNormalScintillationModel.aperture_diameter","title":"aperture_diameter  <code>instance-attribute</code>","text":"<pre><code>aperture_diameter: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ApertureAveragedLogNormalScintillationModel.default_rytov_variance","title":"default_rytov_variance  <code>instance-attribute</code>","text":"<pre><code>default_rytov_variance: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ApertureAveragedLogNormalScintillationModel.k_number","title":"k_number  <code>cached</code> <code>property</code>","text":"<pre><code>k_number: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ApertureAveragedLogNormalScintillationModel.wavelength","title":"wavelength  <code>instance-attribute</code>","text":"<pre><code>wavelength: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ApertureAveragedLogNormalScintillationModel.sample","title":"sample","text":"<pre><code>sample(\n    rng: Generator,\n    link_distance: float,\n    rytov_variance: float | None = None,\n) -&gt; float\n</code></pre> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>def sample(\n    self,\n    rng: np.random.Generator,\n    link_distance: float,\n    rytov_variance: float | None = None,\n) -&gt; float:\n    sigma2_scintillation = self.sigma2_scintillation(link_distance, rytov_variance)\n    return rng.lognormal(-sigma2_scintillation / 2, sigma2_scintillation)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ApertureAveragedLogNormalScintillationModel.scaled_aperture","title":"scaled_aperture","text":"<pre><code>scaled_aperture(link_distance: float) -&gt; float\n</code></pre> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>def scaled_aperture(self, link_distance: float) -&gt; float:\n    return np.sqrt((self.k_number * self.aperture_diameter**2) / (4 * link_distance))\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ApertureAveragedLogNormalScintillationModel.sigma2_scintillation","title":"sigma2_scintillation","text":"<pre><code>sigma2_scintillation(\n    link_distance: float,\n    ryotv_variance: float | None = None,\n) -&gt; float\n</code></pre> RETURNS DESCRIPTION <code>float</code> <p>Float approximation for aperture averaged scintillation for a plane-wave in the absence of inner scale andouter scale effects as described by Larry C. Andrews and Ronald L. Phillips in the book \"Laser BeamPropagation through Random Media\" Chapter 10.</p> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>def sigma2_scintillation(\n    self,\n    link_distance: float,\n    ryotv_variance: float | None = None,\n) -&gt; Annotated[\n    float,\n    Doc(\n        \"Float approximation for aperture averaged scintillation for a plane-wave in the absence of inner scale and\"\n        'outer scale effects as described by Larry C. Andrews and Ronald L. Phillips in the book \"Laser Beam'\n        'Propagation through Random Media\" Chapter 10.',\n    ),\n]:\n    if ryotv_variance is not None and self.default_rytov_variance != ryotv_variance:\n        ryotv_variance = self.default_rytov_variance\n    scaled_aperture = self.scaled_aperture(link_distance=link_distance)\n    num1 = 0.49 * self.default_rytov_variance\n    den1 = (1 + 0.65 * scaled_aperture**2 + 1.11 * self.default_rytov_variance ** (6 / 5)) ** (7 / 6)\n    num2 = 0.51 * self.default_rytov_variance * (1 + 0.69 * self.default_rytov_variance ** (6 / 5)) ** (-5 / 6)\n    den2 = 1 + 0.90 * scaled_aperture**2 + 0.62 * scaled_aperture**2 * self.default_rytov_variance ** (6 / 5)\n    return np.exp(num1 / den1 + num2 / den2) - 1\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.AtmosphericScintillationModel","title":"AtmosphericScintillationModel","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.AtmosphericScintillationModel.sample","title":"sample  <code>abstractmethod</code>","text":"<pre><code>sample(\n    rng: Generator,\n    link_distance: float,\n    rytov_variance: float | None = None,\n) -&gt; float\n</code></pre> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    rng: np.random.Generator,\n    link_distance: float,\n    rytov_variance: float | None = None,\n) -&gt; float: ...\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.BinaryCloudModel","title":"BinaryCloudModel  <code>dataclass</code>","text":"<pre><code>BinaryCloudModel(\n    *,\n    initial_cloud: bool = False,\n    transition_p_0_to_1: float = 0.15,\n    transition_p_1_to_0: float = 0.4\n)\n</code></pre> <p>               Bases: <code>CloudStates[bool_]</code></p> <p>Binary Cloud Model.</p> <p>Generate the state of clouds described by a Markov Chain by calling the 'simulate' method.</p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.BinaryCloudModel.initial_cloud","title":"initial_cloud  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_cloud: bool = False\n</code></pre> <p>Initial state. True indicates cloudy and False indicates free-of-clouds.</p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.BinaryCloudModel.transition_p_0_to_1","title":"transition_p_0_to_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transition_p_0_to_1: float = 0.15\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.BinaryCloudModel.transition_p_1_to_0","title":"transition_p_1_to_0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transition_p_1_to_0: float = 0.4\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.BinaryCloudModel.simulate","title":"simulate","text":"<pre><code>simulate(\n    time: NDArray[datetime64], rng: Generator\n) -&gt; NDArray[bool_]\n</code></pre> PARAMETER DESCRIPTION <code>time</code> <p>time_array as a np.ndarray with elements in the np.datetime64 format</p> <p> TYPE: <code>NDArray[datetime64]</code> </p> <code>rng</code> <p>NumPy random number generator.</p> <p> TYPE: <code>Generator</code> </p> RETURNS DESCRIPTION <code>NDArray[bool_]</code> <p>time series of cloud states on given time frame (1|True = cloudy, 0|False = Free-of-clouds)</p> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>def simulate(\n    self,\n    time: Annotated[\n        npt.NDArray[np.datetime64],\n        Doc(\"time_array as a np.ndarray with elements in the np.datetime64 format\"),\n    ],\n    rng: Annotated[np.random.Generator, Doc(\"NumPy random number generator.\")],\n) -&gt; Annotated[\n    npt.NDArray[np.bool_],\n    Doc(\"time series of cloud states on given time frame (1|True = cloudy, 0|False = Free-of-clouds)\"),\n]:\n    sampled = np.empty(time.shape[0], dtype=bool)\n    current_state = self.initial_cloud\n\n    for i in range(time.shape[0]):\n        sampled[i] = current_state\n        next_state = rng.choice(np.array([0, 1]), size=1, p=self._state_tm[int(current_state)])[0]\n        current_state = next_state\n    return sampled\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CloudStates","title":"CloudStates","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CloudStates.simulate","title":"simulate  <code>abstractmethod</code>","text":"<pre><code>simulate(\n    time: NDArray[datetime64], rng: Generator\n) -&gt; NDArray[T]\n</code></pre> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>@abstractmethod\ndef simulate(self, time: npt.NDArray[np.datetime64], rng: np.random.Generator) -&gt; npt.NDArray[T]: ...\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CommLinkCalculationCoordinator","title":"CommLinkCalculationCoordinator","text":"<pre><code>CommLinkCalculationCoordinator(\n    *,\n    calculator_assignment: Mapping[\n        EdgeType, CommLinkCalculator\n    ],\n    directed: bool = False\n)\n</code></pre> Source code in <code>src/cosmica/comm_link/coordinator.py</code> <pre><code>def __init__(\n    self,\n    *,\n    calculator_assignment: Mapping[EdgeType, CommLinkCalculator],\n    directed: bool = False,\n) -&gt; None:\n    self.calculator_assignment = dict(calculator_assignment)\n    self.directed = directed\n\n    if not self.directed:\n        assert len(set(self.calculator_assignment)) == len(\n            self.calculator_assignment,\n        ), \"All edge types must be unique.\"\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CommLinkCalculationCoordinator.calculator_assignment","title":"calculator_assignment  <code>instance-attribute</code>","text":"<pre><code>calculator_assignment = dict(calculator_assignment)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CommLinkCalculationCoordinator.directed","title":"directed  <code>instance-attribute</code>","text":"<pre><code>directed = directed\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CommLinkCalculationCoordinator.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[\n        Collection[tuple[Node, Node]]\n    ],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[dict[tuple[Node, Node], CommLinkPerformance]]\n</code></pre> Source code in <code>src/cosmica/comm_link/coordinator.py</code> <pre><code>def calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[Node, Node]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[Node, Node], CommLinkPerformance]]:\n    assert len(dynamics_data.time) == len(edges_time_series)\n\n    if self.directed:\n        msg = \"calc_time_series is only supported for undirected calculators.\"\n        raise NotImplementedError(msg)\n    return self._calc_undirected(edges_time_series, dynamics_data=dynamics_data, rng=rng)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CommLinkCalculator","title":"CommLinkCalculator","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CommLinkCalculator.calc","title":"calc  <code>abstractmethod</code>","text":"<pre><code>calc(\n    edges_time_series: Sequence[Collection[tuple[T, U]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[dict[tuple[T, U], CommLinkPerformance]]\n</code></pre> <p>Calculate communication link performance for each edge in a network.</p> Source code in <code>src/cosmica/comm_link/base.py</code> <pre><code>@abstractmethod\ndef calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[T, U]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[T, U], CommLinkPerformance]]:\n    \"\"\"Calculate communication link performance for each edge in a network.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CommLinkPerformance","title":"CommLinkPerformance","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CommLinkPerformance.delay","title":"delay  <code>instance-attribute</code>","text":"<pre><code>delay: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CommLinkPerformance.link_available","title":"link_available  <code>instance-attribute</code>","text":"<pre><code>link_available: bool\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.CommLinkPerformance.link_capacity","title":"link_capacity  <code>instance-attribute</code>","text":"<pre><code>link_capacity: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.EdgeFailureModel","title":"EdgeFailureModel","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.EdgeFailureModel.simulate","title":"simulate  <code>abstractmethod</code>","text":"<pre><code>simulate(\n    time: NDArray[datetime64], rng: Generator\n) -&gt; NDArray[T]\n</code></pre> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>@abstractmethod\ndef simulate(self, time: npt.NDArray[np.datetime64], rng: np.random.Generator) -&gt; npt.NDArray[T]: ...\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ExpEdgeModel","title":"ExpEdgeModel  <code>dataclass</code>","text":"<pre><code>ExpEdgeModel(\n    *,\n    reliability: timedelta64 = (\n        lambda: timedelta64(15, \"D\")\n    )(),\n    recovery_time: timedelta64 = (\n        lambda: timedelta64(1800, \"s\")\n    )()\n)\n</code></pre> <p>               Bases: <code>EdgeFailureModel[bool_]</code></p> <p>Exponential Edge Model.</p> <p>Generate the state of an edge following an exponential distribution by calling the 'simulate' method. An edge can be thought as the link between two nodes (e.g. terminals, satellites)</p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ExpEdgeModel.recovery_time","title":"recovery_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>recovery_time: timedelta64 = field(\n    default_factory=lambda: timedelta64(1800, \"s\")\n)\n</code></pre> <p>Recovery time in seconds (expected)</p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ExpEdgeModel.reliability","title":"reliability  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reliability: timedelta64 = field(\n    default_factory=lambda: timedelta64(15, \"D\")\n)\n</code></pre> <p>time length in days which the edge is expected not to fail (Expected value of exponential distribution)</p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.ExpEdgeModel.simulate","title":"simulate","text":"<pre><code>simulate(\n    time: NDArray[datetime64], rng: Generator\n) -&gt; NDArray[bool_]\n</code></pre> PARAMETER DESCRIPTION <code>time</code> <p>time_array as a np.ndarray with elements in the np.datetime64 format</p> <p> TYPE: <code>NDArray[datetime64]</code> </p> <code>rng</code> <p>NumPy random number generator</p> <p> TYPE: <code>Generator</code> </p> RETURNS DESCRIPTION <code>NDArray[bool_]</code> <p>time series of edge states on given time frame (True = Failure, False= No-failure)</p> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>def simulate(\n    self,\n    time: Annotated[\n        npt.NDArray[np.datetime64],\n        Doc(\"time_array as a np.ndarray with elements in the np.datetime64 format\"),\n    ],\n    rng: Annotated[np.random.Generator, Doc(\"NumPy random number generator\")],\n) -&gt; Annotated[\n    npt.NDArray[np.bool_],\n    Doc(\"time series of edge states on given time frame (True = Failure, False= No-failure)\"),\n]:\n    state_changed = np.zeros(time.shape, dtype=np.bool_)\n    time_step = time[1] - time[0]\n    total_time = time[-1] - time[0]\n\n    failure_time: np.timedelta64 = rng.exponential(self.reliability / _SECOND) * _SECOND\n    while failure_time &lt;= total_time:\n        failure_idx: int = np.where(time &gt; (time[0] + failure_time))[0][0]\n        state_changed[failure_idx] = True\n        recovery_idx = failure_idx + int(self.recovery_time / time_step)\n        if recovery_idx &lt; state_changed.shape[0]:  # type: ignore[misc] # Possibly a typing bug in NumPy\n            state_changed[recovery_idx] = True\n        else:\n            return np.logical_xor.accumulate(state_changed)\n        failure_time += self.recovery_time + rng.exponential(self.reliability / _SECOND) * _SECOND\n    return np.logical_xor.accumulate(state_changed)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GatewayToGatewayCommLinkCalculator","title":"GatewayToGatewayCommLinkCalculator","text":"<pre><code>GatewayToGatewayCommLinkCalculator(\n    *,\n    gateway_to_gateway_bandwidth: float,\n    refractive_index: float = 1.5\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Gateway, Gateway]</code></p> <p>Calculate gateway-to-gateway communication link performance using great circle distance.</p> <p>Initialize the gateway-to-gateway communication link calculator.</p> Source code in <code>src/cosmica/comm_link/gateway_to_gateway.py</code> <pre><code>def __init__(\n    self,\n    *,\n    gateway_to_gateway_bandwidth: float,\n    refractive_index: float = 1.5,\n) -&gt; None:\n    \"\"\"Initialize the gateway-to-gateway communication link calculator.\"\"\"\n    self.gateway_to_gateway_bandwidth = gateway_to_gateway_bandwidth\n    self.refractive_index = refractive_index\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GatewayToGatewayCommLinkCalculator.gateway_to_gateway_bandwidth","title":"gateway_to_gateway_bandwidth  <code>instance-attribute</code>","text":"<pre><code>gateway_to_gateway_bandwidth = gateway_to_gateway_bandwidth\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GatewayToGatewayCommLinkCalculator.refractive_index","title":"refractive_index  <code>instance-attribute</code>","text":"<pre><code>refractive_index = refractive_index\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GatewayToGatewayCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Gateway, Gateway]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[Gateway, Gateway], CommLinkPerformance]\n</code></pre> <p>Calculate communication link performance for gateway-to-gateway edges.</p> Source code in <code>src/cosmica/comm_link/gateway_to_gateway.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Gateway, Gateway]],\n    *,\n    dynamics_data: DynamicsData,  # noqa: ARG002 For interface compatibility\n    rng: np.random.Generator,  # noqa: ARG002 For interface compatibility\n) -&gt; dict[tuple[Gateway, Gateway], CommLinkPerformance]:\n    \"\"\"Calculate communication link performance for gateway-to-gateway edges.\"\"\"\n    return {\n        edge: self._calc_gateway_to_gateway(\n            gateway1=edge[0],\n            gateway2=edge[1],\n        )\n        for edge in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GatewayToInternetCommLinkCalculator","title":"GatewayToInternetCommLinkCalculator","text":"<pre><code>GatewayToInternetCommLinkCalculator(\n    *,\n    gateway_to_internet_link_capacity: float,\n    gateway_to_internet_delay: float\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Gateway, Internet]</code></p> <p>Calculates the communication link between a gateway and an internet.</p> Source code in <code>src/cosmica/comm_link/gateway_to_internet.py</code> <pre><code>def __init__(\n    self,\n    *,\n    gateway_to_internet_link_capacity: float,\n    gateway_to_internet_delay: float,\n) -&gt; None:\n    self.gateway_to_internet_link_capacity = gateway_to_internet_link_capacity\n    self.gateway_to_internet_delay = gateway_to_internet_delay\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GatewayToInternetCommLinkCalculator.gateway_to_internet_delay","title":"gateway_to_internet_delay  <code>instance-attribute</code>","text":"<pre><code>gateway_to_internet_delay = gateway_to_internet_delay\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GatewayToInternetCommLinkCalculator.gateway_to_internet_link_capacity","title":"gateway_to_internet_link_capacity  <code>instance-attribute</code>","text":"<pre><code>gateway_to_internet_link_capacity = (\n    gateway_to_internet_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GatewayToInternetCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Gateway, Internet]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[Gateway, Internet], CommLinkPerformance]\n</code></pre> Source code in <code>src/cosmica/comm_link/gateway_to_internet.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Gateway, Internet]],\n    *,\n    dynamics_data: DynamicsData,  # noqa: ARG002 For interface compatibility\n    rng: np.random.Generator,  # noqa: ARG002 For interface compatibility\n) -&gt; dict[tuple[Gateway, Internet], CommLinkPerformance]:\n    return {\n        (gateway, internet): CommLinkPerformance(\n            link_capacity=self.gateway_to_internet_link_capacity,\n            delay=self.gateway_to_internet_delay,\n            link_available=True,\n        )\n        for gateway, internet in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GeometricCommLinkCalculator","title":"GeometricCommLinkCalculator","text":"<pre><code>GeometricCommLinkCalculator(\n    *,\n    inter_satellite_link_capacity: float,\n    satellite_to_gateway_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\")\n)\n</code></pre> <p>Calculate geometric communication link performance for each edge in a network.</p> Source code in <code>src/cosmica/comm_link/geometric.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_satellite_link_capacity: float,\n    satellite_to_gateway_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n) -&gt; None:\n    warnings.warn(\n        \"GeometricCommLinkCalculator is deprecated.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    self.max_inter_satellite_distance = max_inter_satellite_distance\n    self.inter_satellite_link_capacity = inter_satellite_link_capacity\n    self.satellite_to_gateway_link_capacity = satellite_to_gateway_link_capacity\n    self.lowest_altitude = lowest_altitude\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GeometricCommLinkCalculator.inter_satellite_link_capacity","title":"inter_satellite_link_capacity  <code>instance-attribute</code>","text":"<pre><code>inter_satellite_link_capacity = (\n    inter_satellite_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GeometricCommLinkCalculator.lowest_altitude","title":"lowest_altitude  <code>instance-attribute</code>","text":"<pre><code>lowest_altitude = lowest_altitude\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GeometricCommLinkCalculator.max_inter_satellite_distance","title":"max_inter_satellite_distance  <code>instance-attribute</code>","text":"<pre><code>max_inter_satellite_distance = max_inter_satellite_distance\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GeometricCommLinkCalculator.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GeometricCommLinkCalculator.satellite_to_gateway_link_capacity","title":"satellite_to_gateway_link_capacity  <code>instance-attribute</code>","text":"<pre><code>satellite_to_gateway_link_capacity = (\n    satellite_to_gateway_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.GeometricCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    graph: Graph,\n    *,\n    satellite_position_eci: dict[\n        ConstellationSatellite, NDArray[float64]\n    ],\n    satellite_velocity_eci: dict[\n        ConstellationSatellite, NDArray[float64]\n    ],\n    satellite_position_ecef: dict[\n        ConstellationSatellite, NDArray[float64]\n    ],\n    satellite_attitude_angular_velocity_eci: dict[\n        ConstellationSatellite, NDArray[float64]\n    ]\n) -&gt; dict[_EdgeType, CommLinkPerformance]\n</code></pre> <p>Calculate geometric communication link performance for each edge in a network.</p> Source code in <code>src/cosmica/comm_link/geometric.py</code> <pre><code>def calc(\n    self,\n    graph: nx.Graph,\n    *,\n    satellite_position_eci: dict[ConstellationSatellite, npt.NDArray[np.float64]],\n    satellite_velocity_eci: dict[ConstellationSatellite, npt.NDArray[np.float64]],\n    satellite_position_ecef: dict[ConstellationSatellite, npt.NDArray[np.float64]],\n    satellite_attitude_angular_velocity_eci: dict[ConstellationSatellite, npt.NDArray[np.float64]],\n) -&gt; dict[_EdgeType, CommLinkPerformance]:\n    \"\"\"Calculate geometric communication link performance for each edge in a network.\"\"\"\n    performance: dict[_EdgeType, CommLinkPerformance] = {}\n    for node1, node2 in graph.edges:\n        if isinstance(node1, ConstellationSatellite) and isinstance(node2, ConstellationSatellite):\n            performance[(node1, node2)] = self._calc_satellite_to_satellite(\n                positions_eci=(satellite_position_eci[node1], satellite_position_eci[node2]),\n                velocities_eci=(satellite_velocity_eci[node1], satellite_velocity_eci[node2]),\n                attitude_angular_velocities_eci=(\n                    satellite_attitude_angular_velocity_eci[node1],\n                    satellite_attitude_angular_velocity_eci[node2],\n                ),\n            )\n        elif isinstance(node1, ConstellationSatellite) and isinstance(node2, Gateway):\n            performance[(node1, node2)] = self._calc_satellite_to_gateway(satellite_position_ecef[node1], node2)\n        elif isinstance(node1, Gateway) and isinstance(node2, ConstellationSatellite):\n            performance[(node1, node2)] = self._calc_satellite_to_gateway(satellite_position_ecef[node2], node1)\n        else:\n            msg = f\"Invalid edge: {node1} -&gt; {node2}\"\n            raise TypeError(msg)\n    return performance\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.MemorylessCommLinkCalculator","title":"MemorylessCommLinkCalculator","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.MemorylessCommLinkCalculator.calc","title":"calc  <code>abstractmethod</code>","text":"<pre><code>calc(\n    edges: Collection[tuple[T, U]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[T, U], CommLinkPerformance]\n</code></pre> <p>Calculate communication link performance for each edge in a network.</p> Source code in <code>src/cosmica/comm_link/base.py</code> <pre><code>@abstractmethod\ndef calc(\n    self,\n    edges: Collection[tuple[T, U]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; dict[tuple[T, U], CommLinkPerformance]:\n    \"\"\"Calculate communication link performance for each edge in a network.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.MemorylessCommLinkCalculatorWrapper","title":"MemorylessCommLinkCalculatorWrapper","text":"<pre><code>MemorylessCommLinkCalculatorWrapper(\n    memoryless_calculator: MemorylessCommLinkCalculator[\n        T, U\n    ],\n)\n</code></pre> <p>               Bases: <code>CommLinkCalculator[T, U]</code></p> <p>Convert a memoryless calculator to a time series calculator by calling the memoryless one at each time step.</p> Source code in <code>src/cosmica/comm_link/base.py</code> <pre><code>def __init__(\n    self,\n    memoryless_calculator: MemorylessCommLinkCalculator[T, U],\n    /,\n) -&gt; None:\n    self.memoryless_calculator = memoryless_calculator\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.MemorylessCommLinkCalculatorWrapper.memoryless_calculator","title":"memoryless_calculator  <code>instance-attribute</code>","text":"<pre><code>memoryless_calculator = memoryless_calculator\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.MemorylessCommLinkCalculatorWrapper.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[Collection[tuple[T, U]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[dict[tuple[T, U], CommLinkPerformance]]\n</code></pre> Source code in <code>src/cosmica/comm_link/base.py</code> <pre><code>def calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[T, U]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[T, U], CommLinkPerformance]]:\n    assert len(edges_time_series) == len(\n        dynamics_data.time,\n    ), \"edges_time_series must have the same length as dynamics_data.time\"\n    return [\n        self.memoryless_calculator.calc(edges=edges, dynamics_data=dynamics_data[time_index], rng=rng)\n        for time_index, edges in enumerate(edges_time_series)\n    ]\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.OTC2OTCBinaryCommLinkCalculator","title":"OTC2OTCBinaryCommLinkCalculator","text":"<pre><code>OTC2OTCBinaryCommLinkCalculator(\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0\n)\n</code></pre> <p>               Bases: <code>CommLinkCalculator[SatelliteTerminal, SatelliteTerminal]</code></p> <p>Calculate satellite-to-satellite communication link performance for each terminal in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n) -&gt; None:\n    self.max_inter_satellite_distance = max_inter_satellite_distance\n    self.inter_satellite_link_capacity = inter_satellite_link_capacity\n    self.lowest_altitude = lowest_altitude\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n    self.sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.OTC2OTCBinaryCommLinkCalculator.inter_satellite_link_capacity","title":"inter_satellite_link_capacity  <code>instance-attribute</code>","text":"<pre><code>inter_satellite_link_capacity = (\n    inter_satellite_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.OTC2OTCBinaryCommLinkCalculator.lowest_altitude","title":"lowest_altitude  <code>instance-attribute</code>","text":"<pre><code>lowest_altitude = lowest_altitude\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.OTC2OTCBinaryCommLinkCalculator.max_inter_satellite_distance","title":"max_inter_satellite_distance  <code>instance-attribute</code>","text":"<pre><code>max_inter_satellite_distance = max_inter_satellite_distance\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.OTC2OTCBinaryCommLinkCalculator.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.OTC2OTCBinaryCommLinkCalculator.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.OTC2OTCBinaryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[\n        Collection[\n            tuple[SatelliteTerminal, SatelliteTerminal]\n        ]\n    ],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[\n    dict[\n        tuple[SatelliteTerminal, SatelliteTerminal],\n        CommLinkPerformance,\n    ]\n]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[SatelliteTerminal, SatelliteTerminal]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator,  # noqa: ARG002\n) -&gt; list[dict[tuple[SatelliteTerminal, SatelliteTerminal], CommLinkPerformance]]:\n    terminal_memo: dict[tuple[SatelliteTerminal, SatelliteTerminal], list[tuple[float, float]]] = {}\n    comm_link_time_series = []\n    prev_time = dynamics_data.time[0]\n\n    for i, snapshot in enumerate(edges_time_series):\n        edges_performance = {}\n        current_time = dynamics_data.time[i]\n        time_delta = current_time - prev_time if i != 0 else 1\n        if time_delta == 0:\n            msg = \"time_delta must be non-zero\"\n            raise ValueError(msg)\n        # Note: the terminal angular velocity and pointing verifications in the first iteration will return\n        # meaningless results and should be disconsidered during analysis.\n\n        for edge in snapshot:\n            # TODO(): \u30a8\u30c3\u30b8\u304ctuple\u3068\u3057\u3066\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u9806\u5e8f\u3092\u8003\u616e\u3057\u3066\u8abf\u3079\u308b\u5fc5\u8981\u304c\u3042\u308b\n            previous_terminal_directions = terminal_memo.get(edge, [(0.0, 0.0), (0.0, 0.0)])\n\n            # TODO(): \u304a\u305d\u3089\u304f dynamics_data \u306e\u4e2d\u3067\u5404\u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u306e\u5024\u3092\u53d6\u3063\u3066\u304f\u308b\u5fc5\u8981\u304c\u3042\u308b\n            comm_link_performance, terminal_directions = self._calc_satellite_to_satellite(\n                positions_eci=(\n                    dynamics_data.satellite_position_eci[edge[0]],\n                    dynamics_data.satellite_position_eci[edge[1]],\n                ),\n                velocities_eci=(\n                    dynamics_data.satellite_velocity_eci[edge[0]],\n                    dynamics_data.satellite_velocity_eci[edge[1]],\n                ),\n                attitude_angular_velocities_eci=(\n                    dynamics_data.satellite_attitude_angular_velocity_eci[edge[0]],\n                    dynamics_data.satellite_attitude_angular_velocity_eci[edge[1]],\n                ),\n                sun_direction_eci=dynamics_data.sun_direction_eci,\n                terminals=(\n                    edge[0].terminal,\n                    edge[1].terminal,\n                ),\n                previous_terminal_directions=previous_terminal_directions,\n                time_delta=time_delta,\n            )\n\n            edges_performance[edge] = comm_link_performance\n            terminal_memo[edge] = terminal_directions\n\n        comm_link_time_series.append(edges_performance)\n        prev_time = current_time\n\n    return comm_link_time_series\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculator","title":"SatToGatewayBinaryCommLinkCalculator","text":"<pre><code>SatToGatewayBinaryCommLinkCalculator(\n    *,\n    satellite_to_gateway_link_capacity: float,\n    sun_exclusion_angle: float = 0.0\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Satellite, Gateway]</code></p> <p>Calculate satellite-to-gateway communication link performance for each edge in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def __init__(\n    self,\n    *,\n    satellite_to_gateway_link_capacity: float,\n    sun_exclusion_angle: float = 0.0,\n) -&gt; None:\n    self.satellite_to_gateway_link_capacity = satellite_to_gateway_link_capacity\n    self.sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculator.satellite_to_gateway_link_capacity","title":"satellite_to_gateway_link_capacity  <code>instance-attribute</code>","text":"<pre><code>satellite_to_gateway_link_capacity = (\n    satellite_to_gateway_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculator.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Satellite, Gateway]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[Satellite, Gateway], CommLinkPerformance]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Satellite, Gateway]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,  # noqa: ARG002 For interface compatibility\n) -&gt; dict[tuple[Satellite, Gateway], CommLinkPerformance]:\n    return {\n        edge: self._calc_satellite_to_gateway(\n            satellite_position_ecef=dynamics_data.satellite_position_ecef[edge[0]],\n            sun_direction_ecef=dynamics_data.sun_direction_ecef,\n            sun_exclusion_angle=self.sun_exclusion_angle,\n            gateway=edge[1],\n        )\n        for edge in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculatorWithScintillation","title":"SatToGatewayBinaryCommLinkCalculatorWithScintillation","text":"<pre><code>SatToGatewayBinaryCommLinkCalculatorWithScintillation(\n    *,\n    satellite_to_gateway_link_capacity: float,\n    link_capacity: float,\n    noise_figure: float,\n    lna_gain: float,\n    lct_p0: float,\n    turbulence_model_factory: Callable[\n        [GatewayOGS], AtmosphericScintillationModel\n    ] = lambda gateway: ApertureAveragedLogNormalScintillationModel(\n        default_rytov_variance=rytov_variance,\n        wavelength=1550 * 1e-09,\n        aperture_diameter=aperture_size,\n    )\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Satellite, GatewayOGS]</code></p> <p>Calculate satellite-to-gateway communication link performance for each edge in a network with turbulence.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def __init__(\n    self,\n    *,\n    satellite_to_gateway_link_capacity: float,\n    link_capacity: float,\n    noise_figure: float,\n    lna_gain: float,\n    lct_p0: float,\n    turbulence_model_factory: Callable[\n        [GatewayOGS],\n        AtmosphericScintillationModel,\n    ] = lambda gateway: ApertureAveragedLogNormalScintillationModel(\n        default_rytov_variance=gateway.rytov_variance,\n        wavelength=1550 * 1e-9,\n        aperture_diameter=gateway.aperture_size,\n    ),\n) -&gt; None:\n    self.satellite_to_gateway_link_capacity = satellite_to_gateway_link_capacity\n    self.link_capacity = link_capacity\n    self.noise_figure = noise_figure\n    self.lna_gain = lna_gain\n    self.lct_p0 = lct_p0\n    self.turbulence_model_factory = turbulence_model_factory\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculatorWithScintillation.lct_p0","title":"lct_p0  <code>instance-attribute</code>","text":"<pre><code>lct_p0 = lct_p0\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculatorWithScintillation.link_capacity","title":"link_capacity  <code>instance-attribute</code>","text":"<pre><code>link_capacity = link_capacity\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculatorWithScintillation.lna_gain","title":"lna_gain  <code>instance-attribute</code>","text":"<pre><code>lna_gain = lna_gain\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculatorWithScintillation.noise_figure","title":"noise_figure  <code>instance-attribute</code>","text":"<pre><code>noise_figure = noise_figure\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculatorWithScintillation.satellite_to_gateway_link_capacity","title":"satellite_to_gateway_link_capacity  <code>instance-attribute</code>","text":"<pre><code>satellite_to_gateway_link_capacity = (\n    satellite_to_gateway_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculatorWithScintillation.turbulence_model_factory","title":"turbulence_model_factory  <code>instance-attribute</code>","text":"<pre><code>turbulence_model_factory = turbulence_model_factory\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryCommLinkCalculatorWithScintillation.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Satellite, GatewayOGS]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[\n    tuple[Satellite, GatewayOGS], CommLinkPerformance\n]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Satellite, GatewayOGS]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; dict[tuple[Satellite, GatewayOGS], CommLinkPerformance]:\n    gateway_turbulence_map = self._map_turbulence2gateway(edges)\n    return {\n        edge: self._calc_satellite_to_gateway(\n            satellite_position_ecef=dynamics_data.satellite_position_ecef[edge[0]],\n            sun_direction_ecef=dynamics_data.sun_direction_ecef,\n            sun_exclusion_angle=0.0,\n            rng=rng,\n            gateway=edge[1],\n            gateway_turbulence_map=gateway_turbulence_map,\n        )\n        for edge in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryMemoryCommLinkCalculator","title":"SatToGatewayBinaryMemoryCommLinkCalculator","text":"<pre><code>SatToGatewayBinaryMemoryCommLinkCalculator(\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[\n        Satellite, Gateway\n    ],\n    link_acquisition_time: float = 60,\n    skip_link_acquisition_at_simulation_start: bool = True\n)\n</code></pre> <p>               Bases: <code>CommLinkCalculator[Satellite, Gateway]</code></p> <p>Calculate satellite-to-gateway communication link performance for each edge in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def __init__(\n    self,\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[Satellite, Gateway],\n    link_acquisition_time: float = 60,\n    skip_link_acquisition_at_simulation_start: bool = True,\n) -&gt; None:\n    self.memoryless_calculator = memoryless_calculator\n    self.link_acquisition_time = link_acquisition_time\n    self.skip_link_acquisition_at_simulation_start = skip_link_acquisition_at_simulation_start\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryMemoryCommLinkCalculator.link_acquisition_time","title":"link_acquisition_time  <code>instance-attribute</code>","text":"<pre><code>link_acquisition_time = link_acquisition_time\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryMemoryCommLinkCalculator.memoryless_calculator","title":"memoryless_calculator  <code>instance-attribute</code>","text":"<pre><code>memoryless_calculator = memoryless_calculator\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryMemoryCommLinkCalculator.skip_link_acquisition_at_simulation_start","title":"skip_link_acquisition_at_simulation_start  <code>instance-attribute</code>","text":"<pre><code>skip_link_acquisition_at_simulation_start = (\n    skip_link_acquisition_at_simulation_start\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayBinaryMemoryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[\n        Collection[tuple[Satellite, Gateway]]\n    ],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[\n    dict[tuple[Satellite, Gateway], CommLinkPerformance]\n]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[Satellite, Gateway]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[Satellite, Gateway], CommLinkPerformance]]:\n    assert len(edges_time_series) == len(dynamics_data.time)\n\n    comm_link_time_series = []\n\n    link_acquisition_start_time: dict[tuple[Satellite, Gateway], np.datetime64] = {}\n    prev_edges: frozenset[tuple[Satellite, Gateway]] = frozenset()\n    for time_index, edges_snapshot in enumerate(edges_time_series):\n        current_time: np.datetime64 = dynamics_data.time[time_index]\n\n        comm_link = self.memoryless_calculator.calc(\n            edges=edges_snapshot,\n            dynamics_data=dynamics_data[time_index],\n            rng=rng,\n        )\n\n        edges_snapshot_set = frozenset(edges_snapshot)\n        new_edges = edges_snapshot_set - prev_edges\n        for edge in new_edges:\n            if self.skip_link_acquisition_at_simulation_start and time_index == 0:\n                link_acquisition_start_time[edge] = current_time - np.timedelta64(\n                    int(self.link_acquisition_time),\n                    \"s\",\n                )\n            else:\n                link_acquisition_start_time[edge] = current_time\n\n        disappeared_edges = prev_edges - edges_snapshot_set\n        for edge in disappeared_edges:  # remove edges that disappeared\n            link_acquisition_start_time.pop(edge, None)\n        prev_edges = edges_snapshot_set\n\n        for edge in edges_snapshot_set:\n            if not comm_link[edge][\"link_available\"]:\n                link_acquisition_start_time[edge] = current_time\n\n            within_link_acquisition: bool = False\n            if edge in link_acquisition_start_time:\n                within_link_acquisition = (\n                    float(\n                        (current_time - link_acquisition_start_time[edge]) / np.timedelta64(1, \"s\"),\n                    )\n                    &lt; self.link_acquisition_time\n                )\n            if within_link_acquisition:\n                comm_link[edge] = CommLinkPerformance(\n                    link_capacity=0.0,\n                    delay=np.inf,\n                    link_available=False,\n                )\n\n        comm_link_time_series.append(comm_link)\n\n    return comm_link_time_series\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayStochasticBinaryCommLinkCalculator","title":"SatToGatewayStochasticBinaryCommLinkCalculator","text":"<pre><code>SatToGatewayStochasticBinaryCommLinkCalculator(\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[\n        Satellite, Gateway\n    ],\n    stochastic_model_factory: Callable[\n        [Node, Node], CloudStates[bool_]\n    ]\n)\n</code></pre> <p>               Bases: <code>CommLinkCalculator[Satellite, Gateway]</code></p> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def __init__(\n    self,\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[Satellite, Gateway],\n    stochastic_model_factory: Callable[[Node, Node], CloudStates[np.bool_]],\n) -&gt; None:\n    self.memoryless_calculator = memoryless_calculator\n    self.stochastic_model_factory = stochastic_model_factory\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayStochasticBinaryCommLinkCalculator.memoryless_calculator","title":"memoryless_calculator  <code>instance-attribute</code>","text":"<pre><code>memoryless_calculator = memoryless_calculator\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayStochasticBinaryCommLinkCalculator.stochastic_model_factory","title":"stochastic_model_factory  <code>instance-attribute</code>","text":"<pre><code>stochastic_model_factory = stochastic_model_factory\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToGatewayStochasticBinaryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[\n        Collection[tuple[Satellite, Gateway]]\n    ],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[\n    dict[tuple[Satellite, Gateway], CommLinkPerformance]\n]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[Satellite, Gateway]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[Satellite, Gateway], CommLinkPerformance]]:\n    assert len(edges_time_series) == len(dynamics_data.time)\n    all_edges = {edge for edges_snapshot in edges_time_series for edge in edges_snapshot}\n    edge_interrupted = {\n        edge: self.stochastic_model_factory(edge[0], edge[1]).simulate(time=dynamics_data.time, rng=rng)\n        for edge in all_edges\n    }\n\n    comm_link_performance = []\n    for time_index, edges_snapshot in enumerate(edges_time_series):\n        comm_link = self.memoryless_calculator.calc(\n            edges=edges_snapshot,\n            dynamics_data=dynamics_data[time_index],\n            rng=rng,\n        )\n        for edge in comm_link:\n            if edge_interrupted[edge][time_index]:\n                comm_link[edge] = CommLinkPerformance(link_capacity=0.0, delay=0.0, link_available=False)\n        comm_link_performance.append(comm_link)\n\n    return comm_link_performance\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculator","title":"SatToSatBinaryCommLinkCalculator","text":"<pre><code>SatToSatBinaryCommLinkCalculator(\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Satellite, Satellite]</code></p> <p>Calculate satellite-to-satellite communication link performance for each edge in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n) -&gt; None:\n    self.max_inter_satellite_distance = max_inter_satellite_distance\n    self.inter_satellite_link_capacity = inter_satellite_link_capacity\n    self.lowest_altitude = lowest_altitude\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n    self.sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculator.inter_satellite_link_capacity","title":"inter_satellite_link_capacity  <code>instance-attribute</code>","text":"<pre><code>inter_satellite_link_capacity = (\n    inter_satellite_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculator.lowest_altitude","title":"lowest_altitude  <code>instance-attribute</code>","text":"<pre><code>lowest_altitude = lowest_altitude\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculator.max_inter_satellite_distance","title":"max_inter_satellite_distance  <code>instance-attribute</code>","text":"<pre><code>max_inter_satellite_distance = max_inter_satellite_distance\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculator.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculator.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Satellite, Satellite]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[Satellite, Satellite], CommLinkPerformance]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Satellite, Satellite]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,  # noqa: ARG002 For interface compatibility\n) -&gt; dict[tuple[Satellite, Satellite], CommLinkPerformance]:\n    return {\n        edge: self._calc_satellite_to_satellite(\n            positions_eci=(\n                dynamics_data.satellite_position_eci[edge[0]],\n                dynamics_data.satellite_position_eci[edge[1]],\n            ),\n            velocities_eci=(\n                dynamics_data.satellite_velocity_eci[edge[0]],\n                dynamics_data.satellite_velocity_eci[edge[1]],\n            ),\n            attitude_angular_velocities_eci=(\n                dynamics_data.satellite_attitude_angular_velocity_eci[edge[0]],\n                dynamics_data.satellite_attitude_angular_velocity_eci[edge[1]],\n            ),\n            sun_direction_eci=dynamics_data.sun_direction_eci,\n        )\n        for edge in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc","title":"SatToSatBinaryCommLinkCalculatorWithRateCalc","text":"<pre><code>SatToSatBinaryCommLinkCalculatorWithRateCalc(\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n    lct_power: float = 1.0,\n    available_link_capacity: float = 1000000000.0,\n    lna_gain: float,\n    noise_figure: float = 4\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Satellite, Satellite]</code></p> <p>Calculate satellite-to-satellite communication link performance for each edge in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/rate_distance_calculator.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n    lct_power: float = 1.0,\n    available_link_capacity: float = 1e9,\n    lna_gain: float,\n    noise_figure: float = 4,\n) -&gt; None:\n    self.max_inter_satellite_distance = max_inter_satellite_distance\n    self.inter_satellite_link_capacity = inter_satellite_link_capacity\n    self.lowest_altitude = lowest_altitude\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n    self.sun_exclusion_angle = sun_exclusion_angle\n    self.lct_p0 = lct_power\n    self.link_capacity = available_link_capacity\n    self.lna_gain = lna_gain\n    self.noise_figure = noise_figure\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc.inter_satellite_link_capacity","title":"inter_satellite_link_capacity  <code>instance-attribute</code>","text":"<pre><code>inter_satellite_link_capacity = (\n    inter_satellite_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc.lct_p0","title":"lct_p0  <code>instance-attribute</code>","text":"<pre><code>lct_p0 = lct_power\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc.link_capacity","title":"link_capacity  <code>instance-attribute</code>","text":"<pre><code>link_capacity = available_link_capacity\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc.lna_gain","title":"lna_gain  <code>instance-attribute</code>","text":"<pre><code>lna_gain = lna_gain\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc.lowest_altitude","title":"lowest_altitude  <code>instance-attribute</code>","text":"<pre><code>lowest_altitude = lowest_altitude\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc.max_inter_satellite_distance","title":"max_inter_satellite_distance  <code>instance-attribute</code>","text":"<pre><code>max_inter_satellite_distance = max_inter_satellite_distance\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc.noise_figure","title":"noise_figure  <code>instance-attribute</code>","text":"<pre><code>noise_figure = noise_figure\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryCommLinkCalculatorWithRateCalc.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Satellite, Satellite]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[Satellite, Satellite], CommLinkPerformance]\n</code></pre> Source code in <code>src/cosmica/comm_link/rate_distance_calculator.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Satellite, Satellite]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,  # noqa: ARG002 For interface compatibility\n) -&gt; dict[tuple[Satellite, Satellite], CommLinkPerformance]:\n    return {\n        edge: self._calc_satellite_to_satellite(\n            positions_eci=(\n                dynamics_data.satellite_position_eci[edge[0]],\n                dynamics_data.satellite_position_eci[edge[1]],\n            ),\n            velocities_eci=(\n                dynamics_data.satellite_velocity_eci[edge[0]],\n                dynamics_data.satellite_velocity_eci[edge[1]],\n            ),\n            attitude_angular_velocities_eci=(\n                dynamics_data.satellite_attitude_angular_velocity_eci[edge[0]],\n                dynamics_data.satellite_attitude_angular_velocity_eci[edge[1]],\n            ),\n            sun_direction_eci=dynamics_data.sun_direction_eci,\n        )\n        for edge in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryMemoryCommLinkCalculator","title":"SatToSatBinaryMemoryCommLinkCalculator","text":"<pre><code>SatToSatBinaryMemoryCommLinkCalculator(\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[\n        Satellite, Satellite\n    ],\n    link_acquisition_time: float = 60.0,\n    skip_link_acquisition_at_simulation_start: bool = True\n)\n</code></pre> <p>               Bases: <code>CommLinkCalculator[Satellite, Satellite]</code></p> <p>Calculate satellite-to-satellite communication link performance for each edge in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def __init__(\n    self,\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[Satellite, Satellite],\n    link_acquisition_time: float = 60.0,\n    skip_link_acquisition_at_simulation_start: bool = True,\n) -&gt; None:\n    self.memoryless_calculator = memoryless_calculator\n    self.link_acquisition_time = link_acquisition_time\n    self.skip_link_acquisition_at_simulation_start = skip_link_acquisition_at_simulation_start\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryMemoryCommLinkCalculator.link_acquisition_time","title":"link_acquisition_time  <code>instance-attribute</code>","text":"<pre><code>link_acquisition_time = link_acquisition_time\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryMemoryCommLinkCalculator.memoryless_calculator","title":"memoryless_calculator  <code>instance-attribute</code>","text":"<pre><code>memoryless_calculator = memoryless_calculator\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryMemoryCommLinkCalculator.skip_link_acquisition_at_simulation_start","title":"skip_link_acquisition_at_simulation_start  <code>instance-attribute</code>","text":"<pre><code>skip_link_acquisition_at_simulation_start = (\n    skip_link_acquisition_at_simulation_start\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/#cosmica.comm_link.SatToSatBinaryMemoryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[\n        Collection[tuple[Satellite, Satellite]]\n    ],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[\n    dict[tuple[Satellite, Satellite], CommLinkPerformance]\n]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def calc(  # noqa: C901\n    self,\n    edges_time_series: Sequence[Collection[tuple[Satellite, Satellite]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[Satellite, Satellite], CommLinkPerformance]]:\n    assert len(edges_time_series) == len(dynamics_data.time)\n\n    comm_link_time_series: list[dict[tuple[Satellite, Satellite], CommLinkPerformance]] = []\n\n    # \u2015 per-edge state \u2015\n    # TODO(): Currently only undirected edges are targeted, so inter-satellite links are represented in frozenset\n    # prev_dot: dict[frozenset[Satellite], float] = {}\n    link_acquisition_start_time: dict[frozenset[Satellite], np.datetime64] = {}\n    prev_edges: frozenset[frozenset[Satellite]] = frozenset()\n\n    for time_index, edges_snapshot in enumerate(edges_time_series):\n        current_time: np.datetime64 = dynamics_data.time[time_index]\n\n        comm_link = self.memoryless_calculator.calc(\n            edges=edges_snapshot,\n            dynamics_data=dynamics_data[time_index],\n            rng=rng,\n        )\n\n        edges_snapshot_set = to_edge_frozenset(edges_snapshot)\n\n        # \u2500\u2500 update \u201cfirst-seen\u201d bookkeeping \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2605\n        new_edges = edges_snapshot_set - prev_edges\n        for edge_fs in new_edges:\n            if self.skip_link_acquisition_at_simulation_start and time_index == 0:\n                link_acquisition_start_time[edge_fs] = current_time - np.timedelta64(\n                    int(self.link_acquisition_time),\n                    \"s\",\n                )\n            else:\n                link_acquisition_start_time[edge_fs] = current_time\n\n        disappeared_edges = prev_edges - edges_snapshot_set\n        for edge_fs in disappeared_edges:  # \u30d5\u30a7\u30fc\u30c9\u30a2\u30a6\u30c8\u3057\u305f\u3089\u72b6\u614b\u3092\u6d88\u53bb\n            link_acquisition_start_time.pop(edge_fs, None)\n            # prev_dot.pop(edge_fs, None)\n        prev_edges = edges_snapshot_set\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n        for edge_fs in edges_snapshot_set:\n            sat_a, sat_b = sorted(edge_fs, key=id)\n\n            if ((sat_a, sat_b) in comm_link and comm_link[(sat_a, sat_b)][\"link_available\"] is False) or (\n                (sat_b, sat_a) in comm_link and comm_link[(sat_b, sat_a)][\"link_available\"] is False\n            ):\n                link_acquisition_start_time[edge_fs] = current_time\n\n            # --- link acquisition delay ------------ \u2605\n            within_link_acquisition: bool = False\n            if edge_fs in link_acquisition_start_time:\n                within_link_acquisition = (\n                    float(\n                        (current_time - link_acquisition_start_time[edge_fs]) / np.timedelta64(1, \"s\"),\n                    )\n                    &lt; self.link_acquisition_time\n                )\n\n            if within_link_acquisition:\n                if (sat_a, sat_b) in comm_link:\n                    comm_link[(sat_a, sat_b)] = CommLinkPerformance(\n                        link_capacity=0.0,\n                        delay=np.inf,\n                        link_available=False,\n                    )\n                elif (sat_b, sat_a) in comm_link:\n                    comm_link[(sat_b, sat_a)] = CommLinkPerformance(\n                        link_capacity=0.0,\n                        delay=np.inf,\n                        link_available=False,\n                    )\n            # ----------------------------------------------------\n\n        comm_link_time_series.append(comm_link)\n\n    return comm_link_time_series\n</code></pre>"},{"location":"reference/cosmica/comm_link/base/","title":"base","text":""},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base","title":"cosmica.comm_link.base","text":""},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"CommLinkPerformance\",\n    \"MemorylessCommLinkCalculator\",\n    \"MemorylessCommLinkCalculatorWrapper\",\n]\n</code></pre>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.CommLinkCalculator","title":"CommLinkCalculator","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.CommLinkCalculator.calc","title":"calc  <code>abstractmethod</code>","text":"<pre><code>calc(\n    edges_time_series: Sequence[Collection[tuple[T, U]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[dict[tuple[T, U], CommLinkPerformance]]\n</code></pre> <p>Calculate communication link performance for each edge in a network.</p> Source code in <code>src/cosmica/comm_link/base.py</code> <pre><code>@abstractmethod\ndef calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[T, U]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[T, U], CommLinkPerformance]]:\n    \"\"\"Calculate communication link performance for each edge in a network.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.CommLinkPerformance","title":"CommLinkPerformance","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.CommLinkPerformance.delay","title":"delay  <code>instance-attribute</code>","text":"<pre><code>delay: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.CommLinkPerformance.link_available","title":"link_available  <code>instance-attribute</code>","text":"<pre><code>link_available: bool\n</code></pre>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.CommLinkPerformance.link_capacity","title":"link_capacity  <code>instance-attribute</code>","text":"<pre><code>link_capacity: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.MemorylessCommLinkCalculator","title":"MemorylessCommLinkCalculator","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.MemorylessCommLinkCalculator.calc","title":"calc  <code>abstractmethod</code>","text":"<pre><code>calc(\n    edges: Collection[tuple[T, U]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[T, U], CommLinkPerformance]\n</code></pre> <p>Calculate communication link performance for each edge in a network.</p> Source code in <code>src/cosmica/comm_link/base.py</code> <pre><code>@abstractmethod\ndef calc(\n    self,\n    edges: Collection[tuple[T, U]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; dict[tuple[T, U], CommLinkPerformance]:\n    \"\"\"Calculate communication link performance for each edge in a network.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.MemorylessCommLinkCalculatorWrapper","title":"MemorylessCommLinkCalculatorWrapper","text":"<pre><code>MemorylessCommLinkCalculatorWrapper(\n    memoryless_calculator: MemorylessCommLinkCalculator[\n        T, U\n    ],\n)\n</code></pre> <p>               Bases: <code>CommLinkCalculator[T, U]</code></p> <p>Convert a memoryless calculator to a time series calculator by calling the memoryless one at each time step.</p> Source code in <code>src/cosmica/comm_link/base.py</code> <pre><code>def __init__(\n    self,\n    memoryless_calculator: MemorylessCommLinkCalculator[T, U],\n    /,\n) -&gt; None:\n    self.memoryless_calculator = memoryless_calculator\n</code></pre>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.MemorylessCommLinkCalculatorWrapper.memoryless_calculator","title":"memoryless_calculator  <code>instance-attribute</code>","text":"<pre><code>memoryless_calculator = memoryless_calculator\n</code></pre>"},{"location":"reference/cosmica/comm_link/base/#cosmica.comm_link.base.MemorylessCommLinkCalculatorWrapper.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[Collection[tuple[T, U]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[dict[tuple[T, U], CommLinkPerformance]]\n</code></pre> Source code in <code>src/cosmica/comm_link/base.py</code> <pre><code>def calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[T, U]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[T, U], CommLinkPerformance]]:\n    assert len(edges_time_series) == len(\n        dynamics_data.time,\n    ), \"edges_time_series must have the same length as dynamics_data.time\"\n    return [\n        self.memoryless_calculator.calc(edges=edges, dynamics_data=dynamics_data[time_index], rng=rng)\n        for time_index, edges in enumerate(edges_time_series)\n    ]\n</code></pre>"},{"location":"reference/cosmica/comm_link/coordinator/","title":"coordinator","text":""},{"location":"reference/cosmica/comm_link/coordinator/#cosmica.comm_link.coordinator","title":"cosmica.comm_link.coordinator","text":""},{"location":"reference/cosmica/comm_link/coordinator/#cosmica.comm_link.coordinator.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['CommLinkCalculationCoordinator']\n</code></pre>"},{"location":"reference/cosmica/comm_link/coordinator/#cosmica.comm_link.coordinator.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/comm_link/coordinator/#cosmica.comm_link.coordinator.EdgeType","title":"EdgeType","text":"<pre><code>EdgeType = tuple[type[Node], type[Node]]\n</code></pre>"},{"location":"reference/cosmica/comm_link/coordinator/#cosmica.comm_link.coordinator.CommLinkCalculationCoordinator","title":"CommLinkCalculationCoordinator","text":"<pre><code>CommLinkCalculationCoordinator(\n    *,\n    calculator_assignment: Mapping[\n        EdgeType, CommLinkCalculator\n    ],\n    directed: bool = False\n)\n</code></pre> Source code in <code>src/cosmica/comm_link/coordinator.py</code> <pre><code>def __init__(\n    self,\n    *,\n    calculator_assignment: Mapping[EdgeType, CommLinkCalculator],\n    directed: bool = False,\n) -&gt; None:\n    self.calculator_assignment = dict(calculator_assignment)\n    self.directed = directed\n\n    if not self.directed:\n        assert len(set(self.calculator_assignment)) == len(\n            self.calculator_assignment,\n        ), \"All edge types must be unique.\"\n</code></pre>"},{"location":"reference/cosmica/comm_link/coordinator/#cosmica.comm_link.coordinator.CommLinkCalculationCoordinator.calculator_assignment","title":"calculator_assignment  <code>instance-attribute</code>","text":"<pre><code>calculator_assignment = dict(calculator_assignment)\n</code></pre>"},{"location":"reference/cosmica/comm_link/coordinator/#cosmica.comm_link.coordinator.CommLinkCalculationCoordinator.directed","title":"directed  <code>instance-attribute</code>","text":"<pre><code>directed = directed\n</code></pre>"},{"location":"reference/cosmica/comm_link/coordinator/#cosmica.comm_link.coordinator.CommLinkCalculationCoordinator.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[\n        Collection[tuple[Node, Node]]\n    ],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[dict[tuple[Node, Node], CommLinkPerformance]]\n</code></pre> Source code in <code>src/cosmica/comm_link/coordinator.py</code> <pre><code>def calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[Node, Node]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[Node, Node], CommLinkPerformance]]:\n    assert len(dynamics_data.time) == len(edges_time_series)\n\n    if self.directed:\n        msg = \"calc_time_series is only supported for undirected calculators.\"\n        raise NotImplementedError(msg)\n    return self._calc_undirected(edges_time_series, dynamics_data=dynamics_data, rng=rng)\n</code></pre>"},{"location":"reference/cosmica/comm_link/gateway_to_gateway/","title":"gateway_to_gateway","text":""},{"location":"reference/cosmica/comm_link/gateway_to_gateway/#cosmica.comm_link.gateway_to_gateway","title":"cosmica.comm_link.gateway_to_gateway","text":""},{"location":"reference/cosmica/comm_link/gateway_to_gateway/#cosmica.comm_link.gateway_to_gateway.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['GatewayToGatewayCommLinkCalculator']\n</code></pre>"},{"location":"reference/cosmica/comm_link/gateway_to_gateway/#cosmica.comm_link.gateway_to_gateway.GatewayToGatewayCommLinkCalculator","title":"GatewayToGatewayCommLinkCalculator","text":"<pre><code>GatewayToGatewayCommLinkCalculator(\n    *,\n    gateway_to_gateway_bandwidth: float,\n    refractive_index: float = 1.5\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Gateway, Gateway]</code></p> <p>Calculate gateway-to-gateway communication link performance using great circle distance.</p> <p>Initialize the gateway-to-gateway communication link calculator.</p> Source code in <code>src/cosmica/comm_link/gateway_to_gateway.py</code> <pre><code>def __init__(\n    self,\n    *,\n    gateway_to_gateway_bandwidth: float,\n    refractive_index: float = 1.5,\n) -&gt; None:\n    \"\"\"Initialize the gateway-to-gateway communication link calculator.\"\"\"\n    self.gateway_to_gateway_bandwidth = gateway_to_gateway_bandwidth\n    self.refractive_index = refractive_index\n</code></pre>"},{"location":"reference/cosmica/comm_link/gateway_to_gateway/#cosmica.comm_link.gateway_to_gateway.GatewayToGatewayCommLinkCalculator.gateway_to_gateway_bandwidth","title":"gateway_to_gateway_bandwidth  <code>instance-attribute</code>","text":"<pre><code>gateway_to_gateway_bandwidth = gateway_to_gateway_bandwidth\n</code></pre>"},{"location":"reference/cosmica/comm_link/gateway_to_gateway/#cosmica.comm_link.gateway_to_gateway.GatewayToGatewayCommLinkCalculator.refractive_index","title":"refractive_index  <code>instance-attribute</code>","text":"<pre><code>refractive_index = refractive_index\n</code></pre>"},{"location":"reference/cosmica/comm_link/gateway_to_gateway/#cosmica.comm_link.gateway_to_gateway.GatewayToGatewayCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Gateway, Gateway]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[Gateway, Gateway], CommLinkPerformance]\n</code></pre> <p>Calculate communication link performance for gateway-to-gateway edges.</p> Source code in <code>src/cosmica/comm_link/gateway_to_gateway.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Gateway, Gateway]],\n    *,\n    dynamics_data: DynamicsData,  # noqa: ARG002 For interface compatibility\n    rng: np.random.Generator,  # noqa: ARG002 For interface compatibility\n) -&gt; dict[tuple[Gateway, Gateway], CommLinkPerformance]:\n    \"\"\"Calculate communication link performance for gateway-to-gateway edges.\"\"\"\n    return {\n        edge: self._calc_gateway_to_gateway(\n            gateway1=edge[0],\n            gateway2=edge[1],\n        )\n        for edge in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/gateway_to_internet/","title":"gateway_to_internet","text":""},{"location":"reference/cosmica/comm_link/gateway_to_internet/#cosmica.comm_link.gateway_to_internet","title":"cosmica.comm_link.gateway_to_internet","text":""},{"location":"reference/cosmica/comm_link/gateway_to_internet/#cosmica.comm_link.gateway_to_internet.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['GatewayToInternetCommLinkCalculator']\n</code></pre>"},{"location":"reference/cosmica/comm_link/gateway_to_internet/#cosmica.comm_link.gateway_to_internet.GatewayToInternetCommLinkCalculator","title":"GatewayToInternetCommLinkCalculator","text":"<pre><code>GatewayToInternetCommLinkCalculator(\n    *,\n    gateway_to_internet_link_capacity: float,\n    gateway_to_internet_delay: float\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Gateway, Internet]</code></p> <p>Calculates the communication link between a gateway and an internet.</p> Source code in <code>src/cosmica/comm_link/gateway_to_internet.py</code> <pre><code>def __init__(\n    self,\n    *,\n    gateway_to_internet_link_capacity: float,\n    gateway_to_internet_delay: float,\n) -&gt; None:\n    self.gateway_to_internet_link_capacity = gateway_to_internet_link_capacity\n    self.gateway_to_internet_delay = gateway_to_internet_delay\n</code></pre>"},{"location":"reference/cosmica/comm_link/gateway_to_internet/#cosmica.comm_link.gateway_to_internet.GatewayToInternetCommLinkCalculator.gateway_to_internet_delay","title":"gateway_to_internet_delay  <code>instance-attribute</code>","text":"<pre><code>gateway_to_internet_delay = gateway_to_internet_delay\n</code></pre>"},{"location":"reference/cosmica/comm_link/gateway_to_internet/#cosmica.comm_link.gateway_to_internet.GatewayToInternetCommLinkCalculator.gateway_to_internet_link_capacity","title":"gateway_to_internet_link_capacity  <code>instance-attribute</code>","text":"<pre><code>gateway_to_internet_link_capacity = (\n    gateway_to_internet_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/gateway_to_internet/#cosmica.comm_link.gateway_to_internet.GatewayToInternetCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Gateway, Internet]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[Gateway, Internet], CommLinkPerformance]\n</code></pre> Source code in <code>src/cosmica/comm_link/gateway_to_internet.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Gateway, Internet]],\n    *,\n    dynamics_data: DynamicsData,  # noqa: ARG002 For interface compatibility\n    rng: np.random.Generator,  # noqa: ARG002 For interface compatibility\n) -&gt; dict[tuple[Gateway, Internet], CommLinkPerformance]:\n    return {\n        (gateway, internet): CommLinkPerformance(\n            link_capacity=self.gateway_to_internet_link_capacity,\n            delay=self.gateway_to_internet_delay,\n            link_available=True,\n        )\n        for gateway, internet in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/geometric/","title":"geometric","text":""},{"location":"reference/cosmica/comm_link/geometric/#cosmica.comm_link.geometric","title":"cosmica.comm_link.geometric","text":""},{"location":"reference/cosmica/comm_link/geometric/#cosmica.comm_link.geometric.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['GeometricCommLinkCalculator']\n</code></pre>"},{"location":"reference/cosmica/comm_link/geometric/#cosmica.comm_link.geometric.GeometricCommLinkCalculator","title":"GeometricCommLinkCalculator","text":"<pre><code>GeometricCommLinkCalculator(\n    *,\n    inter_satellite_link_capacity: float,\n    satellite_to_gateway_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\")\n)\n</code></pre> <p>Calculate geometric communication link performance for each edge in a network.</p> Source code in <code>src/cosmica/comm_link/geometric.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_satellite_link_capacity: float,\n    satellite_to_gateway_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n) -&gt; None:\n    warnings.warn(\n        \"GeometricCommLinkCalculator is deprecated.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    self.max_inter_satellite_distance = max_inter_satellite_distance\n    self.inter_satellite_link_capacity = inter_satellite_link_capacity\n    self.satellite_to_gateway_link_capacity = satellite_to_gateway_link_capacity\n    self.lowest_altitude = lowest_altitude\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n</code></pre>"},{"location":"reference/cosmica/comm_link/geometric/#cosmica.comm_link.geometric.GeometricCommLinkCalculator.inter_satellite_link_capacity","title":"inter_satellite_link_capacity  <code>instance-attribute</code>","text":"<pre><code>inter_satellite_link_capacity = (\n    inter_satellite_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/geometric/#cosmica.comm_link.geometric.GeometricCommLinkCalculator.lowest_altitude","title":"lowest_altitude  <code>instance-attribute</code>","text":"<pre><code>lowest_altitude = lowest_altitude\n</code></pre>"},{"location":"reference/cosmica/comm_link/geometric/#cosmica.comm_link.geometric.GeometricCommLinkCalculator.max_inter_satellite_distance","title":"max_inter_satellite_distance  <code>instance-attribute</code>","text":"<pre><code>max_inter_satellite_distance = max_inter_satellite_distance\n</code></pre>"},{"location":"reference/cosmica/comm_link/geometric/#cosmica.comm_link.geometric.GeometricCommLinkCalculator.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/geometric/#cosmica.comm_link.geometric.GeometricCommLinkCalculator.satellite_to_gateway_link_capacity","title":"satellite_to_gateway_link_capacity  <code>instance-attribute</code>","text":"<pre><code>satellite_to_gateway_link_capacity = (\n    satellite_to_gateway_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/geometric/#cosmica.comm_link.geometric.GeometricCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    graph: Graph,\n    *,\n    satellite_position_eci: dict[\n        ConstellationSatellite, NDArray[float64]\n    ],\n    satellite_velocity_eci: dict[\n        ConstellationSatellite, NDArray[float64]\n    ],\n    satellite_position_ecef: dict[\n        ConstellationSatellite, NDArray[float64]\n    ],\n    satellite_attitude_angular_velocity_eci: dict[\n        ConstellationSatellite, NDArray[float64]\n    ]\n) -&gt; dict[_EdgeType, CommLinkPerformance]\n</code></pre> <p>Calculate geometric communication link performance for each edge in a network.</p> Source code in <code>src/cosmica/comm_link/geometric.py</code> <pre><code>def calc(\n    self,\n    graph: nx.Graph,\n    *,\n    satellite_position_eci: dict[ConstellationSatellite, npt.NDArray[np.float64]],\n    satellite_velocity_eci: dict[ConstellationSatellite, npt.NDArray[np.float64]],\n    satellite_position_ecef: dict[ConstellationSatellite, npt.NDArray[np.float64]],\n    satellite_attitude_angular_velocity_eci: dict[ConstellationSatellite, npt.NDArray[np.float64]],\n) -&gt; dict[_EdgeType, CommLinkPerformance]:\n    \"\"\"Calculate geometric communication link performance for each edge in a network.\"\"\"\n    performance: dict[_EdgeType, CommLinkPerformance] = {}\n    for node1, node2 in graph.edges:\n        if isinstance(node1, ConstellationSatellite) and isinstance(node2, ConstellationSatellite):\n            performance[(node1, node2)] = self._calc_satellite_to_satellite(\n                positions_eci=(satellite_position_eci[node1], satellite_position_eci[node2]),\n                velocities_eci=(satellite_velocity_eci[node1], satellite_velocity_eci[node2]),\n                attitude_angular_velocities_eci=(\n                    satellite_attitude_angular_velocity_eci[node1],\n                    satellite_attitude_angular_velocity_eci[node2],\n                ),\n            )\n        elif isinstance(node1, ConstellationSatellite) and isinstance(node2, Gateway):\n            performance[(node1, node2)] = self._calc_satellite_to_gateway(satellite_position_ecef[node1], node2)\n        elif isinstance(node1, Gateway) and isinstance(node2, ConstellationSatellite):\n            performance[(node1, node2)] = self._calc_satellite_to_gateway(satellite_position_ecef[node2], node1)\n        else:\n            msg = f\"Invalid edge: {node1} -&gt; {node2}\"\n            raise TypeError(msg)\n    return performance\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/","title":"rate_distance_calculator","text":""},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator","title":"cosmica.comm_link.rate_distance_calculator","text":""},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['SatToSatBinaryCommLinkCalculatorWithRateCalc']\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc","title":"SatToSatBinaryCommLinkCalculatorWithRateCalc","text":"<pre><code>SatToSatBinaryCommLinkCalculatorWithRateCalc(\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n    lct_power: float = 1.0,\n    available_link_capacity: float = 1000000000.0,\n    lna_gain: float,\n    noise_figure: float = 4\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Satellite, Satellite]</code></p> <p>Calculate satellite-to-satellite communication link performance for each edge in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/rate_distance_calculator.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n    lct_power: float = 1.0,\n    available_link_capacity: float = 1e9,\n    lna_gain: float,\n    noise_figure: float = 4,\n) -&gt; None:\n    self.max_inter_satellite_distance = max_inter_satellite_distance\n    self.inter_satellite_link_capacity = inter_satellite_link_capacity\n    self.lowest_altitude = lowest_altitude\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n    self.sun_exclusion_angle = sun_exclusion_angle\n    self.lct_p0 = lct_power\n    self.link_capacity = available_link_capacity\n    self.lna_gain = lna_gain\n    self.noise_figure = noise_figure\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc.inter_satellite_link_capacity","title":"inter_satellite_link_capacity  <code>instance-attribute</code>","text":"<pre><code>inter_satellite_link_capacity = (\n    inter_satellite_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc.lct_p0","title":"lct_p0  <code>instance-attribute</code>","text":"<pre><code>lct_p0 = lct_power\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc.link_capacity","title":"link_capacity  <code>instance-attribute</code>","text":"<pre><code>link_capacity = available_link_capacity\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc.lna_gain","title":"lna_gain  <code>instance-attribute</code>","text":"<pre><code>lna_gain = lna_gain\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc.lowest_altitude","title":"lowest_altitude  <code>instance-attribute</code>","text":"<pre><code>lowest_altitude = lowest_altitude\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc.max_inter_satellite_distance","title":"max_inter_satellite_distance  <code>instance-attribute</code>","text":"<pre><code>max_inter_satellite_distance = max_inter_satellite_distance\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc.noise_figure","title":"noise_figure  <code>instance-attribute</code>","text":"<pre><code>noise_figure = noise_figure\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/rate_distance_calculator/#cosmica.comm_link.rate_distance_calculator.SatToSatBinaryCommLinkCalculatorWithRateCalc.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Satellite, Satellite]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[Satellite, Satellite], CommLinkPerformance]\n</code></pre> Source code in <code>src/cosmica/comm_link/rate_distance_calculator.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Satellite, Satellite]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,  # noqa: ARG002 For interface compatibility\n) -&gt; dict[tuple[Satellite, Satellite], CommLinkPerformance]:\n    return {\n        edge: self._calc_satellite_to_satellite(\n            positions_eci=(\n                dynamics_data.satellite_position_eci[edge[0]],\n                dynamics_data.satellite_position_eci[edge[1]],\n            ),\n            velocities_eci=(\n                dynamics_data.satellite_velocity_eci[edge[0]],\n                dynamics_data.satellite_velocity_eci[edge[1]],\n            ),\n            attitude_angular_velocities_eci=(\n                dynamics_data.satellite_attitude_angular_velocity_eci[edge[0]],\n                dynamics_data.satellite_attitude_angular_velocity_eci[edge[1]],\n            ),\n            sun_direction_eci=dynamics_data.sun_direction_eci,\n        )\n        for edge in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/","title":"sat_to_ground","text":""},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground","title":"cosmica.comm_link.sat_to_ground","text":""},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"SatToGatewayBinaryCommLinkCalculator\",\n    \"SatToGatewayBinaryCommLinkCalculatorWithScintillation\",\n    \"SatToGatewayBinaryMemoryCommLinkCalculator\",\n    \"SatToGatewayStochasticBinaryCommLinkCalculator\",\n]\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculator","title":"SatToGatewayBinaryCommLinkCalculator","text":"<pre><code>SatToGatewayBinaryCommLinkCalculator(\n    *,\n    satellite_to_gateway_link_capacity: float,\n    sun_exclusion_angle: float = 0.0\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Satellite, Gateway]</code></p> <p>Calculate satellite-to-gateway communication link performance for each edge in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def __init__(\n    self,\n    *,\n    satellite_to_gateway_link_capacity: float,\n    sun_exclusion_angle: float = 0.0,\n) -&gt; None:\n    self.satellite_to_gateway_link_capacity = satellite_to_gateway_link_capacity\n    self.sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculator.satellite_to_gateway_link_capacity","title":"satellite_to_gateway_link_capacity  <code>instance-attribute</code>","text":"<pre><code>satellite_to_gateway_link_capacity = (\n    satellite_to_gateway_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculator.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Satellite, Gateway]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[Satellite, Gateway], CommLinkPerformance]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Satellite, Gateway]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,  # noqa: ARG002 For interface compatibility\n) -&gt; dict[tuple[Satellite, Gateway], CommLinkPerformance]:\n    return {\n        edge: self._calc_satellite_to_gateway(\n            satellite_position_ecef=dynamics_data.satellite_position_ecef[edge[0]],\n            sun_direction_ecef=dynamics_data.sun_direction_ecef,\n            sun_exclusion_angle=self.sun_exclusion_angle,\n            gateway=edge[1],\n        )\n        for edge in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculatorWithScintillation","title":"SatToGatewayBinaryCommLinkCalculatorWithScintillation","text":"<pre><code>SatToGatewayBinaryCommLinkCalculatorWithScintillation(\n    *,\n    satellite_to_gateway_link_capacity: float,\n    link_capacity: float,\n    noise_figure: float,\n    lna_gain: float,\n    lct_p0: float,\n    turbulence_model_factory: Callable[\n        [GatewayOGS], AtmosphericScintillationModel\n    ] = lambda gateway: ApertureAveragedLogNormalScintillationModel(\n        default_rytov_variance=rytov_variance,\n        wavelength=1550 * 1e-09,\n        aperture_diameter=aperture_size,\n    )\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Satellite, GatewayOGS]</code></p> <p>Calculate satellite-to-gateway communication link performance for each edge in a network with turbulence.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def __init__(\n    self,\n    *,\n    satellite_to_gateway_link_capacity: float,\n    link_capacity: float,\n    noise_figure: float,\n    lna_gain: float,\n    lct_p0: float,\n    turbulence_model_factory: Callable[\n        [GatewayOGS],\n        AtmosphericScintillationModel,\n    ] = lambda gateway: ApertureAveragedLogNormalScintillationModel(\n        default_rytov_variance=gateway.rytov_variance,\n        wavelength=1550 * 1e-9,\n        aperture_diameter=gateway.aperture_size,\n    ),\n) -&gt; None:\n    self.satellite_to_gateway_link_capacity = satellite_to_gateway_link_capacity\n    self.link_capacity = link_capacity\n    self.noise_figure = noise_figure\n    self.lna_gain = lna_gain\n    self.lct_p0 = lct_p0\n    self.turbulence_model_factory = turbulence_model_factory\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculatorWithScintillation.lct_p0","title":"lct_p0  <code>instance-attribute</code>","text":"<pre><code>lct_p0 = lct_p0\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculatorWithScintillation.link_capacity","title":"link_capacity  <code>instance-attribute</code>","text":"<pre><code>link_capacity = link_capacity\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculatorWithScintillation.lna_gain","title":"lna_gain  <code>instance-attribute</code>","text":"<pre><code>lna_gain = lna_gain\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculatorWithScintillation.noise_figure","title":"noise_figure  <code>instance-attribute</code>","text":"<pre><code>noise_figure = noise_figure\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculatorWithScintillation.satellite_to_gateway_link_capacity","title":"satellite_to_gateway_link_capacity  <code>instance-attribute</code>","text":"<pre><code>satellite_to_gateway_link_capacity = (\n    satellite_to_gateway_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculatorWithScintillation.turbulence_model_factory","title":"turbulence_model_factory  <code>instance-attribute</code>","text":"<pre><code>turbulence_model_factory = turbulence_model_factory\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryCommLinkCalculatorWithScintillation.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Satellite, GatewayOGS]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[\n    tuple[Satellite, GatewayOGS], CommLinkPerformance\n]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Satellite, GatewayOGS]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; dict[tuple[Satellite, GatewayOGS], CommLinkPerformance]:\n    gateway_turbulence_map = self._map_turbulence2gateway(edges)\n    return {\n        edge: self._calc_satellite_to_gateway(\n            satellite_position_ecef=dynamics_data.satellite_position_ecef[edge[0]],\n            sun_direction_ecef=dynamics_data.sun_direction_ecef,\n            sun_exclusion_angle=0.0,\n            rng=rng,\n            gateway=edge[1],\n            gateway_turbulence_map=gateway_turbulence_map,\n        )\n        for edge in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryMemoryCommLinkCalculator","title":"SatToGatewayBinaryMemoryCommLinkCalculator","text":"<pre><code>SatToGatewayBinaryMemoryCommLinkCalculator(\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[\n        Satellite, Gateway\n    ],\n    link_acquisition_time: float = 60,\n    skip_link_acquisition_at_simulation_start: bool = True\n)\n</code></pre> <p>               Bases: <code>CommLinkCalculator[Satellite, Gateway]</code></p> <p>Calculate satellite-to-gateway communication link performance for each edge in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def __init__(\n    self,\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[Satellite, Gateway],\n    link_acquisition_time: float = 60,\n    skip_link_acquisition_at_simulation_start: bool = True,\n) -&gt; None:\n    self.memoryless_calculator = memoryless_calculator\n    self.link_acquisition_time = link_acquisition_time\n    self.skip_link_acquisition_at_simulation_start = skip_link_acquisition_at_simulation_start\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryMemoryCommLinkCalculator.link_acquisition_time","title":"link_acquisition_time  <code>instance-attribute</code>","text":"<pre><code>link_acquisition_time = link_acquisition_time\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryMemoryCommLinkCalculator.memoryless_calculator","title":"memoryless_calculator  <code>instance-attribute</code>","text":"<pre><code>memoryless_calculator = memoryless_calculator\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryMemoryCommLinkCalculator.skip_link_acquisition_at_simulation_start","title":"skip_link_acquisition_at_simulation_start  <code>instance-attribute</code>","text":"<pre><code>skip_link_acquisition_at_simulation_start = (\n    skip_link_acquisition_at_simulation_start\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayBinaryMemoryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[\n        Collection[tuple[Satellite, Gateway]]\n    ],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[\n    dict[tuple[Satellite, Gateway], CommLinkPerformance]\n]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[Satellite, Gateway]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[Satellite, Gateway], CommLinkPerformance]]:\n    assert len(edges_time_series) == len(dynamics_data.time)\n\n    comm_link_time_series = []\n\n    link_acquisition_start_time: dict[tuple[Satellite, Gateway], np.datetime64] = {}\n    prev_edges: frozenset[tuple[Satellite, Gateway]] = frozenset()\n    for time_index, edges_snapshot in enumerate(edges_time_series):\n        current_time: np.datetime64 = dynamics_data.time[time_index]\n\n        comm_link = self.memoryless_calculator.calc(\n            edges=edges_snapshot,\n            dynamics_data=dynamics_data[time_index],\n            rng=rng,\n        )\n\n        edges_snapshot_set = frozenset(edges_snapshot)\n        new_edges = edges_snapshot_set - prev_edges\n        for edge in new_edges:\n            if self.skip_link_acquisition_at_simulation_start and time_index == 0:\n                link_acquisition_start_time[edge] = current_time - np.timedelta64(\n                    int(self.link_acquisition_time),\n                    \"s\",\n                )\n            else:\n                link_acquisition_start_time[edge] = current_time\n\n        disappeared_edges = prev_edges - edges_snapshot_set\n        for edge in disappeared_edges:  # remove edges that disappeared\n            link_acquisition_start_time.pop(edge, None)\n        prev_edges = edges_snapshot_set\n\n        for edge in edges_snapshot_set:\n            if not comm_link[edge][\"link_available\"]:\n                link_acquisition_start_time[edge] = current_time\n\n            within_link_acquisition: bool = False\n            if edge in link_acquisition_start_time:\n                within_link_acquisition = (\n                    float(\n                        (current_time - link_acquisition_start_time[edge]) / np.timedelta64(1, \"s\"),\n                    )\n                    &lt; self.link_acquisition_time\n                )\n            if within_link_acquisition:\n                comm_link[edge] = CommLinkPerformance(\n                    link_capacity=0.0,\n                    delay=np.inf,\n                    link_available=False,\n                )\n\n        comm_link_time_series.append(comm_link)\n\n    return comm_link_time_series\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayStochasticBinaryCommLinkCalculator","title":"SatToGatewayStochasticBinaryCommLinkCalculator","text":"<pre><code>SatToGatewayStochasticBinaryCommLinkCalculator(\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[\n        Satellite, Gateway\n    ],\n    stochastic_model_factory: Callable[\n        [Node, Node], CloudStates[bool_]\n    ]\n)\n</code></pre> <p>               Bases: <code>CommLinkCalculator[Satellite, Gateway]</code></p> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def __init__(\n    self,\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[Satellite, Gateway],\n    stochastic_model_factory: Callable[[Node, Node], CloudStates[np.bool_]],\n) -&gt; None:\n    self.memoryless_calculator = memoryless_calculator\n    self.stochastic_model_factory = stochastic_model_factory\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayStochasticBinaryCommLinkCalculator.memoryless_calculator","title":"memoryless_calculator  <code>instance-attribute</code>","text":"<pre><code>memoryless_calculator = memoryless_calculator\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayStochasticBinaryCommLinkCalculator.stochastic_model_factory","title":"stochastic_model_factory  <code>instance-attribute</code>","text":"<pre><code>stochastic_model_factory = stochastic_model_factory\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_ground/#cosmica.comm_link.sat_to_ground.SatToGatewayStochasticBinaryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[\n        Collection[tuple[Satellite, Gateway]]\n    ],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[\n    dict[tuple[Satellite, Gateway], CommLinkPerformance]\n]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_ground.py</code> <pre><code>def calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[Satellite, Gateway]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[Satellite, Gateway], CommLinkPerformance]]:\n    assert len(edges_time_series) == len(dynamics_data.time)\n    all_edges = {edge for edges_snapshot in edges_time_series for edge in edges_snapshot}\n    edge_interrupted = {\n        edge: self.stochastic_model_factory(edge[0], edge[1]).simulate(time=dynamics_data.time, rng=rng)\n        for edge in all_edges\n    }\n\n    comm_link_performance = []\n    for time_index, edges_snapshot in enumerate(edges_time_series):\n        comm_link = self.memoryless_calculator.calc(\n            edges=edges_snapshot,\n            dynamics_data=dynamics_data[time_index],\n            rng=rng,\n        )\n        for edge in comm_link:\n            if edge_interrupted[edge][time_index]:\n                comm_link[edge] = CommLinkPerformance(link_capacity=0.0, delay=0.0, link_available=False)\n        comm_link_performance.append(comm_link)\n\n    return comm_link_performance\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/","title":"sat_to_sat","text":""},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat","title":"cosmica.comm_link.sat_to_sat","text":""},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"OTC2OTCBinaryCommLinkCalculator\",\n    \"SatToSatBinaryCommLinkCalculator\",\n    \"SatToSatBinaryMemoryCommLinkCalculator\",\n]\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.OTC2OTCBinaryCommLinkCalculator","title":"OTC2OTCBinaryCommLinkCalculator","text":"<pre><code>OTC2OTCBinaryCommLinkCalculator(\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0\n)\n</code></pre> <p>               Bases: <code>CommLinkCalculator[SatelliteTerminal, SatelliteTerminal]</code></p> <p>Calculate satellite-to-satellite communication link performance for each terminal in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n) -&gt; None:\n    self.max_inter_satellite_distance = max_inter_satellite_distance\n    self.inter_satellite_link_capacity = inter_satellite_link_capacity\n    self.lowest_altitude = lowest_altitude\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n    self.sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.OTC2OTCBinaryCommLinkCalculator.inter_satellite_link_capacity","title":"inter_satellite_link_capacity  <code>instance-attribute</code>","text":"<pre><code>inter_satellite_link_capacity = (\n    inter_satellite_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.OTC2OTCBinaryCommLinkCalculator.lowest_altitude","title":"lowest_altitude  <code>instance-attribute</code>","text":"<pre><code>lowest_altitude = lowest_altitude\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.OTC2OTCBinaryCommLinkCalculator.max_inter_satellite_distance","title":"max_inter_satellite_distance  <code>instance-attribute</code>","text":"<pre><code>max_inter_satellite_distance = max_inter_satellite_distance\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.OTC2OTCBinaryCommLinkCalculator.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.OTC2OTCBinaryCommLinkCalculator.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.OTC2OTCBinaryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[\n        Collection[\n            tuple[SatelliteTerminal, SatelliteTerminal]\n        ]\n    ],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[\n    dict[\n        tuple[SatelliteTerminal, SatelliteTerminal],\n        CommLinkPerformance,\n    ]\n]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def calc(\n    self,\n    edges_time_series: Sequence[Collection[tuple[SatelliteTerminal, SatelliteTerminal]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator,  # noqa: ARG002\n) -&gt; list[dict[tuple[SatelliteTerminal, SatelliteTerminal], CommLinkPerformance]]:\n    terminal_memo: dict[tuple[SatelliteTerminal, SatelliteTerminal], list[tuple[float, float]]] = {}\n    comm_link_time_series = []\n    prev_time = dynamics_data.time[0]\n\n    for i, snapshot in enumerate(edges_time_series):\n        edges_performance = {}\n        current_time = dynamics_data.time[i]\n        time_delta = current_time - prev_time if i != 0 else 1\n        if time_delta == 0:\n            msg = \"time_delta must be non-zero\"\n            raise ValueError(msg)\n        # Note: the terminal angular velocity and pointing verifications in the first iteration will return\n        # meaningless results and should be disconsidered during analysis.\n\n        for edge in snapshot:\n            # TODO(): \u30a8\u30c3\u30b8\u304ctuple\u3068\u3057\u3066\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u9806\u5e8f\u3092\u8003\u616e\u3057\u3066\u8abf\u3079\u308b\u5fc5\u8981\u304c\u3042\u308b\n            previous_terminal_directions = terminal_memo.get(edge, [(0.0, 0.0), (0.0, 0.0)])\n\n            # TODO(): \u304a\u305d\u3089\u304f dynamics_data \u306e\u4e2d\u3067\u5404\u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u306e\u5024\u3092\u53d6\u3063\u3066\u304f\u308b\u5fc5\u8981\u304c\u3042\u308b\n            comm_link_performance, terminal_directions = self._calc_satellite_to_satellite(\n                positions_eci=(\n                    dynamics_data.satellite_position_eci[edge[0]],\n                    dynamics_data.satellite_position_eci[edge[1]],\n                ),\n                velocities_eci=(\n                    dynamics_data.satellite_velocity_eci[edge[0]],\n                    dynamics_data.satellite_velocity_eci[edge[1]],\n                ),\n                attitude_angular_velocities_eci=(\n                    dynamics_data.satellite_attitude_angular_velocity_eci[edge[0]],\n                    dynamics_data.satellite_attitude_angular_velocity_eci[edge[1]],\n                ),\n                sun_direction_eci=dynamics_data.sun_direction_eci,\n                terminals=(\n                    edge[0].terminal,\n                    edge[1].terminal,\n                ),\n                previous_terminal_directions=previous_terminal_directions,\n                time_delta=time_delta,\n            )\n\n            edges_performance[edge] = comm_link_performance\n            terminal_memo[edge] = terminal_directions\n\n        comm_link_time_series.append(edges_performance)\n        prev_time = current_time\n\n    return comm_link_time_series\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryCommLinkCalculator","title":"SatToSatBinaryCommLinkCalculator","text":"<pre><code>SatToSatBinaryCommLinkCalculator(\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0\n)\n</code></pre> <p>               Bases: <code>MemorylessCommLinkCalculator[Satellite, Satellite]</code></p> <p>Calculate satellite-to-satellite communication link performance for each edge in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_satellite_link_capacity: float,\n    max_inter_satellite_distance: float = float(\"inf\"),\n    lowest_altitude: float = 0.0,\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n) -&gt; None:\n    self.max_inter_satellite_distance = max_inter_satellite_distance\n    self.inter_satellite_link_capacity = inter_satellite_link_capacity\n    self.lowest_altitude = lowest_altitude\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n    self.sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryCommLinkCalculator.inter_satellite_link_capacity","title":"inter_satellite_link_capacity  <code>instance-attribute</code>","text":"<pre><code>inter_satellite_link_capacity = (\n    inter_satellite_link_capacity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryCommLinkCalculator.lowest_altitude","title":"lowest_altitude  <code>instance-attribute</code>","text":"<pre><code>lowest_altitude = lowest_altitude\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryCommLinkCalculator.max_inter_satellite_distance","title":"max_inter_satellite_distance  <code>instance-attribute</code>","text":"<pre><code>max_inter_satellite_distance = max_inter_satellite_distance\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryCommLinkCalculator.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryCommLinkCalculator.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges: Collection[tuple[Satellite, Satellite]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; dict[tuple[Satellite, Satellite], CommLinkPerformance]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def calc(\n    self,\n    edges: Collection[tuple[Satellite, Satellite]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,  # noqa: ARG002 For interface compatibility\n) -&gt; dict[tuple[Satellite, Satellite], CommLinkPerformance]:\n    return {\n        edge: self._calc_satellite_to_satellite(\n            positions_eci=(\n                dynamics_data.satellite_position_eci[edge[0]],\n                dynamics_data.satellite_position_eci[edge[1]],\n            ),\n            velocities_eci=(\n                dynamics_data.satellite_velocity_eci[edge[0]],\n                dynamics_data.satellite_velocity_eci[edge[1]],\n            ),\n            attitude_angular_velocities_eci=(\n                dynamics_data.satellite_attitude_angular_velocity_eci[edge[0]],\n                dynamics_data.satellite_attitude_angular_velocity_eci[edge[1]],\n            ),\n            sun_direction_eci=dynamics_data.sun_direction_eci,\n        )\n        for edge in edges\n    }\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryMemoryCommLinkCalculator","title":"SatToSatBinaryMemoryCommLinkCalculator","text":"<pre><code>SatToSatBinaryMemoryCommLinkCalculator(\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[\n        Satellite, Satellite\n    ],\n    link_acquisition_time: float = 60.0,\n    skip_link_acquisition_at_simulation_start: bool = True\n)\n</code></pre> <p>               Bases: <code>CommLinkCalculator[Satellite, Satellite]</code></p> <p>Calculate satellite-to-satellite communication link performance for each edge in a network.</p> <p>The link performance is calculated as a binary value, i.e., 1 if the link is available and 0 otherwise.</p> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def __init__(\n    self,\n    *,\n    memoryless_calculator: MemorylessCommLinkCalculator[Satellite, Satellite],\n    link_acquisition_time: float = 60.0,\n    skip_link_acquisition_at_simulation_start: bool = True,\n) -&gt; None:\n    self.memoryless_calculator = memoryless_calculator\n    self.link_acquisition_time = link_acquisition_time\n    self.skip_link_acquisition_at_simulation_start = skip_link_acquisition_at_simulation_start\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryMemoryCommLinkCalculator.link_acquisition_time","title":"link_acquisition_time  <code>instance-attribute</code>","text":"<pre><code>link_acquisition_time = link_acquisition_time\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryMemoryCommLinkCalculator.memoryless_calculator","title":"memoryless_calculator  <code>instance-attribute</code>","text":"<pre><code>memoryless_calculator = memoryless_calculator\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryMemoryCommLinkCalculator.skip_link_acquisition_at_simulation_start","title":"skip_link_acquisition_at_simulation_start  <code>instance-attribute</code>","text":"<pre><code>skip_link_acquisition_at_simulation_start = (\n    skip_link_acquisition_at_simulation_start\n)\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.SatToSatBinaryMemoryCommLinkCalculator.calc","title":"calc","text":"<pre><code>calc(\n    edges_time_series: Sequence[\n        Collection[tuple[Satellite, Satellite]]\n    ],\n    *,\n    dynamics_data: DynamicsData,\n    rng: Generator\n) -&gt; list[\n    dict[tuple[Satellite, Satellite], CommLinkPerformance]\n]\n</code></pre> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def calc(  # noqa: C901\n    self,\n    edges_time_series: Sequence[Collection[tuple[Satellite, Satellite]]],\n    *,\n    dynamics_data: DynamicsData,\n    rng: np.random.Generator,\n) -&gt; list[dict[tuple[Satellite, Satellite], CommLinkPerformance]]:\n    assert len(edges_time_series) == len(dynamics_data.time)\n\n    comm_link_time_series: list[dict[tuple[Satellite, Satellite], CommLinkPerformance]] = []\n\n    # \u2015 per-edge state \u2015\n    # TODO(): Currently only undirected edges are targeted, so inter-satellite links are represented in frozenset\n    # prev_dot: dict[frozenset[Satellite], float] = {}\n    link_acquisition_start_time: dict[frozenset[Satellite], np.datetime64] = {}\n    prev_edges: frozenset[frozenset[Satellite]] = frozenset()\n\n    for time_index, edges_snapshot in enumerate(edges_time_series):\n        current_time: np.datetime64 = dynamics_data.time[time_index]\n\n        comm_link = self.memoryless_calculator.calc(\n            edges=edges_snapshot,\n            dynamics_data=dynamics_data[time_index],\n            rng=rng,\n        )\n\n        edges_snapshot_set = to_edge_frozenset(edges_snapshot)\n\n        # \u2500\u2500 update \u201cfirst-seen\u201d bookkeeping \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2605\n        new_edges = edges_snapshot_set - prev_edges\n        for edge_fs in new_edges:\n            if self.skip_link_acquisition_at_simulation_start and time_index == 0:\n                link_acquisition_start_time[edge_fs] = current_time - np.timedelta64(\n                    int(self.link_acquisition_time),\n                    \"s\",\n                )\n            else:\n                link_acquisition_start_time[edge_fs] = current_time\n\n        disappeared_edges = prev_edges - edges_snapshot_set\n        for edge_fs in disappeared_edges:  # \u30d5\u30a7\u30fc\u30c9\u30a2\u30a6\u30c8\u3057\u305f\u3089\u72b6\u614b\u3092\u6d88\u53bb\n            link_acquisition_start_time.pop(edge_fs, None)\n            # prev_dot.pop(edge_fs, None)\n        prev_edges = edges_snapshot_set\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n        for edge_fs in edges_snapshot_set:\n            sat_a, sat_b = sorted(edge_fs, key=id)\n\n            if ((sat_a, sat_b) in comm_link and comm_link[(sat_a, sat_b)][\"link_available\"] is False) or (\n                (sat_b, sat_a) in comm_link and comm_link[(sat_b, sat_a)][\"link_available\"] is False\n            ):\n                link_acquisition_start_time[edge_fs] = current_time\n\n            # --- link acquisition delay ------------ \u2605\n            within_link_acquisition: bool = False\n            if edge_fs in link_acquisition_start_time:\n                within_link_acquisition = (\n                    float(\n                        (current_time - link_acquisition_start_time[edge_fs]) / np.timedelta64(1, \"s\"),\n                    )\n                    &lt; self.link_acquisition_time\n                )\n\n            if within_link_acquisition:\n                if (sat_a, sat_b) in comm_link:\n                    comm_link[(sat_a, sat_b)] = CommLinkPerformance(\n                        link_capacity=0.0,\n                        delay=np.inf,\n                        link_available=False,\n                    )\n                elif (sat_b, sat_a) in comm_link:\n                    comm_link[(sat_b, sat_a)] = CommLinkPerformance(\n                        link_capacity=0.0,\n                        delay=np.inf,\n                        link_available=False,\n                    )\n            # ----------------------------------------------------\n\n        comm_link_time_series.append(comm_link)\n\n    return comm_link_time_series\n</code></pre>"},{"location":"reference/cosmica/comm_link/sat_to_sat/#cosmica.comm_link.sat_to_sat.to_edge_frozenset","title":"to_edge_frozenset","text":"<pre><code>to_edge_frozenset(\n    snapshot: Collection[tuple[Satellite, Satellite]],\n) -&gt; frozenset[frozenset[Satellite]]\n</code></pre> <p>Convert a snapshot to {frozenset{SatA, SatB}, \u2026} representation.</p> Source code in <code>src/cosmica/comm_link/sat_to_sat.py</code> <pre><code>def to_edge_frozenset(snapshot: Collection[tuple[Satellite, Satellite]]) -&gt; frozenset[frozenset[Satellite]]:\n    \"\"\"Convert a snapshot to {frozenset{SatA, SatB}, \u2026} representation.\"\"\"\n    return frozenset(frozenset(edge) for edge in snapshot)\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/","title":"uncertainty","text":""},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty","title":"cosmica.comm_link.uncertainty","text":"<p>Models for the uncertainty parameters in the communication link.</p>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"ApertureAveragedLogNormalScintillationModel\",\n    \"AtmosphericScintillationModel\",\n    \"BinaryCloudModel\",\n    \"CloudStates\",\n    \"EdgeFailureModel\",\n    \"ExpEdgeModel\",\n]\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ApertureAveragedLogNormalScintillationModel","title":"ApertureAveragedLogNormalScintillationModel  <code>dataclass</code>","text":"<pre><code>ApertureAveragedLogNormalScintillationModel(\n    *,\n    default_rytov_variance: float,\n    wavelength: float,\n    aperture_diameter: float\n)\n</code></pre> <p>               Bases: <code>AtmosphericScintillationModel[bool_]</code></p>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ApertureAveragedLogNormalScintillationModel.aperture_diameter","title":"aperture_diameter  <code>instance-attribute</code>","text":"<pre><code>aperture_diameter: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ApertureAveragedLogNormalScintillationModel.default_rytov_variance","title":"default_rytov_variance  <code>instance-attribute</code>","text":"<pre><code>default_rytov_variance: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ApertureAveragedLogNormalScintillationModel.k_number","title":"k_number  <code>cached</code> <code>property</code>","text":"<pre><code>k_number: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ApertureAveragedLogNormalScintillationModel.wavelength","title":"wavelength  <code>instance-attribute</code>","text":"<pre><code>wavelength: float\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ApertureAveragedLogNormalScintillationModel.sample","title":"sample","text":"<pre><code>sample(\n    rng: Generator,\n    link_distance: float,\n    rytov_variance: float | None = None,\n) -&gt; float\n</code></pre> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>def sample(\n    self,\n    rng: np.random.Generator,\n    link_distance: float,\n    rytov_variance: float | None = None,\n) -&gt; float:\n    sigma2_scintillation = self.sigma2_scintillation(link_distance, rytov_variance)\n    return rng.lognormal(-sigma2_scintillation / 2, sigma2_scintillation)\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ApertureAveragedLogNormalScintillationModel.scaled_aperture","title":"scaled_aperture","text":"<pre><code>scaled_aperture(link_distance: float) -&gt; float\n</code></pre> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>def scaled_aperture(self, link_distance: float) -&gt; float:\n    return np.sqrt((self.k_number * self.aperture_diameter**2) / (4 * link_distance))\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ApertureAveragedLogNormalScintillationModel.sigma2_scintillation","title":"sigma2_scintillation","text":"<pre><code>sigma2_scintillation(\n    link_distance: float,\n    ryotv_variance: float | None = None,\n) -&gt; float\n</code></pre> RETURNS DESCRIPTION <code>float</code> <p>Float approximation for aperture averaged scintillation for a plane-wave in the absence of inner scale andouter scale effects as described by Larry C. Andrews and Ronald L. Phillips in the book \"Laser BeamPropagation through Random Media\" Chapter 10.</p> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>def sigma2_scintillation(\n    self,\n    link_distance: float,\n    ryotv_variance: float | None = None,\n) -&gt; Annotated[\n    float,\n    Doc(\n        \"Float approximation for aperture averaged scintillation for a plane-wave in the absence of inner scale and\"\n        'outer scale effects as described by Larry C. Andrews and Ronald L. Phillips in the book \"Laser Beam'\n        'Propagation through Random Media\" Chapter 10.',\n    ),\n]:\n    if ryotv_variance is not None and self.default_rytov_variance != ryotv_variance:\n        ryotv_variance = self.default_rytov_variance\n    scaled_aperture = self.scaled_aperture(link_distance=link_distance)\n    num1 = 0.49 * self.default_rytov_variance\n    den1 = (1 + 0.65 * scaled_aperture**2 + 1.11 * self.default_rytov_variance ** (6 / 5)) ** (7 / 6)\n    num2 = 0.51 * self.default_rytov_variance * (1 + 0.69 * self.default_rytov_variance ** (6 / 5)) ** (-5 / 6)\n    den2 = 1 + 0.90 * scaled_aperture**2 + 0.62 * scaled_aperture**2 * self.default_rytov_variance ** (6 / 5)\n    return np.exp(num1 / den1 + num2 / den2) - 1\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.AtmosphericScintillationModel","title":"AtmosphericScintillationModel","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.AtmosphericScintillationModel.sample","title":"sample  <code>abstractmethod</code>","text":"<pre><code>sample(\n    rng: Generator,\n    link_distance: float,\n    rytov_variance: float | None = None,\n) -&gt; float\n</code></pre> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    rng: np.random.Generator,\n    link_distance: float,\n    rytov_variance: float | None = None,\n) -&gt; float: ...\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.BinaryCloudModel","title":"BinaryCloudModel  <code>dataclass</code>","text":"<pre><code>BinaryCloudModel(\n    *,\n    initial_cloud: bool = False,\n    transition_p_0_to_1: float = 0.15,\n    transition_p_1_to_0: float = 0.4\n)\n</code></pre> <p>               Bases: <code>CloudStates[bool_]</code></p> <p>Binary Cloud Model.</p> <p>Generate the state of clouds described by a Markov Chain by calling the 'simulate' method.</p>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.BinaryCloudModel.initial_cloud","title":"initial_cloud  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_cloud: bool = False\n</code></pre> <p>Initial state. True indicates cloudy and False indicates free-of-clouds.</p>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.BinaryCloudModel.transition_p_0_to_1","title":"transition_p_0_to_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transition_p_0_to_1: float = 0.15\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.BinaryCloudModel.transition_p_1_to_0","title":"transition_p_1_to_0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transition_p_1_to_0: float = 0.4\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.BinaryCloudModel.simulate","title":"simulate","text":"<pre><code>simulate(\n    time: NDArray[datetime64], rng: Generator\n) -&gt; NDArray[bool_]\n</code></pre> PARAMETER DESCRIPTION <code>time</code> <p>time_array as a np.ndarray with elements in the np.datetime64 format</p> <p> TYPE: <code>NDArray[datetime64]</code> </p> <code>rng</code> <p>NumPy random number generator.</p> <p> TYPE: <code>Generator</code> </p> RETURNS DESCRIPTION <code>NDArray[bool_]</code> <p>time series of cloud states on given time frame (1|True = cloudy, 0|False = Free-of-clouds)</p> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>def simulate(\n    self,\n    time: Annotated[\n        npt.NDArray[np.datetime64],\n        Doc(\"time_array as a np.ndarray with elements in the np.datetime64 format\"),\n    ],\n    rng: Annotated[np.random.Generator, Doc(\"NumPy random number generator.\")],\n) -&gt; Annotated[\n    npt.NDArray[np.bool_],\n    Doc(\"time series of cloud states on given time frame (1|True = cloudy, 0|False = Free-of-clouds)\"),\n]:\n    sampled = np.empty(time.shape[0], dtype=bool)\n    current_state = self.initial_cloud\n\n    for i in range(time.shape[0]):\n        sampled[i] = current_state\n        next_state = rng.choice(np.array([0, 1]), size=1, p=self._state_tm[int(current_state)])[0]\n        current_state = next_state\n    return sampled\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.CloudStates","title":"CloudStates","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.CloudStates.simulate","title":"simulate  <code>abstractmethod</code>","text":"<pre><code>simulate(\n    time: NDArray[datetime64], rng: Generator\n) -&gt; NDArray[T]\n</code></pre> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>@abstractmethod\ndef simulate(self, time: npt.NDArray[np.datetime64], rng: np.random.Generator) -&gt; npt.NDArray[T]: ...\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.EdgeFailureModel","title":"EdgeFailureModel","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.EdgeFailureModel.simulate","title":"simulate  <code>abstractmethod</code>","text":"<pre><code>simulate(\n    time: NDArray[datetime64], rng: Generator\n) -&gt; NDArray[T]\n</code></pre> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>@abstractmethod\ndef simulate(self, time: npt.NDArray[np.datetime64], rng: np.random.Generator) -&gt; npt.NDArray[T]: ...\n</code></pre>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ExpEdgeModel","title":"ExpEdgeModel  <code>dataclass</code>","text":"<pre><code>ExpEdgeModel(\n    *,\n    reliability: timedelta64 = (\n        lambda: timedelta64(15, \"D\")\n    )(),\n    recovery_time: timedelta64 = (\n        lambda: timedelta64(1800, \"s\")\n    )()\n)\n</code></pre> <p>               Bases: <code>EdgeFailureModel[bool_]</code></p> <p>Exponential Edge Model.</p> <p>Generate the state of an edge following an exponential distribution by calling the 'simulate' method. An edge can be thought as the link between two nodes (e.g. terminals, satellites)</p>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ExpEdgeModel.recovery_time","title":"recovery_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>recovery_time: timedelta64 = field(\n    default_factory=lambda: timedelta64(1800, \"s\")\n)\n</code></pre> <p>Recovery time in seconds (expected)</p>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ExpEdgeModel.reliability","title":"reliability  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reliability: timedelta64 = field(\n    default_factory=lambda: timedelta64(15, \"D\")\n)\n</code></pre> <p>time length in days which the edge is expected not to fail (Expected value of exponential distribution)</p>"},{"location":"reference/cosmica/comm_link/uncertainty/#cosmica.comm_link.uncertainty.ExpEdgeModel.simulate","title":"simulate","text":"<pre><code>simulate(\n    time: NDArray[datetime64], rng: Generator\n) -&gt; NDArray[bool_]\n</code></pre> PARAMETER DESCRIPTION <code>time</code> <p>time_array as a np.ndarray with elements in the np.datetime64 format</p> <p> TYPE: <code>NDArray[datetime64]</code> </p> <code>rng</code> <p>NumPy random number generator</p> <p> TYPE: <code>Generator</code> </p> RETURNS DESCRIPTION <code>NDArray[bool_]</code> <p>time series of edge states on given time frame (True = Failure, False= No-failure)</p> Source code in <code>src/cosmica/comm_link/uncertainty.py</code> <pre><code>def simulate(\n    self,\n    time: Annotated[\n        npt.NDArray[np.datetime64],\n        Doc(\"time_array as a np.ndarray with elements in the np.datetime64 format\"),\n    ],\n    rng: Annotated[np.random.Generator, Doc(\"NumPy random number generator\")],\n) -&gt; Annotated[\n    npt.NDArray[np.bool_],\n    Doc(\"time series of edge states on given time frame (True = Failure, False= No-failure)\"),\n]:\n    state_changed = np.zeros(time.shape, dtype=np.bool_)\n    time_step = time[1] - time[0]\n    total_time = time[-1] - time[0]\n\n    failure_time: np.timedelta64 = rng.exponential(self.reliability / _SECOND) * _SECOND\n    while failure_time &lt;= total_time:\n        failure_idx: int = np.where(time &gt; (time[0] + failure_time))[0][0]\n        state_changed[failure_idx] = True\n        recovery_idx = failure_idx + int(self.recovery_time / time_step)\n        if recovery_idx &lt; state_changed.shape[0]:  # type: ignore[misc] # Possibly a typing bug in NumPy\n            state_changed[recovery_idx] = True\n        else:\n            return np.logical_xor.accumulate(state_changed)\n        failure_time += self.recovery_time + rng.exponential(self.reliability / _SECOND) * _SECOND\n    return np.logical_xor.accumulate(state_changed)\n</code></pre>"},{"location":"reference/cosmica/dtos/","title":"dtos","text":""},{"location":"reference/cosmica/dtos/#cosmica.dtos","title":"cosmica.dtos","text":""},{"location":"reference/cosmica/dtos/#cosmica.dtos.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['DynamicsData']\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData","title":"DynamicsData  <code>dataclass</code>","text":"<pre><code>DynamicsData(\n    *,\n    time: NDArray[datetime64],\n    dcm_eci2ecef: NDArray[floating],\n    satellite_position_eci: dict[T, NDArray[floating]],\n    satellite_velocity_eci: dict[T, NDArray[floating]],\n    satellite_position_ecef: dict[T, NDArray[floating]],\n    satellite_attitude_angular_velocity_eci: dict[\n        T, NDArray[floating]\n    ],\n    sun_direction_eci: NDArray[floating],\n    sun_direction_ecef: NDArray[floating]\n)\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.data_shape","title":"data_shape  <code>property</code>","text":"<pre><code>data_shape: tuple[int, ...]\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.dcm_eci2ecef","title":"dcm_eci2ecef  <code>instance-attribute</code>","text":"<pre><code>dcm_eci2ecef: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.satellite_attitude_angular_velocity_eci","title":"satellite_attitude_angular_velocity_eci  <code>instance-attribute</code>","text":"<pre><code>satellite_attitude_angular_velocity_eci: dict[\n    T, NDArray[floating]\n]\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.satellite_position_ecef","title":"satellite_position_ecef  <code>instance-attribute</code>","text":"<pre><code>satellite_position_ecef: dict[T, NDArray[floating]]\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.satellite_position_eci","title":"satellite_position_eci  <code>instance-attribute</code>","text":"<pre><code>satellite_position_eci: dict[T, NDArray[floating]]\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.satellite_velocity_eci","title":"satellite_velocity_eci  <code>instance-attribute</code>","text":"<pre><code>satellite_velocity_eci: dict[T, NDArray[floating]]\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.sun_direction_ecef","title":"sun_direction_ecef  <code>instance-attribute</code>","text":"<pre><code>sun_direction_ecef: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.sun_direction_eci","title":"sun_direction_eci  <code>instance-attribute</code>","text":"<pre><code>sun_direction_eci: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: NDArray[datetime64]\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(item: int | slice) -&gt; DynamicsData[T]\n</code></pre> Source code in <code>src/cosmica/dtos/dynamics_data.py</code> <pre><code>def __getitem__(self, item: int | slice) -&gt; DynamicsData[T]:\n    return DynamicsData(\n        time=self.time[item],\n        dcm_eci2ecef=self.dcm_eci2ecef[item],\n        satellite_position_eci={key: value[item] for key, value in self.satellite_position_eci.items()},\n        satellite_velocity_eci={key: value[item] for key, value in self.satellite_velocity_eci.items()},\n        satellite_position_ecef={key: value[item] for key, value in self.satellite_position_ecef.items()},\n        satellite_attitude_angular_velocity_eci={\n            key: value[item] for key, value in self.satellite_attitude_angular_velocity_eci.items()\n        },\n        sun_direction_eci=self.sun_direction_eci[item],\n        sun_direction_ecef=self.sun_direction_ecef[item],\n    )\n</code></pre>"},{"location":"reference/cosmica/dtos/#cosmica.dtos.DynamicsData.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/cosmica/dtos/dynamics_data.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    data_shape = self.time.shape\n    assert self.dcm_eci2ecef.shape[:-2] == data_shape\n    assert _check_item_shape_if_any(self.satellite_position_eci, data_shape, slice(-1))\n    assert _check_item_shape_if_any(self.satellite_velocity_eci, data_shape, slice(-1))\n    assert _check_item_shape_if_any(self.satellite_position_ecef, data_shape, slice(-1))\n    assert _check_item_shape_if_any(self.satellite_attitude_angular_velocity_eci, data_shape, slice(-1))\n    assert self.sun_direction_eci.shape[:-1] == data_shape\n    assert self.sun_direction_ecef.shape[:-1] == data_shape\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/","title":"dynamics_data","text":""},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data","title":"cosmica.dtos.dynamics_data","text":""},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['DynamicsData']\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData","title":"DynamicsData  <code>dataclass</code>","text":"<pre><code>DynamicsData(\n    *,\n    time: NDArray[datetime64],\n    dcm_eci2ecef: NDArray[floating],\n    satellite_position_eci: dict[T, NDArray[floating]],\n    satellite_velocity_eci: dict[T, NDArray[floating]],\n    satellite_position_ecef: dict[T, NDArray[floating]],\n    satellite_attitude_angular_velocity_eci: dict[\n        T, NDArray[floating]\n    ],\n    sun_direction_eci: NDArray[floating],\n    sun_direction_ecef: NDArray[floating]\n)\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.data_shape","title":"data_shape  <code>property</code>","text":"<pre><code>data_shape: tuple[int, ...]\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.dcm_eci2ecef","title":"dcm_eci2ecef  <code>instance-attribute</code>","text":"<pre><code>dcm_eci2ecef: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.satellite_attitude_angular_velocity_eci","title":"satellite_attitude_angular_velocity_eci  <code>instance-attribute</code>","text":"<pre><code>satellite_attitude_angular_velocity_eci: dict[\n    T, NDArray[floating]\n]\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.satellite_position_ecef","title":"satellite_position_ecef  <code>instance-attribute</code>","text":"<pre><code>satellite_position_ecef: dict[T, NDArray[floating]]\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.satellite_position_eci","title":"satellite_position_eci  <code>instance-attribute</code>","text":"<pre><code>satellite_position_eci: dict[T, NDArray[floating]]\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.satellite_velocity_eci","title":"satellite_velocity_eci  <code>instance-attribute</code>","text":"<pre><code>satellite_velocity_eci: dict[T, NDArray[floating]]\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.sun_direction_ecef","title":"sun_direction_ecef  <code>instance-attribute</code>","text":"<pre><code>sun_direction_ecef: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.sun_direction_eci","title":"sun_direction_eci  <code>instance-attribute</code>","text":"<pre><code>sun_direction_eci: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: NDArray[datetime64]\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(item: int | slice) -&gt; DynamicsData[T]\n</code></pre> Source code in <code>src/cosmica/dtos/dynamics_data.py</code> <pre><code>def __getitem__(self, item: int | slice) -&gt; DynamicsData[T]:\n    return DynamicsData(\n        time=self.time[item],\n        dcm_eci2ecef=self.dcm_eci2ecef[item],\n        satellite_position_eci={key: value[item] for key, value in self.satellite_position_eci.items()},\n        satellite_velocity_eci={key: value[item] for key, value in self.satellite_velocity_eci.items()},\n        satellite_position_ecef={key: value[item] for key, value in self.satellite_position_ecef.items()},\n        satellite_attitude_angular_velocity_eci={\n            key: value[item] for key, value in self.satellite_attitude_angular_velocity_eci.items()\n        },\n        sun_direction_eci=self.sun_direction_eci[item],\n        sun_direction_ecef=self.sun_direction_ecef[item],\n    )\n</code></pre>"},{"location":"reference/cosmica/dtos/dynamics_data/#cosmica.dtos.dynamics_data.DynamicsData.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/cosmica/dtos/dynamics_data.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    data_shape = self.time.shape\n    assert self.dcm_eci2ecef.shape[:-2] == data_shape\n    assert _check_item_shape_if_any(self.satellite_position_eci, data_shape, slice(-1))\n    assert _check_item_shape_if_any(self.satellite_velocity_eci, data_shape, slice(-1))\n    assert _check_item_shape_if_any(self.satellite_position_ecef, data_shape, slice(-1))\n    assert _check_item_shape_if_any(self.satellite_attitude_angular_velocity_eci, data_shape, slice(-1))\n    assert self.sun_direction_eci.shape[:-1] == data_shape\n    assert self.sun_direction_ecef.shape[:-1] == data_shape\n</code></pre>"},{"location":"reference/cosmica/dynamics/","title":"dynamics","text":""},{"location":"reference/cosmica/dynamics/#cosmica.dynamics","title":"cosmica.dynamics","text":""},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"CircularSatelliteOrbit\",\n    \"CircularSatelliteOrbitPropagator\",\n    \"EllipticalSatelliteOrbit\",\n    \"EllipticalSatelliteOrbitPropagator\",\n    \"MOPCSatelliteKey\",\n    \"MultiOrbitalPlaneConstellation\",\n    \"SatelliteConstellation\",\n    \"SatelliteOrbit\",\n    \"SatelliteOrbitState\",\n    \"get_sun_direction_eci\",\n    \"make_satellite_orbit\",\n]\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit","title":"CircularSatelliteOrbit  <code>dataclass</code>","text":"<pre><code>CircularSatelliteOrbit(\n    *,\n    semi_major_axis: float,\n    inclination: float,\n    raan: float,\n    phase_at_epoch: float,\n    epoch: datetime64\n)\n</code></pre> <p>               Bases: <code>SatelliteOrbit</code></p>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit.dcm_orbit_to_eci","title":"dcm_orbit_to_eci  <code>cached</code> <code>property</code>","text":"<pre><code>dcm_orbit_to_eci: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit.epoch","title":"epoch  <code>instance-attribute</code>","text":"<pre><code>epoch: datetime64\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit.inclination","title":"inclination  <code>instance-attribute</code>","text":"<pre><code>inclination: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit.mean_motion","title":"mean_motion  <code>cached</code> <code>property</code>","text":"<pre><code>mean_motion: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit.phase_at_epoch","title":"phase_at_epoch  <code>instance-attribute</code>","text":"<pre><code>phase_at_epoch: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit.raan","title":"raan  <code>instance-attribute</code>","text":"<pre><code>raan: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit.semi_major_axis","title":"semi_major_axis  <code>instance-attribute</code>","text":"<pre><code>semi_major_axis: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    object.__setattr__(\n        self,\n        \"_model\",\n        CircularSatelliteOrbitModel(\n            semi_major_axis=self.semi_major_axis,\n            inclination=self.inclination,\n            raan=self.raan,\n            phase_at_epoch=self.phase_at_epoch,\n            epoch=self.epoch,\n        ),\n    )\n    object.__setattr__(self, \"_propagator\", CircularSatelliteOrbitPropagator(self._model))\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit.propagate","title":"propagate","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState:\n    return self._propagator.propagate(time)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbit.propagate_from_epoch","title":"propagate_from_epoch","text":"<pre><code>propagate_from_epoch(\n    time_from_epoch: NDArray[timedelta64],\n) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def propagate_from_epoch(self, time_from_epoch: npt.NDArray[np.timedelta64]) -&gt; SatelliteOrbitState:\n    return self._propagator.propagate_from_epoch(time_from_epoch)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbitPropagator","title":"CircularSatelliteOrbitPropagator","text":"<pre><code>CircularSatelliteOrbitPropagator(\n    model: CircularSatelliteOrbitModel,\n)\n</code></pre> <p>               Bases: <code>SatelliteOrbitPropagator</code></p> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __init__(self, model: CircularSatelliteOrbitModel) -&gt; None:\n    self._model = model\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbitPropagator.dcm_orbit_to_eci","title":"dcm_orbit_to_eci  <code>cached</code> <code>property</code>","text":"<pre><code>dcm_orbit_to_eci: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbitPropagator.mean_motion","title":"mean_motion  <code>cached</code> <code>property</code>","text":"<pre><code>mean_motion: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbitPropagator.propagate","title":"propagate","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState:\n    time_from_epoch = time - self._model.epoch\n    return self.propagate_from_epoch(time_from_epoch)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.CircularSatelliteOrbitPropagator.propagate_from_epoch","title":"propagate_from_epoch","text":"<pre><code>propagate_from_epoch(\n    time_from_epoch: NDArray[timedelta64],\n) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def propagate_from_epoch(self, time_from_epoch: npt.NDArray[np.timedelta64]) -&gt; SatelliteOrbitState:\n    time_from_epoch_in_seconds = time_from_epoch / np.timedelta64(1, \"s\")\n    phase = self._model.phase_at_epoch + self.mean_motion * time_from_epoch_in_seconds\n    in_plane_position = self._model.semi_major_axis * np.array([np.cos(phase), np.sin(phase), np.zeros_like(phase)])\n    in_plane_velocity = (\n        self.mean_motion\n        * self._model.semi_major_axis\n        * np.array([-np.sin(phase), np.cos(phase), np.zeros_like(phase)])\n    )\n\n    position_eci: npt.NDArray[np.floating] = rowwise_matmul(self.dcm_orbit_to_eci, in_plane_position.T)\n    velocity_eci: npt.NDArray[np.floating] = rowwise_matmul(self.dcm_orbit_to_eci, in_plane_velocity.T)\n\n    return SatelliteOrbitState(position_eci=position_eci, velocity_eci=velocity_eci)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit","title":"EllipticalSatelliteOrbit  <code>dataclass</code>","text":"<pre><code>EllipticalSatelliteOrbit(\n    *,\n    semi_major_axis: float,\n    inclination: float,\n    raan: float,\n    phase_at_epoch: float,\n    epoch: datetime64,\n    satnum: int,\n    gravity_model: GravityModel = WGS84,\n    drag_coeff: float,\n    eccentricity: float,\n    argpo: float\n)\n</code></pre> <p>               Bases: <code>SatelliteOrbit</code></p>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.argpo","title":"argpo  <code>instance-attribute</code>","text":"<pre><code>argpo: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.drag_coeff","title":"drag_coeff  <code>instance-attribute</code>","text":"<pre><code>drag_coeff: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.eccentricity","title":"eccentricity  <code>instance-attribute</code>","text":"<pre><code>eccentricity: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.epoch","title":"epoch  <code>instance-attribute</code>","text":"<pre><code>epoch: datetime64\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.gravity_model","title":"gravity_model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gravity_model: GravityModel = WGS84\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.inclination","title":"inclination  <code>instance-attribute</code>","text":"<pre><code>inclination: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.mean_motion","title":"mean_motion  <code>cached</code> <code>property</code>","text":"<pre><code>mean_motion: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.phase_at_epoch","title":"phase_at_epoch  <code>instance-attribute</code>","text":"<pre><code>phase_at_epoch: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.raan","title":"raan  <code>instance-attribute</code>","text":"<pre><code>raan: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.satellite","title":"satellite  <code>cached</code> <code>property</code>","text":"<pre><code>satellite: EarthSatellite\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.satnum","title":"satnum  <code>instance-attribute</code>","text":"<pre><code>satnum: int\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.semi_major_axis","title":"semi_major_axis  <code>instance-attribute</code>","text":"<pre><code>semi_major_axis: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.ts","title":"ts  <code>cached</code> <code>property</code>","text":"<pre><code>ts: Timescale\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    object.__setattr__(\n        self,\n        \"_model\",\n        EllipticalSatelliteOrbitModel(\n            semi_major_axis=self.semi_major_axis,\n            inclination=self.inclination,\n            raan=self.raan,\n            phase_at_epoch=self.phase_at_epoch,\n            epoch=self.epoch,\n            satnum=self.satnum,\n            gravity_model=self.gravity_model,\n            drag_coeff=self.drag_coeff,\n            eccentricity=self.eccentricity,\n            argpo=self.argpo,\n        ),\n    )\n    object.__setattr__(self, \"_propagator\", EllipticalSatelliteOrbitPropagator(self._model))\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.datetime64_utc_to_skytime","title":"datetime64_utc_to_skytime","text":"<pre><code>datetime64_utc_to_skytime(\n    t_datetime64: NDArray[datetime64],\n) -&gt; Time\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def datetime64_utc_to_skytime(self, t_datetime64: npt.NDArray[np.datetime64]) -&gt; Time:\n    return self._propagator.datetime64_utc_to_skytime(t_datetime64)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbit.propagate","title":"propagate","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState:\n    return self._propagator.propagate(time)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbitPropagator","title":"EllipticalSatelliteOrbitPropagator","text":"<pre><code>EllipticalSatelliteOrbitPropagator(\n    model: EllipticalSatelliteOrbitModel,\n    reference_frame: ReferenceFrame = \"gcrs\",\n)\n</code></pre> <p>               Bases: <code>SatelliteOrbitPropagator</code></p> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __init__(self, model: EllipticalSatelliteOrbitModel, reference_frame: ReferenceFrame = \"gcrs\") -&gt; None:\n    self._model = model\n    rf = reference_frame.lower()\n    if rf not in {\"teme\", \"j2000\", \"gcrs\"}:\n        logger.error(\"Invalid reference frame: %s\", reference_frame)\n        msg = f\"Invalid reference_frame: {reference_frame!r}\"\n        raise ValueError(msg)\n    self.reference_frame = rf\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbitPropagator.mean_motion","title":"mean_motion  <code>cached</code> <code>property</code>","text":"<pre><code>mean_motion: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbitPropagator.reference_frame","title":"reference_frame  <code>instance-attribute</code>","text":"<pre><code>reference_frame = rf\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbitPropagator.satellite","title":"satellite  <code>cached</code> <code>property</code>","text":"<pre><code>satellite: EarthSatellite\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbitPropagator.ts","title":"ts  <code>cached</code> <code>property</code>","text":"<pre><code>ts: Timescale\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbitPropagator.datetime64_utc_to_skytime","title":"datetime64_utc_to_skytime","text":"<pre><code>datetime64_utc_to_skytime(\n    t_datetime64: NDArray[datetime64],\n) -&gt; Time\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def datetime64_utc_to_skytime(self, t_datetime64: npt.NDArray[np.datetime64]) -&gt; Time:\n    t_datetimes = [time.astype(datetime).replace(tzinfo=utc) for time in t_datetime64]\n    return self.ts.from_datetimes(t_datetimes)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.EllipticalSatelliteOrbitPropagator.propagate","title":"propagate","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>@override\ndef propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState:\n    time_from_epoch = self.datetime64_utc_to_skytime(time)\n    if self.reference_frame in {\"j2000\", \"gcrs\"}:\n        geoc = self.satellite.at(time_from_epoch)  # Geocentric position in GCRS/ICRF axes\n        position_eci_km = geoc.position.km\n        velocity_eci_km_s = geoc.velocity.km_per_s\n        return SatelliteOrbitState(position_eci=position_eci_km.T * 1e3, velocity_eci=velocity_eci_km_s.T * 1e3)\n    else:  # TEME\n        [position_eci, velocity_eci, _] = self.satellite._position_and_velocity_TEME_km(time_from_epoch)  # noqa: SLF001\n        return SatelliteOrbitState(position_eci=position_eci.T * 1e3, velocity_eci=velocity_eci.T * 1e3)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MOPCSatelliteKey","title":"MOPCSatelliteKey","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MOPCSatelliteKey.plane_id","title":"plane_id  <code>instance-attribute</code>","text":"<pre><code>plane_id: int\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MOPCSatelliteKey.satellite_id","title":"satellite_id  <code>instance-attribute</code>","text":"<pre><code>satellite_id: int\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MOPCSatelliteKey.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/dynamics/constellation.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"({self.plane_id},{self.satellite_id})\"\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MultiOrbitalPlaneConstellation","title":"MultiOrbitalPlaneConstellation","text":"<pre><code>MultiOrbitalPlaneConstellation(\n    satellite_orbits: Mapping[\n        ConstellationSatellite[MOPCSatelliteKey], TOrbit\n    ],\n)\n</code></pre> <p>               Bases: <code>SatelliteConstellation[MOPCSatelliteKey, TOrbit]</code></p> <p>A constellation of satellites in multiple orbital planes.</p> <p>The satellite key is a tuple of the plane ID and the satellite ID.</p> Source code in <code>src/cosmica/dynamics/constellation.py</code> <pre><code>def __init__(\n    self,\n    satellite_orbits: Mapping[ConstellationSatellite[MOPCSatelliteKey], TOrbit],\n) -&gt; None:\n    self.satellite_orbits = satellite_orbits\n\n    self.satellites = tuple(self.satellite_orbits.keys())\n    self.plane_ids = sorted({sat.id.plane_id for sat in self.satellites})\n    self.satellite_ids = sorted({sat.id.satellite_id for sat in self.satellites})\n\n    self.plane_id_to_satellites: dict[int, list[ConstellationSatellite[MOPCSatelliteKey]]] = {\n        plane_id: [sat for sat in self.satellites if sat.id.plane_id == plane_id] for plane_id in self.plane_ids\n    }\n\n    # Check if all planes have the same number of satellites\n    self._all_planes_have_same_n_satellites = (\n        len({len(self.plane_id_to_satellites[plane_id]) for plane_id in self.plane_ids}) == 1\n    )\n    if not self._all_planes_have_same_n_satellites:\n        logger.warning(\"Not all planes have the same number of satellites.\")\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MultiOrbitalPlaneConstellation.n_satellites_per_plane","title":"n_satellites_per_plane  <code>property</code>","text":"<pre><code>n_satellites_per_plane: int\n</code></pre> <p>Number of satellites per orbital plane.</p> <p>It is assumed that all planes have the same number of satellites. Otherwise, it will raise an exception.</p>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MultiOrbitalPlaneConstellation.plane_id_to_satellites","title":"plane_id_to_satellites  <code>instance-attribute</code>","text":"<pre><code>plane_id_to_satellites: dict[\n    int, list[ConstellationSatellite[MOPCSatelliteKey]]\n] = {\n    plane_id: [\n        sat for sat in (satellites) if plane_id == plane_id\n    ]\n    for plane_id in (plane_ids)\n}\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MultiOrbitalPlaneConstellation.plane_ids","title":"plane_ids  <code>instance-attribute</code>","text":"<pre><code>plane_ids = sorted({(plane_id) for sat in (satellites)})\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MultiOrbitalPlaneConstellation.satellite_ids","title":"satellite_ids  <code>instance-attribute</code>","text":"<pre><code>satellite_ids = sorted(\n    {(satellite_id) for sat in (satellites)}\n)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MultiOrbitalPlaneConstellation.satellite_orbits","title":"satellite_orbits  <code>instance-attribute</code>","text":"<pre><code>satellite_orbits = satellite_orbits\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MultiOrbitalPlaneConstellation.satellites","title":"satellites  <code>instance-attribute</code>","text":"<pre><code>satellites = tuple(keys())\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MultiOrbitalPlaneConstellation.from_toml_file","title":"from_toml_file  <code>classmethod</code>","text":"<pre><code>from_toml_file(\n    toml_file_path: Path | str,\n) -&gt; MultiOrbitalPlaneConstellation\n</code></pre> Source code in <code>src/cosmica/dynamics/constellation.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef from_toml_file(cls, toml_file_path: Path | str) -&gt; MultiOrbitalPlaneConstellation:\n    toml_file_path = Path(toml_file_path)\n    with toml_file_path.open(\"rb\") as f:\n        toml_data = tomllib.load(f)\n\n    epoch = np.datetime64(toml_data[\"epoch\"].astimezone(tz=UTC).replace(tzinfo=None))\n\n    @deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\n    def parse_satellite_item(\n        item: dict[str, Any],\n    ) -&gt; tuple[ConstellationSatellite[MOPCSatelliteKey], TOrbit]:\n        plane_id = item.pop(\"plane_id\")\n        satellite_id = item.pop(\"id\")\n\n        # Convert degrees to radians\n        item[\"semi_major_axis\"] = item.pop(\"sma_m\")\n        item[\"inclination\"] = np.radians(item.pop(\"inc_deg\"))\n        item[\"raan\"] = np.radians(item.pop(\"raan_deg\"))\n        item[\"phase_at_epoch\"] = np.radians(item.pop(\"phase_at_epoch_deg\"))\n        item[\"epoch\"] = epoch\n\n        orbit_type = item.pop(\"orbit_type\")\n        return ConstellationSatellite(  # type: ignore[return-value]\n            id=MOPCSatelliteKey(plane_id, satellite_id),\n        ), make_satellite_orbit(\n            orbit_type=orbit_type,\n            **item,\n        )\n\n    satellite_orbits = dict(map(parse_satellite_item, toml_data[\"satellites\"]))\n\n    return cls(satellite_orbits)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.MultiOrbitalPlaneConstellation.propagate","title":"propagate","text":"<pre><code>propagate(\n    time: NDArray[datetime64],\n) -&gt; dict[ConstellationSatellite[T], SatelliteOrbitState]\n</code></pre> Source code in <code>src/cosmica/dynamics/constellation.py</code> <pre><code>def propagate(self, time: npt.NDArray[np.datetime64]) -&gt; dict[ConstellationSatellite[T], SatelliteOrbitState]:\n    return {sat: orbit.propagate(time) for sat, orbit in self.satellite_orbits.items()}\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteConstellation","title":"SatelliteConstellation","text":"<p>               Bases: <code>ABC</code></p> <p>A constellation of satellites.</p> <p><code>satellite_orbits</code> is a dictionary mapping satellite keys to satellite orbits.</p>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteConstellation.satellite_orbits","title":"satellite_orbits  <code>instance-attribute</code>","text":"<pre><code>satellite_orbits: Mapping[\n    ConstellationSatellite[T], TOrbit\n]\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteConstellation.satellites","title":"satellites  <code>instance-attribute</code>","text":"<pre><code>satellites: Sequence[ConstellationSatellite[T]]\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteConstellation.propagate","title":"propagate","text":"<pre><code>propagate(\n    time: NDArray[datetime64],\n) -&gt; dict[ConstellationSatellite[T], SatelliteOrbitState]\n</code></pre> Source code in <code>src/cosmica/dynamics/constellation.py</code> <pre><code>def propagate(self, time: npt.NDArray[np.datetime64]) -&gt; dict[ConstellationSatellite[T], SatelliteOrbitState]:\n    return {sat: orbit.propagate(time) for sat, orbit in self.satellite_orbits.items()}\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteOrbit","title":"SatelliteOrbit","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteOrbit.propagate","title":"propagate  <code>abstractmethod</code>","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>@abstractmethod\ndef propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState: ...\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteOrbitState","title":"SatelliteOrbitState  <code>dataclass</code>","text":"<pre><code>SatelliteOrbitState(\n    *,\n    position_eci: NDArray[floating],\n    velocity_eci: NDArray[floating]\n)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteOrbitState.position_eci","title":"position_eci  <code>instance-attribute</code>","text":"<pre><code>position_eci: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteOrbitState.velocity_eci","title":"velocity_eci  <code>instance-attribute</code>","text":"<pre><code>velocity_eci: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteOrbitState.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(item: int | slice) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __getitem__(self, item: int | slice) -&gt; SatelliteOrbitState:\n    return SatelliteOrbitState(\n        position_eci=self.position_eci[item],\n        velocity_eci=self.velocity_eci[item],\n    )\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteOrbitState.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    assert self.position_eci.shape[-1] == 3, self.position_eci.shape\n    assert self.velocity_eci.shape[-1] == 3, self.velocity_eci.shape\n    assert self.position_eci.shape[:-1] == self.velocity_eci.shape[:-1], (\n        self.position_eci.shape,\n        self.velocity_eci.shape,\n    )\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.SatelliteOrbitState.calc_position_ecef","title":"calc_position_ecef","text":"<pre><code>calc_position_ecef(\n    dcm_eci_to_ecef: NDArray[floating],\n) -&gt; NDArray[floating]\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def calc_position_ecef(self, dcm_eci_to_ecef: npt.NDArray[np.floating]) -&gt; npt.NDArray[np.floating]:\n    return np.einsum(\"ijk,ik-&gt;ij\", dcm_eci_to_ecef, self.position_eci)\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.get_sun_direction_eci","title":"get_sun_direction_eci","text":"<pre><code>get_sun_direction_eci(\n    time: NDArray[datetime64],\n) -&gt; NDArray[float64]\n</code></pre><pre><code>get_sun_direction_eci(time: datetime64) -&gt; NDArray[float64]\n</code></pre> <pre><code>get_sun_direction_eci(\n    time: datetime64 | NDArray[datetime64],\n) -&gt; NDArray[float64]\n</code></pre> <p>Sun direction approximation function.</p> <p>The approximation considers an unperturbed motion of the Earth around the Sun with mean orbital elements that approximate the Sun's elliptic orbit wrt Earth around the year 2000. The algorithm is based on Oliver Montenbruck, Eberhard Grill; \"Satellite Orbits: Models, Methods and Applications\"; Springer-Verlag Berlin. The alterations to the original model follow JAXA's Attitude Control Handbook JERG-2-510-HB001.</p> PARAMETER DESCRIPTION <code>time</code> <p>single element or array of UTC time values in np.datetime64 format.</p> <p> TYPE: <code>datetime64 | NDArray[datetime64]</code> </p> RETURNS DESCRIPTION <code>NDArray[float64]</code> <p>Corresponding Sun direction vector(s) (x,y,z) in eci. If the input is a single element, the output is a 1D array. If the input is an array, the output is a 2D array with the shape (len(time), 3).</p> Source code in <code>src/cosmica/dynamics/sun_dynamics.py</code> <pre><code>def get_sun_direction_eci(\n    time: Annotated[\n        np.datetime64 | npt.NDArray[np.datetime64],\n        Doc(\"single element or array of UTC time values in np.datetime64 format.\"),\n    ],\n) -&gt; Annotated[\n    npt.NDArray[np.float64],\n    Doc(\n        \"Corresponding Sun direction vector(s) (x,y,z) in eci.\"\n        \" If the input is a single element, the output is a 1D array.\"\n        \" If the input is an array, the output is a 2D array with the shape (len(time), 3).\",\n    ),\n]:\n    \"\"\"Sun direction approximation function.\n\n    The approximation considers an unperturbed motion of the Earth around the Sun with mean orbital elements\n    that approximate the Sun's elliptic orbit wrt Earth around the year 2000.\n    The algorithm is based on Oliver Montenbruck, Eberhard Grill; \"Satellite Orbits: Models, Methods and Applications\";\n    Springer-Verlag Berlin. The alterations to the original model follow JAXA's Attitude Control Handbook\n    JERG-2-510-HB001.\n    \"\"\"\n    # tdt: Number of Julian Centuries. J2000 epoch -&gt; 2451545.0 TT\n    tdt = (juliandate(time) - 2451545.0) / 36525.0\n\n    # m: mean anomaly\n    m = np.deg2rad(357.5256 + 35999.045 * tdt)\n\n    # right-ascension + argument of perigee = 282.94 deg\n    # s: Sun's ecliptic longitude\n    s = m + np.deg2rad(282.94 + (6892.0 * np.sin(m) + 72.0 * np.sin(2.0 * m) + 1250.09115 * tdt) / 3600.0 - 0.002652)\n\n    # Obliquity of the ecliptic in radians\n    epsilon_deg = 23.43929111\n    epsilon = np.deg2rad(epsilon_deg)\n\n    # Compute Sun Vector @ J2000. Shape: (3,) or (3, len(time))\n    sun_vec_eci = np.array([np.cos(s), np.sin(s) * np.cos(epsilon), np.sin(s) * np.sin(epsilon)], dtype=np.float64)\n\n    # normalize\n    sun_vec_eci = sun_vec_eci.T  # shape: (3,) or (len(time), 3)\n\n    # shape: (3,) or (len(time), 3)\n    return normalize(sun_vec_eci, axis=-1)  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/cosmica/dynamics/#cosmica.dynamics.make_satellite_orbit","title":"make_satellite_orbit","text":"<pre><code>make_satellite_orbit(\n    orbit_type: Literal[\"circular\"],\n    *args: Any,\n    **kwargs: Any\n) -&gt; SatelliteOrbit\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def make_satellite_orbit(\n    orbit_type: Literal[\"circular\"],\n    *args: Any,\n    **kwargs: Any,\n) -&gt; SatelliteOrbit:\n    if orbit_type == \"circular\":\n        return CircularSatelliteOrbit(*args, **kwargs)\n    else:\n        msg = f\"Unknown orbit type: {orbit_type}\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/","title":"constellation","text":""},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation","title":"cosmica.dynamics.constellation","text":""},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"MOPCSatelliteKey\",\n    \"MultiOrbitalPlaneConstellation\",\n    \"SatelliteConstellation\",\n]\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MOPCSatelliteKey","title":"MOPCSatelliteKey","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MOPCSatelliteKey.plane_id","title":"plane_id  <code>instance-attribute</code>","text":"<pre><code>plane_id: int\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MOPCSatelliteKey.satellite_id","title":"satellite_id  <code>instance-attribute</code>","text":"<pre><code>satellite_id: int\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MOPCSatelliteKey.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/dynamics/constellation.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"({self.plane_id},{self.satellite_id})\"\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MultiOrbitalPlaneConstellation","title":"MultiOrbitalPlaneConstellation","text":"<pre><code>MultiOrbitalPlaneConstellation(\n    satellite_orbits: Mapping[\n        ConstellationSatellite[MOPCSatelliteKey], TOrbit\n    ],\n)\n</code></pre> <p>               Bases: <code>SatelliteConstellation[MOPCSatelliteKey, TOrbit]</code></p> <p>A constellation of satellites in multiple orbital planes.</p> <p>The satellite key is a tuple of the plane ID and the satellite ID.</p> Source code in <code>src/cosmica/dynamics/constellation.py</code> <pre><code>def __init__(\n    self,\n    satellite_orbits: Mapping[ConstellationSatellite[MOPCSatelliteKey], TOrbit],\n) -&gt; None:\n    self.satellite_orbits = satellite_orbits\n\n    self.satellites = tuple(self.satellite_orbits.keys())\n    self.plane_ids = sorted({sat.id.plane_id for sat in self.satellites})\n    self.satellite_ids = sorted({sat.id.satellite_id for sat in self.satellites})\n\n    self.plane_id_to_satellites: dict[int, list[ConstellationSatellite[MOPCSatelliteKey]]] = {\n        plane_id: [sat for sat in self.satellites if sat.id.plane_id == plane_id] for plane_id in self.plane_ids\n    }\n\n    # Check if all planes have the same number of satellites\n    self._all_planes_have_same_n_satellites = (\n        len({len(self.plane_id_to_satellites[plane_id]) for plane_id in self.plane_ids}) == 1\n    )\n    if not self._all_planes_have_same_n_satellites:\n        logger.warning(\"Not all planes have the same number of satellites.\")\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MultiOrbitalPlaneConstellation.n_satellites_per_plane","title":"n_satellites_per_plane  <code>property</code>","text":"<pre><code>n_satellites_per_plane: int\n</code></pre> <p>Number of satellites per orbital plane.</p> <p>It is assumed that all planes have the same number of satellites. Otherwise, it will raise an exception.</p>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MultiOrbitalPlaneConstellation.plane_id_to_satellites","title":"plane_id_to_satellites  <code>instance-attribute</code>","text":"<pre><code>plane_id_to_satellites: dict[\n    int, list[ConstellationSatellite[MOPCSatelliteKey]]\n] = {\n    plane_id: [\n        sat for sat in (satellites) if plane_id == plane_id\n    ]\n    for plane_id in (plane_ids)\n}\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MultiOrbitalPlaneConstellation.plane_ids","title":"plane_ids  <code>instance-attribute</code>","text":"<pre><code>plane_ids = sorted({(plane_id) for sat in (satellites)})\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MultiOrbitalPlaneConstellation.satellite_ids","title":"satellite_ids  <code>instance-attribute</code>","text":"<pre><code>satellite_ids = sorted(\n    {(satellite_id) for sat in (satellites)}\n)\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MultiOrbitalPlaneConstellation.satellite_orbits","title":"satellite_orbits  <code>instance-attribute</code>","text":"<pre><code>satellite_orbits = satellite_orbits\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MultiOrbitalPlaneConstellation.satellites","title":"satellites  <code>instance-attribute</code>","text":"<pre><code>satellites = tuple(keys())\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MultiOrbitalPlaneConstellation.from_toml_file","title":"from_toml_file  <code>classmethod</code>","text":"<pre><code>from_toml_file(\n    toml_file_path: Path | str,\n) -&gt; MultiOrbitalPlaneConstellation\n</code></pre> Source code in <code>src/cosmica/dynamics/constellation.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef from_toml_file(cls, toml_file_path: Path | str) -&gt; MultiOrbitalPlaneConstellation:\n    toml_file_path = Path(toml_file_path)\n    with toml_file_path.open(\"rb\") as f:\n        toml_data = tomllib.load(f)\n\n    epoch = np.datetime64(toml_data[\"epoch\"].astimezone(tz=UTC).replace(tzinfo=None))\n\n    @deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\n    def parse_satellite_item(\n        item: dict[str, Any],\n    ) -&gt; tuple[ConstellationSatellite[MOPCSatelliteKey], TOrbit]:\n        plane_id = item.pop(\"plane_id\")\n        satellite_id = item.pop(\"id\")\n\n        # Convert degrees to radians\n        item[\"semi_major_axis\"] = item.pop(\"sma_m\")\n        item[\"inclination\"] = np.radians(item.pop(\"inc_deg\"))\n        item[\"raan\"] = np.radians(item.pop(\"raan_deg\"))\n        item[\"phase_at_epoch\"] = np.radians(item.pop(\"phase_at_epoch_deg\"))\n        item[\"epoch\"] = epoch\n\n        orbit_type = item.pop(\"orbit_type\")\n        return ConstellationSatellite(  # type: ignore[return-value]\n            id=MOPCSatelliteKey(plane_id, satellite_id),\n        ), make_satellite_orbit(\n            orbit_type=orbit_type,\n            **item,\n        )\n\n    satellite_orbits = dict(map(parse_satellite_item, toml_data[\"satellites\"]))\n\n    return cls(satellite_orbits)\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.MultiOrbitalPlaneConstellation.propagate","title":"propagate","text":"<pre><code>propagate(\n    time: NDArray[datetime64],\n) -&gt; dict[ConstellationSatellite[T], SatelliteOrbitState]\n</code></pre> Source code in <code>src/cosmica/dynamics/constellation.py</code> <pre><code>def propagate(self, time: npt.NDArray[np.datetime64]) -&gt; dict[ConstellationSatellite[T], SatelliteOrbitState]:\n    return {sat: orbit.propagate(time) for sat, orbit in self.satellite_orbits.items()}\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.SatelliteConstellation","title":"SatelliteConstellation","text":"<p>               Bases: <code>ABC</code></p> <p>A constellation of satellites.</p> <p><code>satellite_orbits</code> is a dictionary mapping satellite keys to satellite orbits.</p>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.SatelliteConstellation.satellite_orbits","title":"satellite_orbits  <code>instance-attribute</code>","text":"<pre><code>satellite_orbits: Mapping[\n    ConstellationSatellite[T], TOrbit\n]\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.SatelliteConstellation.satellites","title":"satellites  <code>instance-attribute</code>","text":"<pre><code>satellites: Sequence[ConstellationSatellite[T]]\n</code></pre>"},{"location":"reference/cosmica/dynamics/constellation/#cosmica.dynamics.constellation.SatelliteConstellation.propagate","title":"propagate","text":"<pre><code>propagate(\n    time: NDArray[datetime64],\n) -&gt; dict[ConstellationSatellite[T], SatelliteOrbitState]\n</code></pre> Source code in <code>src/cosmica/dynamics/constellation.py</code> <pre><code>def propagate(self, time: npt.NDArray[np.datetime64]) -&gt; dict[ConstellationSatellite[T], SatelliteOrbitState]:\n    return {sat: orbit.propagate(time) for sat, orbit in self.satellite_orbits.items()}\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/","title":"orbit","text":""},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit","title":"cosmica.dynamics.orbit","text":""},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.ReferenceFrame","title":"ReferenceFrame  <code>module-attribute</code>","text":"<pre><code>ReferenceFrame = Literal['teme', 'j2000', 'gcrs']\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"CircularSatelliteOrbit\",\n    \"CircularSatelliteOrbitPropagator\",\n    \"EllipticalSatelliteOrbit\",\n    \"EllipticalSatelliteOrbitPropagator\",\n    \"SatelliteOrbit\",\n    \"SatelliteOrbitState\",\n    \"make_satellite_orbit\",\n]\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit","title":"CircularSatelliteOrbit  <code>dataclass</code>","text":"<pre><code>CircularSatelliteOrbit(\n    *,\n    semi_major_axis: float,\n    inclination: float,\n    raan: float,\n    phase_at_epoch: float,\n    epoch: datetime64\n)\n</code></pre> <p>               Bases: <code>SatelliteOrbit</code></p>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit.dcm_orbit_to_eci","title":"dcm_orbit_to_eci  <code>cached</code> <code>property</code>","text":"<pre><code>dcm_orbit_to_eci: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit.epoch","title":"epoch  <code>instance-attribute</code>","text":"<pre><code>epoch: datetime64\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit.inclination","title":"inclination  <code>instance-attribute</code>","text":"<pre><code>inclination: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit.mean_motion","title":"mean_motion  <code>cached</code> <code>property</code>","text":"<pre><code>mean_motion: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit.phase_at_epoch","title":"phase_at_epoch  <code>instance-attribute</code>","text":"<pre><code>phase_at_epoch: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit.raan","title":"raan  <code>instance-attribute</code>","text":"<pre><code>raan: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit.semi_major_axis","title":"semi_major_axis  <code>instance-attribute</code>","text":"<pre><code>semi_major_axis: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    object.__setattr__(\n        self,\n        \"_model\",\n        CircularSatelliteOrbitModel(\n            semi_major_axis=self.semi_major_axis,\n            inclination=self.inclination,\n            raan=self.raan,\n            phase_at_epoch=self.phase_at_epoch,\n            epoch=self.epoch,\n        ),\n    )\n    object.__setattr__(self, \"_propagator\", CircularSatelliteOrbitPropagator(self._model))\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit.propagate","title":"propagate","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState:\n    return self._propagator.propagate(time)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbit.propagate_from_epoch","title":"propagate_from_epoch","text":"<pre><code>propagate_from_epoch(\n    time_from_epoch: NDArray[timedelta64],\n) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def propagate_from_epoch(self, time_from_epoch: npt.NDArray[np.timedelta64]) -&gt; SatelliteOrbitState:\n    return self._propagator.propagate_from_epoch(time_from_epoch)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbitPropagator","title":"CircularSatelliteOrbitPropagator","text":"<pre><code>CircularSatelliteOrbitPropagator(\n    model: CircularSatelliteOrbitModel,\n)\n</code></pre> <p>               Bases: <code>SatelliteOrbitPropagator</code></p> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __init__(self, model: CircularSatelliteOrbitModel) -&gt; None:\n    self._model = model\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbitPropagator.dcm_orbit_to_eci","title":"dcm_orbit_to_eci  <code>cached</code> <code>property</code>","text":"<pre><code>dcm_orbit_to_eci: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbitPropagator.mean_motion","title":"mean_motion  <code>cached</code> <code>property</code>","text":"<pre><code>mean_motion: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbitPropagator.propagate","title":"propagate","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState:\n    time_from_epoch = time - self._model.epoch\n    return self.propagate_from_epoch(time_from_epoch)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.CircularSatelliteOrbitPropagator.propagate_from_epoch","title":"propagate_from_epoch","text":"<pre><code>propagate_from_epoch(\n    time_from_epoch: NDArray[timedelta64],\n) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def propagate_from_epoch(self, time_from_epoch: npt.NDArray[np.timedelta64]) -&gt; SatelliteOrbitState:\n    time_from_epoch_in_seconds = time_from_epoch / np.timedelta64(1, \"s\")\n    phase = self._model.phase_at_epoch + self.mean_motion * time_from_epoch_in_seconds\n    in_plane_position = self._model.semi_major_axis * np.array([np.cos(phase), np.sin(phase), np.zeros_like(phase)])\n    in_plane_velocity = (\n        self.mean_motion\n        * self._model.semi_major_axis\n        * np.array([-np.sin(phase), np.cos(phase), np.zeros_like(phase)])\n    )\n\n    position_eci: npt.NDArray[np.floating] = rowwise_matmul(self.dcm_orbit_to_eci, in_plane_position.T)\n    velocity_eci: npt.NDArray[np.floating] = rowwise_matmul(self.dcm_orbit_to_eci, in_plane_velocity.T)\n\n    return SatelliteOrbitState(position_eci=position_eci, velocity_eci=velocity_eci)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit","title":"EllipticalSatelliteOrbit  <code>dataclass</code>","text":"<pre><code>EllipticalSatelliteOrbit(\n    *,\n    semi_major_axis: float,\n    inclination: float,\n    raan: float,\n    phase_at_epoch: float,\n    epoch: datetime64,\n    satnum: int,\n    gravity_model: GravityModel = WGS84,\n    drag_coeff: float,\n    eccentricity: float,\n    argpo: float\n)\n</code></pre> <p>               Bases: <code>SatelliteOrbit</code></p>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.argpo","title":"argpo  <code>instance-attribute</code>","text":"<pre><code>argpo: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.drag_coeff","title":"drag_coeff  <code>instance-attribute</code>","text":"<pre><code>drag_coeff: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.eccentricity","title":"eccentricity  <code>instance-attribute</code>","text":"<pre><code>eccentricity: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.epoch","title":"epoch  <code>instance-attribute</code>","text":"<pre><code>epoch: datetime64\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.gravity_model","title":"gravity_model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gravity_model: GravityModel = WGS84\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.inclination","title":"inclination  <code>instance-attribute</code>","text":"<pre><code>inclination: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.mean_motion","title":"mean_motion  <code>cached</code> <code>property</code>","text":"<pre><code>mean_motion: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.phase_at_epoch","title":"phase_at_epoch  <code>instance-attribute</code>","text":"<pre><code>phase_at_epoch: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.raan","title":"raan  <code>instance-attribute</code>","text":"<pre><code>raan: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.satellite","title":"satellite  <code>cached</code> <code>property</code>","text":"<pre><code>satellite: EarthSatellite\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.satnum","title":"satnum  <code>instance-attribute</code>","text":"<pre><code>satnum: int\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.semi_major_axis","title":"semi_major_axis  <code>instance-attribute</code>","text":"<pre><code>semi_major_axis: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.ts","title":"ts  <code>cached</code> <code>property</code>","text":"<pre><code>ts: Timescale\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    object.__setattr__(\n        self,\n        \"_model\",\n        EllipticalSatelliteOrbitModel(\n            semi_major_axis=self.semi_major_axis,\n            inclination=self.inclination,\n            raan=self.raan,\n            phase_at_epoch=self.phase_at_epoch,\n            epoch=self.epoch,\n            satnum=self.satnum,\n            gravity_model=self.gravity_model,\n            drag_coeff=self.drag_coeff,\n            eccentricity=self.eccentricity,\n            argpo=self.argpo,\n        ),\n    )\n    object.__setattr__(self, \"_propagator\", EllipticalSatelliteOrbitPropagator(self._model))\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.datetime64_utc_to_skytime","title":"datetime64_utc_to_skytime","text":"<pre><code>datetime64_utc_to_skytime(\n    t_datetime64: NDArray[datetime64],\n) -&gt; Time\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def datetime64_utc_to_skytime(self, t_datetime64: npt.NDArray[np.datetime64]) -&gt; Time:\n    return self._propagator.datetime64_utc_to_skytime(t_datetime64)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbit.propagate","title":"propagate","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState:\n    return self._propagator.propagate(time)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbitPropagator","title":"EllipticalSatelliteOrbitPropagator","text":"<pre><code>EllipticalSatelliteOrbitPropagator(\n    model: EllipticalSatelliteOrbitModel,\n    reference_frame: ReferenceFrame = \"gcrs\",\n)\n</code></pre> <p>               Bases: <code>SatelliteOrbitPropagator</code></p> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __init__(self, model: EllipticalSatelliteOrbitModel, reference_frame: ReferenceFrame = \"gcrs\") -&gt; None:\n    self._model = model\n    rf = reference_frame.lower()\n    if rf not in {\"teme\", \"j2000\", \"gcrs\"}:\n        logger.error(\"Invalid reference frame: %s\", reference_frame)\n        msg = f\"Invalid reference_frame: {reference_frame!r}\"\n        raise ValueError(msg)\n    self.reference_frame = rf\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbitPropagator.mean_motion","title":"mean_motion  <code>cached</code> <code>property</code>","text":"<pre><code>mean_motion: float\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbitPropagator.reference_frame","title":"reference_frame  <code>instance-attribute</code>","text":"<pre><code>reference_frame = rf\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbitPropagator.satellite","title":"satellite  <code>cached</code> <code>property</code>","text":"<pre><code>satellite: EarthSatellite\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbitPropagator.ts","title":"ts  <code>cached</code> <code>property</code>","text":"<pre><code>ts: Timescale\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbitPropagator.datetime64_utc_to_skytime","title":"datetime64_utc_to_skytime","text":"<pre><code>datetime64_utc_to_skytime(\n    t_datetime64: NDArray[datetime64],\n) -&gt; Time\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def datetime64_utc_to_skytime(self, t_datetime64: npt.NDArray[np.datetime64]) -&gt; Time:\n    t_datetimes = [time.astype(datetime).replace(tzinfo=utc) for time in t_datetime64]\n    return self.ts.from_datetimes(t_datetimes)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.EllipticalSatelliteOrbitPropagator.propagate","title":"propagate","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>@override\ndef propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState:\n    time_from_epoch = self.datetime64_utc_to_skytime(time)\n    if self.reference_frame in {\"j2000\", \"gcrs\"}:\n        geoc = self.satellite.at(time_from_epoch)  # Geocentric position in GCRS/ICRF axes\n        position_eci_km = geoc.position.km\n        velocity_eci_km_s = geoc.velocity.km_per_s\n        return SatelliteOrbitState(position_eci=position_eci_km.T * 1e3, velocity_eci=velocity_eci_km_s.T * 1e3)\n    else:  # TEME\n        [position_eci, velocity_eci, _] = self.satellite._position_and_velocity_TEME_km(time_from_epoch)  # noqa: SLF001\n        return SatelliteOrbitState(position_eci=position_eci.T * 1e3, velocity_eci=velocity_eci.T * 1e3)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.SatelliteOrbit","title":"SatelliteOrbit","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.SatelliteOrbit.propagate","title":"propagate  <code>abstractmethod</code>","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>@abstractmethod\ndef propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState: ...\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.SatelliteOrbitPropagator","title":"SatelliteOrbitPropagator","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.SatelliteOrbitPropagator.propagate","title":"propagate  <code>abstractmethod</code>","text":"<pre><code>propagate(time: NDArray[datetime64]) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>@abstractmethod\ndef propagate(self, time: npt.NDArray[np.datetime64]) -&gt; SatelliteOrbitState: ...\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.SatelliteOrbitState","title":"SatelliteOrbitState  <code>dataclass</code>","text":"<pre><code>SatelliteOrbitState(\n    *,\n    position_eci: NDArray[floating],\n    velocity_eci: NDArray[floating]\n)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.SatelliteOrbitState.position_eci","title":"position_eci  <code>instance-attribute</code>","text":"<pre><code>position_eci: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.SatelliteOrbitState.velocity_eci","title":"velocity_eci  <code>instance-attribute</code>","text":"<pre><code>velocity_eci: NDArray[floating]\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.SatelliteOrbitState.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(item: int | slice) -&gt; SatelliteOrbitState\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __getitem__(self, item: int | slice) -&gt; SatelliteOrbitState:\n    return SatelliteOrbitState(\n        position_eci=self.position_eci[item],\n        velocity_eci=self.velocity_eci[item],\n    )\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.SatelliteOrbitState.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    assert self.position_eci.shape[-1] == 3, self.position_eci.shape\n    assert self.velocity_eci.shape[-1] == 3, self.velocity_eci.shape\n    assert self.position_eci.shape[:-1] == self.velocity_eci.shape[:-1], (\n        self.position_eci.shape,\n        self.velocity_eci.shape,\n    )\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.SatelliteOrbitState.calc_position_ecef","title":"calc_position_ecef","text":"<pre><code>calc_position_ecef(\n    dcm_eci_to_ecef: NDArray[floating],\n) -&gt; NDArray[floating]\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def calc_position_ecef(self, dcm_eci_to_ecef: npt.NDArray[np.floating]) -&gt; npt.NDArray[np.floating]:\n    return np.einsum(\"ijk,ik-&gt;ij\", dcm_eci_to_ecef, self.position_eci)\n</code></pre>"},{"location":"reference/cosmica/dynamics/orbit/#cosmica.dynamics.orbit.make_satellite_orbit","title":"make_satellite_orbit","text":"<pre><code>make_satellite_orbit(\n    orbit_type: Literal[\"circular\"],\n    *args: Any,\n    **kwargs: Any\n) -&gt; SatelliteOrbit\n</code></pre> Source code in <code>src/cosmica/dynamics/orbit.py</code> <pre><code>def make_satellite_orbit(\n    orbit_type: Literal[\"circular\"],\n    *args: Any,\n    **kwargs: Any,\n) -&gt; SatelliteOrbit:\n    if orbit_type == \"circular\":\n        return CircularSatelliteOrbit(*args, **kwargs)\n    else:\n        msg = f\"Unknown orbit type: {orbit_type}\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/cosmica/dynamics/plotting/","title":"plotting","text":""},{"location":"reference/cosmica/dynamics/plotting/#cosmica.dynamics.plotting","title":"cosmica.dynamics.plotting","text":""},{"location":"reference/cosmica/dynamics/plotting/#cosmica.dynamics.plotting.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['visualize_multi_orbital_plane_constellation']\n</code></pre>"},{"location":"reference/cosmica/dynamics/plotting/#cosmica.dynamics.plotting.visualize_multi_orbital_plane_constellation","title":"visualize_multi_orbital_plane_constellation","text":"<pre><code>visualize_multi_orbital_plane_constellation(\n    constellation: MultiOrbitalPlaneConstellation[\n        CircularSatelliteOrbit\n    ],\n    propagation_result: Mapping[\n        ConstellationSatellite, SatelliteOrbitState\n    ],\n    time_index: int = 0,\n) -&gt; None\n</code></pre> Source code in <code>src/cosmica/dynamics/plotting.py</code> <pre><code>def visualize_multi_orbital_plane_constellation(\n    constellation: MultiOrbitalPlaneConstellation[CircularSatelliteOrbit],\n    propagation_result: Mapping[ConstellationSatellite, SatelliteOrbitState],\n    time_index: int = 0,\n) -&gt; None:\n    fig = plt.figure()\n    ax: Axes3D = fig.add_subplot(111, projection=\"3d\")\n\n    cmap = mpl.colormaps[\"tab20\"]\n\n    # Plot the Earth\n    ax.plot_surface(*_ms(0, 0, 0, EARTH_RADIUS), color=\"blue\", alpha=0.2)\n\n    # Plot the orbit trajectory of the first satellite in each orbital plane\n    for i, plane_id in enumerate(constellation.plane_ids):\n        satellite = constellation.plane_id_to_satellites[plane_id][0]\n        ax.plot(\n            propagation_result[satellite].position_eci[:, 0],\n            propagation_result[satellite].position_eci[:, 1],\n            propagation_result[satellite].position_eci[:, 2],\n            color=cmap(i),\n            linewidth=0.5,\n            label=f\"Plane {plane_id}\",\n        )\n        for satellite in constellation.satellites:\n            # Plot the position of each satellite at the `time_index`\n            ax.plot(\n                propagation_result[satellite].position_eci[time_index, 0],\n                propagation_result[satellite].position_eci[time_index, 1],\n                propagation_result[satellite].position_eci[time_index, 2],\n                \"ro\",\n                markersize=2,\n            )\n\n    # Set plot labels and aspect ratio\n    ax.set_xlabel(\"X (km)\")\n    ax.set_ylabel(\"Y (km)\")\n    ax.set_zlabel(\"Z (km)\")\n    ax.set_box_aspect([1, 1, 1])\n\n    ax.legend()\n\n    plt.show()\n</code></pre>"},{"location":"reference/cosmica/dynamics/sun_dynamics/","title":"sun_dynamics","text":""},{"location":"reference/cosmica/dynamics/sun_dynamics/#cosmica.dynamics.sun_dynamics","title":"cosmica.dynamics.sun_dynamics","text":""},{"location":"reference/cosmica/dynamics/sun_dynamics/#cosmica.dynamics.sun_dynamics.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['get_sun_direction_eci']\n</code></pre>"},{"location":"reference/cosmica/dynamics/sun_dynamics/#cosmica.dynamics.sun_dynamics.get_sun_direction_eci","title":"get_sun_direction_eci","text":"<pre><code>get_sun_direction_eci(\n    time: NDArray[datetime64],\n) -&gt; NDArray[float64]\n</code></pre><pre><code>get_sun_direction_eci(time: datetime64) -&gt; NDArray[float64]\n</code></pre> <pre><code>get_sun_direction_eci(\n    time: datetime64 | NDArray[datetime64],\n) -&gt; NDArray[float64]\n</code></pre> <p>Sun direction approximation function.</p> <p>The approximation considers an unperturbed motion of the Earth around the Sun with mean orbital elements that approximate the Sun's elliptic orbit wrt Earth around the year 2000. The algorithm is based on Oliver Montenbruck, Eberhard Grill; \"Satellite Orbits: Models, Methods and Applications\"; Springer-Verlag Berlin. The alterations to the original model follow JAXA's Attitude Control Handbook JERG-2-510-HB001.</p> PARAMETER DESCRIPTION <code>time</code> <p>single element or array of UTC time values in np.datetime64 format.</p> <p> TYPE: <code>datetime64 | NDArray[datetime64]</code> </p> RETURNS DESCRIPTION <code>NDArray[float64]</code> <p>Corresponding Sun direction vector(s) (x,y,z) in eci. If the input is a single element, the output is a 1D array. If the input is an array, the output is a 2D array with the shape (len(time), 3).</p> Source code in <code>src/cosmica/dynamics/sun_dynamics.py</code> <pre><code>def get_sun_direction_eci(\n    time: Annotated[\n        np.datetime64 | npt.NDArray[np.datetime64],\n        Doc(\"single element or array of UTC time values in np.datetime64 format.\"),\n    ],\n) -&gt; Annotated[\n    npt.NDArray[np.float64],\n    Doc(\n        \"Corresponding Sun direction vector(s) (x,y,z) in eci.\"\n        \" If the input is a single element, the output is a 1D array.\"\n        \" If the input is an array, the output is a 2D array with the shape (len(time), 3).\",\n    ),\n]:\n    \"\"\"Sun direction approximation function.\n\n    The approximation considers an unperturbed motion of the Earth around the Sun with mean orbital elements\n    that approximate the Sun's elliptic orbit wrt Earth around the year 2000.\n    The algorithm is based on Oliver Montenbruck, Eberhard Grill; \"Satellite Orbits: Models, Methods and Applications\";\n    Springer-Verlag Berlin. The alterations to the original model follow JAXA's Attitude Control Handbook\n    JERG-2-510-HB001.\n    \"\"\"\n    # tdt: Number of Julian Centuries. J2000 epoch -&gt; 2451545.0 TT\n    tdt = (juliandate(time) - 2451545.0) / 36525.0\n\n    # m: mean anomaly\n    m = np.deg2rad(357.5256 + 35999.045 * tdt)\n\n    # right-ascension + argument of perigee = 282.94 deg\n    # s: Sun's ecliptic longitude\n    s = m + np.deg2rad(282.94 + (6892.0 * np.sin(m) + 72.0 * np.sin(2.0 * m) + 1250.09115 * tdt) / 3600.0 - 0.002652)\n\n    # Obliquity of the ecliptic in radians\n    epsilon_deg = 23.43929111\n    epsilon = np.deg2rad(epsilon_deg)\n\n    # Compute Sun Vector @ J2000. Shape: (3,) or (3, len(time))\n    sun_vec_eci = np.array([np.cos(s), np.sin(s) * np.cos(epsilon), np.sin(s) * np.sin(epsilon)], dtype=np.float64)\n\n    # normalize\n    sun_vec_eci = sun_vec_eci.T  # shape: (3,) or (len(time), 3)\n\n    # shape: (3,) or (len(time), 3)\n    return normalize(sun_vec_eci, axis=-1)  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/","title":"experimental_packet_routing","text":""},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing","title":"cosmica.experimental_packet_routing","text":""},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.BackupCaseType","title":"BackupCaseType  <code>module-attribute</code>","text":"<pre><code>BackupCaseType = Literal[\n    \"no-backup\",\n    \"backup-feeder-links\",\n    \"backup-n-hops-links\",\n    \"backup-n-hops-links-and-feeder-links\",\n    \"dual-backup-n-hops-links-and-feeder-links\",\n]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"BackupCaseType\",\n    \"PacketCommunicationSimulator\",\n    \"PacketRoutingResult\",\n    \"PacketRoutingSetting\",\n    \"RoutingResultVisualizer\",\n    \"RoutingResultVisualizer\",\n    \"SpaceTimeGraph\",\n]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator","title":"PacketCommunicationSimulator","text":"<pre><code>PacketCommunicationSimulator(\n    time: NDArray[datetime64],\n    all_graphs_with_comm_performance: list[Graph],\n    nodes_dict: dict[NodeGID, Node],\n    demands: list[Demand],\n    *,\n    backup_case: BackupCaseType = \"no-backup\",\n    hop_limit: int = 1,\n    packet_size: int = int(10000.0),\n    space_time_graph: SpaceTimeGraph\n)\n</code></pre> <p>\u6642\u7cfb\u5217\u306e\u30d1\u30b1\u30c3\u30c8\u30ec\u30d9\u30eb\u306e\u901a\u4fe1\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u5b9f\u65bd\u3059\u308b\u30af\u30e9\u30b9.</p> PARAMETER DESCRIPTION <code>time</code> <p>Array of datetime64 representing the time points</p> <p> TYPE: <code>NDArray[datetime64]</code> </p> <code>all_graphs_with_comm_performance</code> <p>List of Graph objects representing communication performance over time</p> <p> TYPE: <code>list[Graph]</code> </p> <code>nodes_dict</code> <p>Dictionary mapping NodeGID to Node objects</p> <p> TYPE: <code>dict[NodeGID, Node]</code> </p> <code>demands</code> <p>List of demands</p> <p> TYPE: <code>list[Demand]</code> </p> <code>backup_case</code> <p>Backup case scenario identifier, default is 'no-backup'</p> <p> TYPE: <code>BackupCaseType</code> DEFAULT: <code>'no-backup'</code> </p> <code>hop_limit</code> <p>Hop limit for backup routing, default is 1</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>packet_size</code> <p>Size of the packet for communication [bit], default is 10,000</p> <p> TYPE: <code>int</code> DEFAULT: <code>int(10000.0)</code> </p> <code>space_time_graph</code> <p>SpaceTimeGraph object</p> <p> TYPE: <code>SpaceTimeGraph</code> </p> Source code in <code>src/cosmica/experimental_packet_routing/simulator.py</code> <pre><code>def __init__(\n    self,\n    time: Annotated[\n        npt.NDArray[np.datetime64],\n        Doc(\"Array of datetime64 representing the time points\"),\n    ],\n    all_graphs_with_comm_performance: Annotated[\n        list[Graph],\n        Doc(\"List of Graph objects representing communication performance over time\"),\n    ],\n    nodes_dict: Annotated[dict[NodeGID, Node], Doc(\"Dictionary mapping NodeGID to Node objects\")],\n    demands: Annotated[list[Demand], Doc(\"List of demands\")],\n    *,\n    backup_case: Annotated[\n        BackupCaseType,\n        Doc(\"Backup case scenario identifier, default is 'no-backup'\"),\n    ] = \"no-backup\",\n    hop_limit: Annotated[int, Doc(\"Hop limit for backup routing, default is 1\")] = 1,\n    packet_size: Annotated[int, Doc(\"Size of the packet for communication [bit], default is 10,000\")] = int(1e4),\n    space_time_graph: Annotated[\n        SpaceTimeGraph,\n        Doc(\"SpaceTimeGraph object\"),\n    ],\n) -&gt; None:\n    assert len(time) == len(all_graphs_with_comm_performance)\n\n    self.time: npt.NDArray[np.datetime64] = time\n    self.all_graphs_with_comm_performance: list[Graph] = all_graphs_with_comm_performance\n    self.nodes_dict: dict[NodeGID, Node] = nodes_dict\n    self.demands: list[Demand] = demands\n\n    self.backup_case: BackupCaseType = backup_case\n    self.hop_limit: int = hop_limit\n    self.packet_size: int = packet_size\n\n    self.node_knowledge_known_by_each_node: dict[Node, NodeKnowledge] = {}\n    self.space_time_graph = space_time_graph\n    for node in tqdm(self.nodes_dict.values(), desc=\"Initializing node knowledge\"):\n        self.node_knowledge_known_by_each_node[node] = NodeKnowledge(\n            target_node=node,\n            space_time_graph=copy.deepcopy(self.space_time_graph),\n            forwarding_table_time_list=initialize_forwarding_table_list_from_space_time_graph(\n                space_time_graph=self.space_time_graph,\n                src_node=node,\n                weight=\"weight\",\n                backup_case=self.backup_case,\n                hops_limit=self.hop_limit,\n            ),\n        )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.all_graphs_with_comm_performance","title":"all_graphs_with_comm_performance  <code>instance-attribute</code>","text":"<pre><code>all_graphs_with_comm_performance: list[Graph] = (\n    all_graphs_with_comm_performance\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.backup_case","title":"backup_case  <code>instance-attribute</code>","text":"<pre><code>backup_case: BackupCaseType = backup_case\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.demands","title":"demands  <code>instance-attribute</code>","text":"<pre><code>demands: list[Demand] = demands\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.hop_limit","title":"hop_limit  <code>instance-attribute</code>","text":"<pre><code>hop_limit: int = hop_limit\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.node_knowledge_known_by_each_node","title":"node_knowledge_known_by_each_node  <code>instance-attribute</code>","text":"<pre><code>node_knowledge_known_by_each_node: dict[\n    Node, NodeKnowledge\n] = {}\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.nodes_dict","title":"nodes_dict  <code>instance-attribute</code>","text":"<pre><code>nodes_dict: dict[NodeGID, Node] = nodes_dict\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.packet_size","title":"packet_size  <code>instance-attribute</code>","text":"<pre><code>packet_size: int = packet_size\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.space_time_graph","title":"space_time_graph  <code>instance-attribute</code>","text":"<pre><code>space_time_graph = space_time_graph\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: NDArray[datetime64] = time\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.create_packet_routing_setting","title":"create_packet_routing_setting","text":"<pre><code>create_packet_routing_setting() -&gt; PacketRoutingSetting\n</code></pre> <p>Generate and return a PacketRoutingSetting object.</p> Source code in <code>src/cosmica/experimental_packet_routing/simulator.py</code> <pre><code>def create_packet_routing_setting(self) -&gt; PacketRoutingSetting:\n    \"\"\"Generate and return a PacketRoutingSetting object.\"\"\"\n    return PacketRoutingSetting(\n        time=self.time,\n        nodes_dict=self.nodes_dict,\n        demands=self.demands,\n        backup_case=self.backup_case,\n        hop_limit=self.hop_limit,\n        packet_size=self.packet_size,\n    )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketCommunicationSimulator.run","title":"run","text":"<pre><code>run(\n    *,\n    rng: Generator | None = None,\n    edge_remove_schedule: (\n        list[tuple[datetime64, tuple[Node, Node]]] | None\n    ) = None,\n    failure_detection_time: timedelta64 | None = None,\n    enable_random_routing_when_edge_failure: bool = False,\n    prevent_loop: bool = False,\n    with_lsa: bool = True,\n    lsa_case: LsaCaseType = \"from-source-to-all\"\n) -&gt; PacketRoutingResult\n</code></pre> PARAMETER DESCRIPTION <code>rng</code> <p>NumPy random number generator. If None, use default.</p> <p> TYPE: <code>Generator | None</code> DEFAULT: <code>None</code> </p> <code>edge_remove_schedule</code> <p>List of edge removal schedule</p> <p> TYPE: <code>list[tuple[datetime64, tuple[Node, Node]]] | None</code> DEFAULT: <code>None</code> </p> <code>failure_detection_time</code> <p>Time taken for failure detection</p> <p> TYPE: <code>timedelta64 | None</code> DEFAULT: <code>None</code> </p> <code>enable_random_routing_when_edge_failure</code> <p>Flag to enable random routing when edge failure</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>prevent_loop</code> <p>Flag to prevent loop in routing</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>with_lsa</code> <p>Flag to enable LSA data</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>lsa_case</code> <p>Case scenario identifier for LSA data, default is 'nominal'</p> <p> TYPE: <code>LsaCaseType</code> DEFAULT: <code>'from-source-to-all'</code> </p> Source code in <code>src/cosmica/experimental_packet_routing/simulator.py</code> <pre><code>def run(  # noqa: C901, PLR0912, PLR0915\n    self,\n    *,\n    rng: Annotated[\n        np.random.Generator | None,\n        Doc(\"NumPy random number generator. If None, use default.\"),\n    ] = None,\n    edge_remove_schedule: Annotated[\n        list[tuple[np.datetime64, tuple[Node, Node]]] | None,\n        Doc(\"List of edge removal schedule\"),\n    ] = None,\n    failure_detection_time: Annotated[np.timedelta64 | None, Doc(\"Time taken for failure detection\")] = None,\n    enable_random_routing_when_edge_failure: Annotated[\n        bool,\n        Doc(\"Flag to enable random routing when edge failure\"),\n    ] = False,\n    prevent_loop: Annotated[bool, Doc(\"Flag to prevent loop in routing\")] = False,\n    with_lsa: Annotated[bool, Doc(\"Flag to enable LSA data\")] = True,\n    lsa_case: Annotated[\n        LsaCaseType,\n        Doc(\"Case scenario identifier for LSA data, default is 'nominal'\"),\n    ] = \"from-source-to-all\",\n) -&gt; PacketRoutingResult:\n    ## \u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u306e\u8a2d\u5b9a ========================================\n    rng = rng if rng is not None else np.random.default_rng()\n    edge_remove_schedule = edge_remove_schedule if edge_remove_schedule is not None else []\n    failure_detection_time = (\n        failure_detection_time if failure_detection_time is not None else np.timedelta64(10, \"ms\")\n    )\n\n    ## \u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u60c5\u5831\u3092\u30ed\u30b0\u51fa\u529b ========================================\n    logger.info(f\"Starting packet communication simulation with {len(self.time)} time steps\")\n    logger.info(f\"Number of nodes: {len(self.nodes_dict)}\")\n    logger.info(f\"Number of demands: {len(self.demands)}\")\n    if edge_remove_schedule:\n        logger.info(f\"Edge removal schedule: {len(edge_remove_schedule)} events\")\n        for timing, edge in edge_remove_schedule:\n            logger.info(f\"  - {edge[0].id} &lt;-&gt; {edge[1].id} at {timing}\")\n\n    ## \u30c7\u30fc\u30bf\u683c\u7d0d\u7528\u306e\u30ea\u30b9\u30c8 ========================================\n    all_graphs_after_simulation: list[Graph] = []  # \u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u5f8c\u306e\u30b0\u30e9\u30d5\u5c65\u6b74\n    comm_data_demand_list: list[CommDataDemand] = []\n    comm_data_lsa_list: list[CommDataLSA] = []\n\n    ## \u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u306e\u5b9f\u884c ========================================\n    for time_idx, current_time in tqdm(\n        enumerate(self.time),\n        desc=\"Running packet simulation\",\n        total=len(self.time),\n    ):\n        if time_idx &lt; len(self.time) - 1:\n            time_step: np.timedelta64 = self.time[time_idx + 1] - self.time[time_idx]\n            time_step_s: float = float(time_step / np.timedelta64(1, \"s\"))\n\n        ## \u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u306b\u304a\u3051\u308b\u30b0\u30e9\u30d5\u306e\u751f\u6210 ========================================\n        _graph: Graph = copy.deepcopy(self.all_graphs_with_comm_performance[time_idx])\n\n        # Initialize the edge attributes\n        nx.set_edge_attributes(\n            _graph,\n            {edge: {\"bandwidth_usage_for_demand_data\": 0} for edge in _graph.edges},\n        )\n        nx.set_edge_attributes(\n            _graph,\n            {edge: {\"bandwidth_usage_for_lsa_data\": 0} for edge in _graph.edges},\n        )\n\n        ## Edge\u306e\u5207\u65ad ========================================\n        for edge_remove_timing, edge_to_remove in edge_remove_schedule:\n            if current_time &gt;= edge_remove_timing:\n                logger.info(\n                    f\"Edge {edge_to_remove[0].id} &lt;-&gt; {edge_to_remove[1].id} disconnected at {current_time}\",\n                )\n                remove_edge_safe(_graph, *edge_to_remove)\n                # Edge\u4e0a\u306b\u3042\u308b\u30c7\u30fc\u30bf\u306f\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u3068\u5224\u65ad\n                packet_loss_count_demand = 0\n                for comm_data_demand in comm_data_demand_list:\n                    if isinstance(comm_data_demand.current_position, tuple) and set(\n                        comm_data_demand.current_position,\n                    ) == set(edge_to_remove):\n                        comm_data_demand.packet_loss = True\n                        comm_data_demand.delay = np.inf\n                        packet_loss_count_demand += 1\n                packet_loss_count_lsa = 0\n                for comm_data_lsa in comm_data_lsa_list:\n                    if isinstance(comm_data_lsa.current_position, tuple) and set(\n                        comm_data_lsa.current_position,\n                    ) == set(edge_to_remove):\n                        comm_data_lsa.packet_loss = True\n                        comm_data_lsa.delay = np.inf\n                        packet_loss_count_lsa += 1\n                if packet_loss_count_demand &gt; 0 or packet_loss_count_lsa &gt; 0:\n                    logger.info(\n                        f\"Packet loss due to edge disconnection: \"\n                        f\"{packet_loss_count_demand} demand packets, {packet_loss_count_lsa} LSA packets\",\n                    )\n\n        ## Edge\u306e\u5fa9\u65e7 ========================================\n        # TODO(Takashima): \u672a\u5b9f\u88c5\n\n        ## \u901a\u4fe1\u30c7\u30fc\u30bf\u306e\u751f\u6210 ========================================\n        # LSA\u30c7\u30fc\u30bf\u306e\u751f\u6210\n        if with_lsa:\n            for edge_remove_timing, edge_to_remove in edge_remove_schedule:\n                failure_detection_timing: np.datetime64 = edge_remove_timing + failure_detection_time\n                if (time_idx == 0 and failure_detection_timing &lt;= self.time[time_idx]) or (\n                    time_idx &gt; 0 and self.time[time_idx - 1] &lt; failure_detection_timing &lt;= self.time[time_idx]\n                ):\n                    # \u5207\u65adEdge\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b node \u60c5\u5831\u3092\u66f4\u65b0\n                    for detect_node in edge_to_remove:\n                        # \u81ea\u8eab\u306e\u60c5\u5831\u3092\u66f4\u65b0\n                        self.node_knowledge_known_by_each_node[detect_node].update_node_knowledge_based_on_lsa(\n                            comm_data_lsa=CommDataLSA(\n                                data_size=self.packet_size,\n                                packet_size=self.packet_size,\n                                packet_num=1,\n                                dst_node=detect_node,\n                                next_node=detect_node,\n                                current_position=detect_node,\n                                path=[detect_node],\n                                generated_time=current_time,\n                                time=current_time,\n                                time_from_generated=0.0,\n                                time_remaining_for_current_position=0.0,\n                                failure_position=edge_to_remove,\n                            ),\n                            current_time=current_time,\n                            weight=\"weight\",\n                            backup_case=self.backup_case,\n                            hops_limit=self.hop_limit,\n                        )\n                    # LSA\u30c7\u30fc\u30bf\u306e\u751f\u6210\n                    if lsa_case == \"from-source-to-all\":\n                        #  \u5207\u65adEdge\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b node \u304b\u3089 \u4ed6\u306e\u3059\u3079\u3066\u306e node \u306b\u5bfe\u3057\u3066 LSA \u30c7\u30fc\u30bf\u3092\u751f\u6210\n                        for detect_node in edge_to_remove:\n                            for dst_node in self.nodes_dict.values():\n                                if dst_node == detect_node:\n                                    # dst_node = detect_node \u306e\u5834\u5408\u306f\u30b9\u30ad\u30c3\u30d7\n                                    continue\n                                next_node = calc_next_node_from_node_knowledge(\n                                    node_knowledge=self.node_knowledge_known_by_each_node[detect_node],\n                                    dst_node=dst_node,\n                                    path=[detect_node],\n                                    current_time=current_time,\n                                    enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                                    prevent_loop=prevent_loop,\n                                )\n                                if next_node is None:\n                                    continue\n                                comm_data_lsa = CommDataLSA(\n                                    data_size=self.packet_size,\n                                    packet_size=self.packet_size,\n                                    packet_num=1,\n                                    dst_node=dst_node,\n                                    next_node=next_node,\n                                    current_position=detect_node,\n                                    path=[detect_node],\n                                    generated_time=current_time,\n                                    time=current_time,\n                                    time_from_generated=0.0,\n                                    time_remaining_for_current_position=0.0,\n                                    failure_position=edge_to_remove,\n                                )\n                                comm_data_lsa_list.append(comm_data_lsa)\n                    elif lsa_case == \"adjacent\":\n                        # \u5207\u65adEdge\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b node \u304b\u3089 \u96a3\u63a5 node \u306b\u5bfe\u3057\u3066 LSA \u30c7\u30fc\u30bf\u3092\u751f\u6210\n                        for detect_node in edge_to_remove:\n                            for dst_node in list(_graph.neighbors(detect_node)):\n                                next_node = calc_next_node_from_node_knowledge(\n                                    node_knowledge=self.node_knowledge_known_by_each_node[detect_node],\n                                    dst_node=dst_node,\n                                    path=[detect_node],\n                                    current_time=current_time,\n                                    enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                                    prevent_loop=prevent_loop,\n                                )\n                                if next_node is None:\n                                    continue\n                                comm_data_lsa = CommDataLSA(\n                                    data_size=self.packet_size,\n                                    packet_size=self.packet_size,\n                                    packet_num=1,\n                                    dst_node=dst_node,\n                                    next_node=next_node,\n                                    current_position=detect_node,\n                                    path=[detect_node],\n                                    generated_time=current_time,\n                                    time=current_time,\n                                    time_from_generated=0.0,\n                                    time_remaining_for_current_position=0.0,\n                                    failure_position=edge_to_remove,\n                                )\n                                comm_data_lsa_list.append(comm_data_lsa)\n\n        # Demand\u30c7\u30fc\u30bf\u306e\u751f\u6210\n        # 1\u30d1\u30b1\u30c3\u30c8\u305a\u3064\u6271\u3046\u3068\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u6642\u9593\u304c\u304b\u304b\u308b\u306e\u3067\u3001\u5b9b\u5148\u304c\u540c\u3058 &amp; \u751f\u6210\u6642\u523b\u304c\u540c\u3058\u30d1\u30b1\u30c3\u30c8\u3092comm_data\u3068\u3057\u3066\u307e\u3068\u3081\u3066\u3044\u308b  # noqa: E501\n        for demand in self.demands:\n            if isinstance(demand, ConstantCommunicationDemand) or (\n                isinstance(demand, TemporaryCommunicationDemand) and demand.is_active(current_time)\n            ):\n                if demand.distribution == \"uniform\":\n                    packet_num = int(demand.transmission_rate * time_step_s / self.packet_size)\n                elif demand.distribution == \"poisson\":\n                    packet_num = int(rng.poisson(lam=demand.transmission_rate * time_step_s / self.packet_size))\n\n                next_node = calc_next_node_from_node_knowledge(\n                    node_knowledge=self.node_knowledge_known_by_each_node[self.nodes_dict[demand.source]],\n                    dst_node=self.nodes_dict[demand.destination],\n                    path=[self.nodes_dict[demand.source]],\n                    current_time=current_time,\n                    enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                    prevent_loop=prevent_loop,\n                )\n                if next_node is None:\n                    continue\n                comm_data_demand = CommDataDemand(\n                    demand_id=demand.id,\n                    data_size=packet_num * self.packet_size,\n                    packet_size=self.packet_size,\n                    packet_num=packet_num,\n                    dst_node=self.nodes_dict[demand.destination],\n                    next_node=next_node,\n                    current_position=self.nodes_dict[demand.source],\n                    path=[self.nodes_dict[demand.source]],\n                    generated_time=current_time,\n                    time=current_time,\n                    time_from_generated=0.0,\n                    time_remaining_for_current_position=0.0,\n                )\n                comm_data_demand_list.append(comm_data_demand)\n\n        ## \u901a\u4fe1\u30c7\u30fc\u30bf\u306e\u4f1d\u64ad ========================================\n        # TODO(Takashima): comm_data_lsa_list\u3084comm_data_demand_list\u306b\u3064\u3044\u3066\u3001\u5c4a\u3044\u305f\u30c7\u30fc\u30bf\u3084\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u306e\u30c7\u30fc\u30bf\u3092\u524a\u9664\u3057\u306a\u3044\u5834\u5408\u3001for\u306e\u30eb\u30fc\u30d7\u56de\u6570\u304c\u5897\u5927\u3057\u3066\u3044\u304f\u306e\u3067\u3001\u51e6\u7406\u3092\u691c\u8a0e  # noqa: E501\n\n        # LSA\u30c7\u30fc\u30bf\u306e\u4f1d\u64ad\n        if with_lsa:\n            for comm_data_lsa in comm_data_lsa_list:\n                if comm_data_lsa.packet_loss or comm_data_lsa.reach_dst:\n                    continue\n                if comm_data_lsa.generated_time &gt; current_time + time_step:\n                    continue\n\n                # \u5171\u901a\u51e6\u7406\n                if comm_data_lsa.time &gt; current_time:\n                    comm_data_lsa.time_remaining_for_current_position -= float(\n                        (current_time + time_step - comm_data_lsa.time) / np.timedelta64(1, \"s\"),\n                    )\n                    comm_data_lsa.time = current_time + time_step\n                else:\n                    comm_data_lsa.time_remaining_for_current_position -= time_step_s\n                    comm_data_lsa.time += time_step\n\n                # Node -&gt; Edge\u3001Edge -&gt; Node\u306a\u3069\u5883\u754c\u3092\u8d85\u3048\u308b\u6642\u306e\u30c7\u30fc\u30bf\u306e\u51e6\u7406\n                while comm_data_lsa.time_remaining_for_current_position &lt; 0:\n                    # Node -&gt; Edge\n                    if not isinstance(comm_data_lsa.current_position, tuple):\n                        next_edge: tuple[Node, Node] = (\n                            comm_data_lsa.current_position,\n                            comm_data_lsa.next_node,\n                        )\n\n                        # \u8ee2\u9001\u5148\u306eEdge\u304c\u5b58\u5728\u3057\u306a\u3044\u6642 -&gt; \u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u3068\u5224\u65ad\n                        if not has_edge_bidirectional(_graph, *next_edge):\n                            comm_data_lsa.packet_loss = True\n                            comm_data_lsa.delay = np.inf\n                            break\n\n                        # Congestion\u306e\u8003\u616e -&gt; LSA\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u306f\u3001\u5360\u6709bandwidth\u306e\u8003\u616e\u306f\u884c\u308f\u306a\u3044\n\n                        # \u73fe\u5728\u4f4d\u7f6e\u306e\u66f4\u65b0\n                        comm_data_lsa.current_position = next_edge\n                        edge_data = get_edge_data(_graph, *next_edge)\n                        if edge_data is not None:\n                            edge_data[\"bandwidth_usage_for_lsa_data\"] += comm_data_lsa.data_size / time_step_s\n\n                            # \u73fe\u5728\u4f4d\u7f6e\u306b\u7559\u307e\u308b\u6b8b\u6642\u9593\u306e\u66f4\u65b0\n                            comm_data_lsa.time_remaining_for_current_position += edge_data[\"delay\"]\n                            comm_data_lsa.time_from_generated += edge_data[\"delay\"]\n\n                    # Edge -&gt; Node\n                    elif isinstance(comm_data_lsa.current_position, tuple):\n                        # \u73fe\u5728\u4f4d\u7f6e\u306e\u66f4\u65b0\n                        comm_data_lsa.current_position = comm_data_lsa.next_node\n                        comm_data_lsa.path.append(comm_data_lsa.current_position)\n\n                        # \u73fe\u5728\u306e\u4f4d\u7f6e\u304c\u76ee\u7684\u5730\u306e\u5834\u5408\n                        if comm_data_lsa.current_position == comm_data_lsa.dst_node:\n                            comm_data_lsa.reach_dst = True\n                            comm_data_lsa.delay = comm_data_lsa.time_from_generated\n                            logger.info(\n                                f\"LSA data received at {comm_data_lsa.dst_node.id} \"\n                                f\"(delay: {comm_data_lsa.delay:.6f}s, failure: {comm_data_lsa.failure_position})\",\n                            )\n                            if lsa_case == \"from-source-to-all\":\n                                self.node_knowledge_known_by_each_node[\n                                    comm_data_lsa.current_position\n                                ].update_node_knowledge_based_on_lsa(\n                                    comm_data_lsa,\n                                    current_time,\n                                    weight=\"weight\",\n                                    backup_case=self.backup_case,\n                                    hops_limit=self.hop_limit,\n                                )\n                            elif lsa_case == \"adjacent\":\n                                already_registered = False\n                                for failure_assumed_edge in self.node_knowledge_known_by_each_node[\n                                    comm_data_lsa.current_position\n                                ].failure_assumed_edge_list:\n                                    if isinstance(comm_data_lsa.failure_position, tuple) and (\n                                        set(failure_assumed_edge) == set(comm_data_lsa.failure_position)\n                                    ):\n                                        already_registered = True\n\n                                # \u540c\u3058\u30ea\u30f3\u30af\u5207\u65ad\u304c\u65e2\u306b\u767b\u9332\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044\n                                if already_registered:\n                                    logger.info(\n                                        f\"LSA data received at {comm_data_lsa.dst_node.id} \"\n                                        f\"(already registered failure: {comm_data_lsa.failure_position})\",\n                                    )\n                                # \u767b\u9332\u3055\u308c\u3066\u3044\u306a\u3044\u30ea\u30f3\u30af\u5207\u65ad\u60c5\u5831\u306e\u5834\u5408\u306e\u307f\u3001\u60c5\u5831\u3092\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u3057\u3001\u96a3\u63a5\u30ce\u30fc\u30c9\u306b\u4f1d\u642c\n                                else:\n                                    logger.info(\n                                        f\"LSA data received at {comm_data_lsa.dst_node.id} \"\n                                        f\"(new failure info: {comm_data_lsa.failure_position})\",\n                                    )\n                                    self.node_knowledge_known_by_each_node[\n                                        comm_data_lsa.current_position\n                                    ].update_node_knowledge_based_on_lsa(\n                                        comm_data_lsa,\n                                        current_time,\n                                        weight=\"weight\",\n                                        backup_case=self.backup_case,\n                                        hops_limit=self.hop_limit,\n                                    )\n\n                                    # \u96a3\u63a5node\u306bLSA\u30c7\u30fc\u30bf\u3092\u4f1d\u642c\n                                    graph_known_by_node = self.node_knowledge_known_by_each_node[\n                                        comm_data_lsa.current_position\n                                    ].space_time_graph.get_space_time_graph_at_time(current_time)\n                                    next_destination_list = list(\n                                        graph_known_by_node.neighbors(comm_data_lsa.current_position),\n                                    )\n\n                                    for dst_node in next_destination_list:\n                                        next_node = calc_next_node_from_node_knowledge(\n                                            node_knowledge=self.node_knowledge_known_by_each_node[\n                                                comm_data_lsa.current_position\n                                            ],\n                                            dst_node=dst_node,\n                                            path=[comm_data_lsa.current_position],\n                                            current_time=current_time,\n                                            enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                                            prevent_loop=prevent_loop,\n                                        )\n                                        if next_node is None:\n                                            continue\n\n                                        generated_time = (\n                                            comm_data_lsa.generated_time\n                                            + np.timedelta64(\n                                                int(comm_data_lsa.delay * 1e3),\n                                                \"ms\",\n                                            )  # TODO(): \u73fe\u72b6\u3060\u3068ms\u5358\u4f4d\u3067\u751f\u6210\u3055\u308c\u3001\u3088\u308a\u7d30\u304b\u3044\u5358\u4f4d\u306b\u5bfe\u5fdc\u3067\u304d\u306a\u3044\n                                            + np.timedelta64(\n                                                10,\n                                                \"ms\",\n                                            )  # TODO(): \u51e6\u7406\u9045\u5ef6\u306b\u3064\u3044\u3066\u30d1\u30e9\u30e1\u30fc\u30bf\u3067\u8a2d\u5b9a\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b\n                                        )\n                                        comm_data_lsa_new = CommDataLSA(\n                                            data_size=self.packet_size,\n                                            packet_size=self.packet_size,\n                                            packet_num=1,\n                                            dst_node=dst_node,\n                                            next_node=next_node,\n                                            current_position=comm_data_lsa.current_position,\n                                            path=[comm_data_lsa.current_position],\n                                            generated_time=generated_time,\n                                            time=generated_time,\n                                            time_from_generated=0,\n                                            time_remaining_for_current_position=0,\n                                            failure_position=comm_data_lsa.failure_position,\n                                        )\n                                        comm_data_lsa_list.append(comm_data_lsa_new)\n                            else:\n                                pass\n\n                            break  # \u76ee\u7684\u5730\u306b\u5230\u9054\u3057\u305f\u5834\u5408\u306f\u3001\u6b21\u306e\u901a\u4fe1\u30c7\u30fc\u30bf\u306b\u79fb\u308b\n\n                        # \u73fe\u5728\u306e\u4f4d\u7f6e\u304c\u76ee\u7684\u5730\u3067\u306a\u3044\u5834\u5408\n                        # \u73fe\u5728\u4f4d\u7f6e\u306b\u7559\u307e\u308b\u6b8b\u6642\u9593\u306e\u66f4\u65b0\n                        # TODO(Takashima): \u5b9f\u969b\u306b\u306fBuffer\u306b\u5165\u308c\u305f\u308a\u3059\u308b\u306e\u3067\u305d\u306e\u51e6\u7406\u3092\u691c\u8a0e\n                        comm_data_lsa.time_remaining_for_current_position += _graph.nodes[\n                            comm_data_lsa.current_position\n                        ][\"delay\"]\n                        comm_data_lsa.time_from_generated += _graph.nodes[comm_data_lsa.current_position][\"delay\"]\n\n                        # \u30eb\u30fc\u30c6\u30a3\u30f3\u30b0\u30c6\u30fc\u30d6\u30eb\u306e\u53c2\u7167\n                        next_node = calc_next_node_from_node_knowledge(\n                            node_knowledge=self.node_knowledge_known_by_each_node[comm_data_lsa.current_position],\n                            dst_node=comm_data_lsa.dst_node,\n                            path=comm_data_lsa.path,\n                            current_time=current_time,\n                            enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                            prevent_loop=prevent_loop,\n                        )\n                        if next_node is None:\n                            comm_data_lsa.packet_loss = True\n                            comm_data_lsa.delay = np.inf\n                            break\n                        comm_data_lsa.next_node = next_node\n\n        # Demand\u30c7\u30fc\u30bf\u306e\u4f1d\u64ad\n        # TODO(Takashima): \u73fe\u72b6\u306f\u5148\u306b\u751f\u6210\u3055\u308c\u305f\u30c7\u30fc\u30bf\u306e\u4f1d\u64ad\u304c\u512a\u5148\u3055\u308c\u308b\u306e\u3067, \u512a\u5148\u9806\u4f4d\u306b\u3064\u3044\u3066\u691c\u8a0e\n        for comm_data_demand in comm_data_demand_list:\n            if comm_data_demand.packet_loss or comm_data_demand.reach_dst:\n                continue\n            if comm_data_demand.generated_time &gt; current_time + time_step:\n                continue\n\n            # \u5171\u901a\u51e6\u7406\n            if comm_data_demand.time &gt; current_time:\n                comm_data_demand.time_remaining_for_current_position -= float(\n                    (current_time + time_step - comm_data_demand.time) / np.timedelta64(1, \"s\"),\n                )\n                comm_data_demand.time = current_time + time_step\n            else:\n                comm_data_demand.time_remaining_for_current_position -= time_step_s\n                comm_data_demand.time += time_step\n\n            # Node -&gt; Edge\u3001Edge -&gt; Node\u306a\u3069\u5883\u754c\u3092\u8d85\u3048\u308b\u6642\u306e\u30c7\u30fc\u30bf\u306e\u51e6\u7406\n            while comm_data_demand.time_remaining_for_current_position &lt; 0:\n                # Node -&gt; Edge\n                if not isinstance(comm_data_demand.current_position, tuple):\n                    next_edge = (\n                        comm_data_demand.current_position,\n                        comm_data_demand.next_node,\n                    )\n\n                    # \u8ee2\u9001\u5148\u306eEdge\u304c\u5b58\u5728\u3057\u306a\u3044\u6642 -&gt; \u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u3068\u5224\u65ad\n                    if not has_edge_bidirectional(_graph, *next_edge):\n                        comm_data_demand.packet_loss = True\n                        comm_data_demand.delay = np.inf\n                        break\n\n                    # Congestion\u306e\u8003\u616e\n                    edge_data = get_edge_data(_graph, *next_edge)\n                    if edge_data is None:\n                        comm_data_demand.packet_loss = True\n                        comm_data_demand.delay = np.inf\n                        break\n\n                    if (\n                        edge_data[\"bandwidth_usage_for_demand_data\"] + comm_data_demand.data_size / time_step_s\n                        &gt; edge_data[\"link_capacity\"]\n                    ):\n                        comm_data_demand.packet_loss = True\n                        comm_data_demand.delay = np.inf\n                        break\n\n                    # \u73fe\u5728\u4f4d\u7f6e\u306e\u66f4\u65b0\n                    comm_data_demand.current_position = next_edge\n                    edge_data[\"bandwidth_usage_for_demand_data\"] += comm_data_demand.data_size / time_step_s\n\n                    # \u73fe\u5728\u4f4d\u7f6e\u306b\u7559\u307e\u308b\u6b8b\u6642\u9593\u306e\u66f4\u65b0\n                    comm_data_demand.time_remaining_for_current_position += edge_data[\"delay\"]\n                    comm_data_demand.time_from_generated += edge_data[\"delay\"]\n\n                # Edge -&gt; Node\n                elif isinstance(comm_data_demand.current_position, tuple):\n                    # \u73fe\u5728\u4f4d\u7f6e\u306e\u66f4\u65b0\n                    comm_data_demand.current_position = comm_data_demand.next_node\n                    comm_data_demand.path.append(comm_data_demand.current_position)\n\n                    # \u73fe\u5728\u306e\u4f4d\u7f6e\u304c\u76ee\u7684\u5730\u306e\u5834\u5408\n                    if comm_data_demand.current_position == comm_data_demand.dst_node:\n                        comm_data_demand.reach_dst = True\n                        comm_data_demand.delay = comm_data_demand.time_from_generated\n                        break  # \u76ee\u7684\u5730\u306b\u5230\u9054\u3057\u305f\u5834\u5408\u306f\u3001\u6b21\u306e\u901a\u4fe1\u30c7\u30fc\u30bf\u306b\u79fb\u308b\n\n                    # \u73fe\u5728\u306e\u4f4d\u7f6e\u304c\u76ee\u7684\u5730\u3067\u306a\u3044\u5834\u5408\n                    # \u73fe\u5728\u4f4d\u7f6e\u306b\u7559\u307e\u308b\u6b8b\u6642\u9593\u306e\u66f4\u65b0\n                    # TODO(Takashima): \u5b9f\u969b\u306b\u306fBuffer\u306b\u5165\u308c\u305f\u308a\u3059\u308b\u306e\u3067\u305d\u306e\u51e6\u7406\u3092\u691c\u8a0e\n                    # -&gt; \u624b\u8a08\u7b97\u3067\u306f, forwarding rate \u304c10Gbps\u306e\u5834\u5408 Queuing Delay\u306f10-100\u03bcs\u306b\u306a\u308a\u305d\u3046\u3067\u5c0f\u3055\u3044\n                    comm_data_demand.time_remaining_for_current_position += _graph.nodes[\n                        comm_data_demand.current_position\n                    ][\"delay\"]\n                    comm_data_demand.time_from_generated += _graph.nodes[comm_data_demand.current_position][\"delay\"]\n\n                    # \u30eb\u30fc\u30c6\u30a3\u30f3\u30b0\u30c6\u30fc\u30d6\u30eb\u306e\u53c2\u7167\n                    next_node = calc_next_node_from_node_knowledge(\n                        node_knowledge=self.node_knowledge_known_by_each_node[comm_data_demand.current_position],\n                        dst_node=comm_data_demand.dst_node,\n                        path=comm_data_demand.path,\n                        current_time=current_time,\n                        enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                        prevent_loop=prevent_loop,\n                    )\n                    if next_node is None:\n                        comm_data_demand.packet_loss = True\n                        comm_data_demand.delay = np.inf\n                        break\n                    comm_data_demand.next_node = next_node\n\n        ## Save the graph to the list of graphs after simulation for each time step ================================\n        all_graphs_after_simulation.append(_graph)\n\n    ## Save simulation results ========================================\n    # \u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u7d50\u679c\u306e\u7d71\u8a08\u3092\u30ed\u30b0\u51fa\u529b\n    total_demand_packets = len(comm_data_demand_list)\n    successful_demand_packets = sum(1 for comm in comm_data_demand_list if comm.reach_dst)\n    packet_loss_demand_packets = sum(1 for comm in comm_data_demand_list if comm.packet_loss)\n\n    total_lsa_packets = len(comm_data_lsa_list)\n    successful_lsa_packets = sum(1 for comm in comm_data_lsa_list if comm.reach_dst)\n    packet_loss_lsa_packets = sum(1 for comm in comm_data_lsa_list if comm.packet_loss)\n\n    logger.info(\"Simulation completed\")\n    logger.info(\n        f\"Demand packets - Total: {total_demand_packets}, \"\n        f\"Successful: {successful_demand_packets}, \"\n        f\"Lost: {packet_loss_demand_packets}\",\n    )\n    logger.info(\n        f\"LSA packets - Total: {total_lsa_packets}, \"\n        f\"Successful: {successful_lsa_packets}, \"\n        f\"Lost: {packet_loss_lsa_packets}\",\n    )\n\n    if successful_demand_packets &gt; 0:\n        avg_delay_demand = np.mean([comm.delay for comm in comm_data_demand_list if comm.reach_dst])\n        logger.info(f\"Average delay for successful demand packets: {avg_delay_demand:.6f}s\")\n\n    return PacketRoutingResult(\n        all_graphs_after_simulation=all_graphs_after_simulation,\n        comm_data_demand_list=comm_data_demand_list,\n        comm_data_lsa_list=comm_data_lsa_list,\n        node_knowledge_known_by_each_node=self.node_knowledge_known_by_each_node,\n    )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingResult","title":"PacketRoutingResult  <code>dataclass</code>","text":"<pre><code>PacketRoutingResult(\n    *,\n    all_graphs_after_simulation: list[Graph] = list[\n        Graph\n    ](),\n    node_knowledge_known_by_each_node: dict[\n        Node, NodeKnowledge\n    ] = dict[Node, NodeKnowledge](),\n    comm_data_demand_list: list[CommDataDemand] = list[\n        CommDataDemand\n    ](),\n    comm_data_lsa_list: list[CommDataLSA] = list[\n        CommDataLSA\n    ]()\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingResult.all_graphs_after_simulation","title":"all_graphs_after_simulation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>all_graphs_after_simulation: list[Graph] = field(\n    default_factory=list[Graph]\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingResult.comm_data_demand_list","title":"comm_data_demand_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_data_demand_list: list[CommDataDemand] = field(\n    default_factory=list[CommDataDemand]\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingResult.comm_data_lsa_list","title":"comm_data_lsa_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_data_lsa_list: list[CommDataLSA] = field(\n    default_factory=list[CommDataLSA]\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingResult.node_knowledge_known_by_each_node","title":"node_knowledge_known_by_each_node  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>node_knowledge_known_by_each_node: dict[\n    Node, NodeKnowledge\n] = field(default_factory=dict[Node, NodeKnowledge])\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingResult.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(\n    graphs_path: Path | None = None,\n    node_knowledge_path: Path | None = None,\n    comm_data_demand_path: Path | None = None,\n    comm_data_lsa_path: Path | None = None,\n) -&gt; Self\n</code></pre> <p>\u6307\u5b9a\u3055\u308c\u305f\u30d1\u30b9\u304b\u3089pickle\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f.</p> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    graphs_path: Path | None = None,\n    node_knowledge_path: Path | None = None,\n    comm_data_demand_path: Path | None = None,\n    comm_data_lsa_path: Path | None = None,\n) -&gt; Self:\n    \"\"\"\u6307\u5b9a\u3055\u308c\u305f\u30d1\u30b9\u304b\u3089pickle\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f.\"\"\"\n    all_graphs_after_simulation = []\n    if graphs_path is not None and graphs_path.exists():\n        with graphs_path.open(\"rb\") as f:\n            all_graphs_after_simulation = pickle.load(f)  # noqa: S301\n        logger.info(f\"Loaded all graphs after simulation: {len(all_graphs_after_simulation)}\")\n    else:\n        logger.info(\"No graph data to load.\")\n\n    node_knowledge_known_by_each_node = {}\n    if node_knowledge_path is not None and node_knowledge_path.exists():\n        with node_knowledge_path.open(\"rb\") as f:\n            node_knowledge_known_by_each_node = pickle.load(f)  # noqa: S301\n        logger.info(f\"Loaded network information: {len(node_knowledge_known_by_each_node)}\")\n    else:\n        logger.info(\"No node knowledge data to load.\")\n\n    comm_data_demand_list = []\n    if comm_data_demand_path is not None and comm_data_demand_path.exists():\n        with comm_data_demand_path.open(\"rb\") as f:\n            comm_data_demand_list = pickle.load(f)  # noqa: S301\n        logger.info(f\"Loaded comm data demand: {len(comm_data_demand_list)}\")\n    else:\n        logger.info(\"No comm data demand to load.\")\n\n    comm_data_lsa_list = []\n    if comm_data_lsa_path is not None and comm_data_lsa_path.exists():\n        with comm_data_lsa_path.open(\"rb\") as f:\n            comm_data_lsa_list = pickle.load(f)  # noqa: S301\n        logger.info(f\"Loaded comm data lsa: {len(comm_data_lsa_list)}\")\n    else:\n        logger.info(\"No comm data lsa to load.\")\n\n    return cls(\n        all_graphs_after_simulation=all_graphs_after_simulation,\n        node_knowledge_known_by_each_node=node_knowledge_known_by_each_node,\n        comm_data_demand_list=comm_data_demand_list,\n        comm_data_lsa_list=comm_data_lsa_list,\n    )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingResult.save_all_graphs_after_simulation","title":"save_all_graphs_after_simulation","text":"<pre><code>save_all_graphs_after_simulation(save_path: Path) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>def save_all_graphs_after_simulation(self, save_path: Path) -&gt; None:\n    if self.all_graphs_after_simulation is not None:\n        with save_path.open(\"wb\") as f:\n            pickle.dump(self.all_graphs_after_simulation, f)\n        logger.info(f\"Saved the simulation results of graph to {save_path}\")\n    else:\n        logger.info(\"No graph data to save.\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingResult.save_comm_data_demand_list","title":"save_comm_data_demand_list","text":"<pre><code>save_comm_data_demand_list(save_path: Path) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>def save_comm_data_demand_list(self, save_path: Path) -&gt; None:\n    if self.comm_data_demand_list is not None:\n        with save_path.open(\"wb\") as f:\n            pickle.dump(self.comm_data_demand_list, f)\n        logger.info(f\"Saved the simulation results of comm data demand to {save_path}\")\n    else:\n        logger.info(\"No comm data demand to save.\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingResult.save_comm_data_lsa_list","title":"save_comm_data_lsa_list","text":"<pre><code>save_comm_data_lsa_list(save_path: Path) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>def save_comm_data_lsa_list(self, save_path: Path) -&gt; None:\n    if self.comm_data_lsa_list is not None:\n        with save_path.open(\"wb\") as f:\n            pickle.dump(self.comm_data_lsa_list, f)\n        logger.info(f\"Saved the simulation results of comm data lsa to {save_path}\")\n    else:\n        logger.info(\"No comm data lsa to save.\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingResult.save_node_knowledge_known_by_each_node","title":"save_node_knowledge_known_by_each_node","text":"<pre><code>save_node_knowledge_known_by_each_node(\n    save_path: Path,\n) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>def save_node_knowledge_known_by_each_node(self, save_path: Path) -&gt; None:\n    if self.node_knowledge_known_by_each_node is not None:\n        with save_path.open(\"wb\") as f:\n            pickle.dump(self.node_knowledge_known_by_each_node, f)\n        logger.info(f\"Saved the simulation results of node knowledge to {save_path}\")\n    else:\n        logger.info(\"No node knowledge data to save.\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingSetting","title":"PacketRoutingSetting  <code>dataclass</code>","text":"<pre><code>PacketRoutingSetting(\n    *,\n    time: NDArray[datetime64],\n    nodes_dict: dict[NodeGID, Node],\n    demands: list[Demand],\n    backup_case: BackupCaseType,\n    hop_limit: int,\n    packet_size: int\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingSetting.backup_case","title":"backup_case  <code>instance-attribute</code>","text":"<pre><code>backup_case: BackupCaseType\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingSetting.demands","title":"demands  <code>instance-attribute</code>","text":"<pre><code>demands: list[Demand]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingSetting.hop_limit","title":"hop_limit  <code>instance-attribute</code>","text":"<pre><code>hop_limit: int\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingSetting.nodes_dict","title":"nodes_dict  <code>instance-attribute</code>","text":"<pre><code>nodes_dict: dict[NodeGID, Node]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingSetting.packet_size","title":"packet_size  <code>instance-attribute</code>","text":"<pre><code>packet_size: int\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingSetting.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: NDArray[datetime64]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingSetting.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(load_path: Path) -&gt; PacketRoutingSetting\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>@classmethod\ndef load(cls, load_path: Path) -&gt; PacketRoutingSetting:\n    with load_path.open(\"rb\") as f:\n        return pickle.load(f)  # noqa: S301\n    logger.info(f\"Loaded the packet routing setting from {load_path}\")\n    return None\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.PacketRoutingSetting.save","title":"save","text":"<pre><code>save(save_path: Path) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>def save(self, save_path: Path) -&gt; None:\n    with save_path.open(\"wb\") as f:\n        pickle.dump(self, f)\n    logger.info(f\"Saved the packet routing setting to {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer","title":"RoutingResultVisualizer","text":"<pre><code>RoutingResultVisualizer(\n    simulation_settings: PacketRoutingSetting,\n    packet_routing_result: PacketRoutingResult,\n)\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def __init__(\n    self,\n    simulation_settings: PacketRoutingSetting,\n    packet_routing_result: PacketRoutingResult,\n) -&gt; None:\n    self.simulation_settings: PacketRoutingSetting = simulation_settings\n    self.packet_routing_result: PacketRoutingResult = packet_routing_result\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.packet_routing_result","title":"packet_routing_result  <code>instance-attribute</code>","text":"<pre><code>packet_routing_result: PacketRoutingResult = (\n    packet_routing_result\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.simulation_settings","title":"simulation_settings  <code>instance-attribute</code>","text":"<pre><code>simulation_settings: PacketRoutingSetting = (\n    simulation_settings\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.time","title":"time  <code>cached</code> <code>property</code>","text":"<pre><code>time: NDArray\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.time_from_epoch","title":"time_from_epoch  <code>cached</code> <code>property</code>","text":"<pre><code>time_from_epoch: NDArray\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.time_step_array","title":"time_step_array  <code>cached</code> <code>property</code>","text":"<pre><code>time_step_array: NDArray\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.calculate_average_delay","title":"calculate_average_delay","text":"<pre><code>calculate_average_delay(\n    *,\n    time_from: datetime64 | None = None,\n    time_to: datetime64 | None = None,\n    weighted_data_size: bool = True\n) -&gt; float\n</code></pre> <p>\u5230\u7740\u3057\u305f\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def calculate_average_delay(\n    self,\n    *,\n    time_from: np.datetime64 | None = None,\n    time_to: np.datetime64 | None = None,\n    weighted_data_size: bool = True,\n) -&gt; float:\n    \"\"\"\u5230\u7740\u3057\u305f\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\u3059\u308b.\"\"\"\n    calc_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"delay\": [\n                comm_data_demand.delay for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"data_size\": [\n                comm_data_demand.data_size for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n\n    # \u6642\u9593\u7bc4\u56f2\u3092\u6307\u5b9a\u3057\u3066\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    if time_from is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &gt;= time_from]\n    if time_to is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &lt;= time_to]\n\n    # \u6709\u9650\u306a\u9045\u5ef6\u5024\u306e\u307f\u3092\u9078\u629e\n    finite_delay_ser: Series = calc_df[\"delay\"][np.isfinite(calc_df[\"delay\"])]\n    finite_data_size_ser: pd.Series = calc_df[\"data_size\"][np.isfinite(calc_df[\"delay\"])]\n\n    if weighted_data_size:\n        # \u30c7\u30fc\u30bf\u30b5\u30a4\u30ba\u3067\u91cd\u307f\u4ed8\u3051\u3057\u305f\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\n        average_delay: float = np.average(finite_delay_ser, weights=finite_data_size_ser)\n    else:\n        # \u5358\u7d14\u306a\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\n        average_delay = finite_delay_ser.mean()\n\n    logger.info(f\"Average delay: {average_delay} s\")\n\n    return average_delay\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.calculate_average_increased_delay","title":"calculate_average_increased_delay","text":"<pre><code>calculate_average_increased_delay(\n    time_baseline: datetime64,\n    *,\n    time_from: datetime64 | None = None,\n    time_to: datetime64 | None = None,\n    weighted_data_size: bool = True\n) -&gt; float\n</code></pre> <p>\u5230\u7740\u3057\u305f\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u5e73\u5747\u9045\u5ef6\u6642\u9593\u306e\u3001\u3042\u308b\u6642\u523b\u306e\u9045\u5ef6\u6642\u9593\u306b\u5bfe\u3059\u308b\u5897\u52a0\u91cf\u3092\u8a08\u7b97\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def calculate_average_increased_delay(\n    self,\n    time_baseline: np.datetime64,\n    *,\n    time_from: np.datetime64 | None = None,\n    time_to: np.datetime64 | None = None,\n    weighted_data_size: bool = True,\n) -&gt; float:\n    \"\"\"\u5230\u7740\u3057\u305f\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u5e73\u5747\u9045\u5ef6\u6642\u9593\u306e\u3001\u3042\u308b\u6642\u523b\u306e\u9045\u5ef6\u6642\u9593\u306b\u5bfe\u3059\u308b\u5897\u52a0\u91cf\u3092\u8a08\u7b97\u3059\u308b.\"\"\"\n    calc_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"delay\": [\n                comm_data_demand.delay for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"data_size\": [\n                comm_data_demand.data_size for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n\n    # \u6642\u9593\u7bc4\u56f2\u3092\u6307\u5b9a\u3057\u3066\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    if time_from is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &gt;= time_from]\n    if time_to is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &lt;= time_to]\n\n    # \u6709\u9650\u306a\u9045\u5ef6\u5024\u306e\u307f\u3092\u9078\u629e\n    finite_delay_ser: Series = calc_df[\"delay\"][np.isfinite(calc_df[\"delay\"])]\n    finite_data_size_ser: pd.Series = calc_df[\"data_size\"][np.isfinite(calc_df[\"delay\"])]\n\n    if weighted_data_size:\n        # \u30c7\u30fc\u30bf\u30b5\u30a4\u30ba\u3067\u91cd\u307f\u4ed8\u3051\u3057\u305f\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\n        average_delay: float = np.average(\n            finite_delay_ser,\n            weights=finite_data_size_ser,\n        )\n    else:\n        # \u5358\u7d14\u306a\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\n        average_delay = finite_delay_ser.mean()\n\n    # \u6307\u5b9a\u3057\u305f\u6642\u523b\u306e\u9045\u5ef6\u6642\u9593\u304b\u3089\u306e\u5dee\u5206\u3092\u8a08\u7b97\n    closest_idx = (calc_df[\"generated_time\"] - pd.to_datetime(time_baseline)).abs().idxmin()\n    average_increased_delay = average_delay - pd.to_numeric(\n        calc_df.loc[closest_idx, \"delay\"],\n    )\n\n    logger.info(f\"Average increased delay: {average_increased_delay} s\")\n\n    return average_delay\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.calculate_average_packet_loss_rate","title":"calculate_average_packet_loss_rate","text":"<pre><code>calculate_average_packet_loss_rate(\n    *,\n    time_from: datetime64 | None = None,\n    time_to: datetime64 | None = None,\n    weighted_data_size: bool = True\n) -&gt; float\n</code></pre> <p>\u751f\u6210\u30c7\u30fc\u30bf\u306e\u5e73\u5747\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u7387\u3092\u8a08\u7b97\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def calculate_average_packet_loss_rate(\n    self,\n    *,\n    time_from: np.datetime64 | None = None,\n    time_to: np.datetime64 | None = None,\n    weighted_data_size: bool = True,\n) -&gt; float:\n    \"\"\"\u751f\u6210\u30c7\u30fc\u30bf\u306e\u5e73\u5747\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u7387\u3092\u8a08\u7b97\u3059\u308b.\"\"\"\n    calc_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"reach_dst\": [\n                comm_data_demand.reach_dst for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"data_size\": [\n                comm_data_demand.data_size for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n\n    # \u6642\u9593\u7bc4\u56f2\u3092\u6307\u5b9a\u3057\u3066\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    if time_from is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &gt;= time_from]\n    if time_to is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &lt;= time_to]\n\n    if weighted_data_size:\n        # \u30c7\u30fc\u30bf\u30b5\u30a4\u30ba\u3067\u91cd\u307f\u4ed8\u3051\u3057\u305f\u5e73\u5747\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u7387\u3092\u8a08\u7b97\n        average_packet_reach_rate: float = np.average(calc_df[\"reach_dst\"], weights=calc_df[\"data_size\"])\n    else:\n        average_packet_reach_rate = calc_df[\"reach_dst\"].mean()\n\n    average_packet_loss_rate = 1 - average_packet_reach_rate\n    logger.info(f\"Average packet loss rate: {average_packet_loss_rate}\")\n\n    return average_packet_loss_rate\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.plot_accumulated_arrival_data_size","title":"plot_accumulated_arrival_data_size","text":"<pre><code>plot_accumulated_arrival_data_size(\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False\n) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_accumulated_arrival_data_size(\n    self,\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False,\n    # link_failure_timing=None,\n) -&gt; None:\n    ## Convert comm_data_demand_list into a pandas DataFrame\n    # \u5230\u9054\u3057\u305f\u30c7\u30fc\u30bf, \u3082\u3057\u304f\u306f\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u3057\u305f\u30c7\u30fc\u30bf\u306e\u307f\u30d7\u30ed\u30c3\u30c8\u3059\u308b\n    plot_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"delay\": [\n                comm_data_demand.delay for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"data_size\": [\n                comm_data_demand.data_size for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"reach_dst\": [\n                comm_data_demand.reach_dst for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n    plot_df = plot_df[plot_df[\"reach_dst\"]]\n\n    plot_df[\"arrival_time\"] = plot_df[\"generated_time\"] + pd.to_timedelta(plot_df[\"delay\"], unit=\"s\")\n    plot_df = plot_df.sort_values(\"arrival_time\")\n\n    plot_df[\"accumulated_arrival_data_size\"] = plot_df.groupby(\"reach_dst\")[\"data_size\"].cumsum()\n\n    if use_time_from_epoch:\n        x_data = (plot_df[\"arrival_time\"] - self.time[0]) / np.timedelta64(1, \"s\")\n    else:\n        x_data = plot_df[\"arrival_time\"]\n\n    ## \u30d7\u30ed\u30c3\u30c8\n    fig, ax = plt.subplots(figsize=(10, 6), dpi=dpi)\n\n    ax.plot(\n        x_data,\n        plot_df[\"accumulated_arrival_data_size\"],\n        label=\"Accumulated arrival data size\",\n        color=\"blue\",\n    )\n\n    # Customizing title and labels font size\n    if with_title:\n        ax.set_title(\"Accumulated Arrival Data Size\", fontsize=title_fontsize)\n    ax.set_ylabel(\"Accumulated arrival data size [bit]\", fontsize=label_fontsize)\n    if use_time_from_epoch:\n        ax.set_xlabel(\"Time from Epoch [s]\", fontsize=label_fontsize)\n    else:\n        ax.set_xlabel(\"Time\", fontsize=label_fontsize)\n        # Formatting the x-axis with date and time, and rotating the text\n        ax.xaxis.set_major_formatter(DateFormatter(\"%Y/%m/%d %H:%M:%S\"))\n        plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\")\n\n    # Customizing tick label font size\n    ax.tick_params(axis=\"both\", labelsize=tick_label_fontsize)\n\n    # \u8ef8\u306e\u7bc4\u56f2\u8a2d\u5b9a\n    if use_time_from_epoch:\n        ax.set_xlim(xlim if xlim else (self.time_from_epoch[0], self.time_from_epoch[-1]))\n    else:\n        ax.set_xlim(xlim if xlim else (self.time[0], self.time[-1]))\n    ax.set_ylim(ylim if ylim else (0, None))\n\n    if with_grid:\n        ax.xaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.yaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.grid(which=\"major\", color=\"#CCCCCC\", linestyle=\"--\")\n        ax.grid(which=\"minor\", color=\"#CCCCCC\", linestyle=\":\")\n\n    # \u51e1\u4f8b\u306e\u8a2d\u5b9a\n    ax.legend(fontsize=legend_fontsize, loc=legend_loc)\n\n    # \u4fdd\u5b58\n    fig.savefig(save_path, bbox_inches=\"tight\")\n    logger.info(f\"Saved visualization: {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.plot_arrival_data_rate","title":"plot_arrival_data_rate","text":"<pre><code>plot_arrival_data_rate(\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False\n) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_arrival_data_rate(\n    self,\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False,\n    # link_failure_timing=None,\n) -&gt; None:\n    # --- 1. \u5fc5\u8981\u30c7\u30fc\u30bf\u3092\u6574\u5f62 ---------------------------------------------------\n    plot_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"delay\": [\n                comm_data_demand.delay for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"data_size\": [\n                comm_data_demand.data_size for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"reach_dst\": [\n                comm_data_demand.reach_dst for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n    plot_df = plot_df[plot_df[\"reach_dst\"]]\n    plot_df[\"arrival_time\"] = (plot_df[\"generated_time\"] + pd.to_timedelta(plot_df[\"delay\"], unit=\"s\")).astype(\n        \"datetime64[ms]\",\n    )\n\n    # --- 2. \u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u60c5\u5831 --------------------------------------------------\n    time_index = pd.Series(self.time).astype(\"datetime64[ms]\")\n    dt_seconds = np.asarray(self.time_step_array, dtype=float)\n\n    # --- 3. \u5404 arrival \u3092\u76f4\u524d\u306e time_index \u306b\u5272\u308a\u5f53\u3066 ---------------------------\n    # np.searchsorted \u3067\u633f\u5165\u4f4d\u7f6e\u3092\u53d6\u5f97 \u2192 1 \u3064\u524d\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u304c\u300c\u5c5e\u3059\u308b\u30b9\u30c6\u30c3\u30d7\u300d\n    idx = np.searchsorted(time_index.to_numpy(), plot_df[\"arrival_time\"].to_numpy(), side=\"right\") - 1\n    valid = idx &gt;= 0  # \u8ca0\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306f epoch \u4ee5\u524d\u306a\u306e\u3067\u9664\u5916\n\n    # --- 4. \u30b9\u30c6\u30c3\u30d7\u6bce\u306b\u30d0\u30a4\u30c8\u6570\u3092\u52a0\u7b97 -----------------------------------------\n    bytes_per_step = np.zeros(len(time_index), dtype=float)\n    np.add.at(bytes_per_step, idx[valid], plot_df[\"data_size\"].to_numpy()[valid])\n\n    arrival_rate = bytes_per_step / dt_seconds\n\n    # --- 5. \u53ef\u8996\u5316 -------------------------------------------------------------\n    x_data = (time_index - time_index.iloc[0]).dt.total_seconds() if use_time_from_epoch else time_index\n\n    fig, ax = plt.subplots(figsize=(10, 6), dpi=dpi)\n    ax.plot(x_data, arrival_rate, label=\"Arrival data rate\", lw=1)\n\n    if with_title:\n        ax.set_title(\"Arrival Data Rate\", fontsize=title_fontsize)\n    ax.set_ylabel(\"Arrival data rate [bit/s]\", fontsize=label_fontsize)\n    if use_time_from_epoch:\n        ax.set_xlabel(\"Time from Epoch [s]\", fontsize=label_fontsize)\n    else:\n        ax.set_xlabel(\"Time\", fontsize=label_fontsize)\n        ax.xaxis.set_major_formatter(DateFormatter(\"%Y/%m/%d %H:%M:%S\"))\n        plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\")\n\n    ax.tick_params(axis=\"both\", labelsize=tick_label_fontsize)\n    ax.set_xlim(xlim if xlim else (x_data.iloc[0], x_data.iloc[-1]))\n    ax.set_ylim(ylim if ylim else (0, None))\n\n    if with_grid:\n        ax.xaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.yaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.grid(which=\"major\", linestyle=\"--\", alpha=0.6)\n        ax.grid(which=\"minor\", linestyle=\":\", alpha=0.4)\n\n    ax.legend(fontsize=legend_fontsize, loc=legend_loc)\n    fig.savefig(save_path, bbox_inches=\"tight\")\n    logger.info(f\"Saved visualization: {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.plot_delay","title":"plot_delay","text":"<pre><code>plot_delay(\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False,\n    replace_inf: bool = False\n) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_delay(\n    self,\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False,\n    replace_inf: bool = False,\n    # link_failure_timing=None,\n) -&gt; None:\n    ## Convert comm_data_demand_list into a pandas DataFrame\n    # \u5230\u9054\u3057\u305f\u30c7\u30fc\u30bf, \u3082\u3057\u304f\u306f\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u3057\u305f\u30c7\u30fc\u30bf\u306e\u307f\u30d7\u30ed\u30c3\u30c8\u3059\u308b\n    plot_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"delay\": [\n                comm_data_demand.delay for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n    plot_df = plot_df.sort_values(\"generated_time\")\n\n    if use_time_from_epoch:\n        x_data = (plot_df[\"generated_time\"] - self.time[0]) / np.timedelta64(1, \"s\")\n    else:\n        x_data = plot_df[\"generated_time\"]\n\n    max_delay = plot_df[\"delay\"][plot_df[\"delay\"] != np.inf].max()\n\n    if replace_inf:\n        # np.inf\u3060\u3068\u30d7\u30ed\u30c3\u30c8\u3055\u308c\u306a\u3044\u306e\u3067\u3001\u9069\u5f53\u306a\u5927\u304d\u3044\u5024\u306b\u7f6e\u63db\n        plot_df[\"delay\"] = plot_df[\"delay\"].replace(np.inf, 1e5)\n\n    ## \u30d7\u30ed\u30c3\u30c8\n    fig, ax = plt.subplots(figsize=(10, 6), dpi=dpi)\n\n    ax.plot(x_data, plot_df[\"delay\"], label=\"Delay\", color=\"blue\")\n\n    # Customizing title and labels font size\n    if with_title:\n        ax.set_title(\"Delay\", fontsize=title_fontsize)\n    ax.set_ylabel(\"Average delay time [s]\", fontsize=label_fontsize)\n    if use_time_from_epoch:\n        ax.set_xlabel(\"Time from epoch[s]\", fontsize=label_fontsize)\n    else:\n        ax.set_xlabel(\"Time\", fontsize=label_fontsize)\n        # Formatting the x-axis with date and time, and rotating the text\n        ax.xaxis.set_major_formatter(DateFormatter(\"%Y/%m/%d %H:%M:%S\"))\n        plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\")\n\n    # Customizing tick label font size\n    ax.tick_params(axis=\"both\", labelsize=tick_label_fontsize)\n\n    # \u8ef8\u306e\u7bc4\u56f2\u8a2d\u5b9a\n    if use_time_from_epoch:\n        ax.set_xlim(xlim if xlim else (self.time_from_epoch[0], self.time_from_epoch[-1]))\n    else:\n        ax.set_xlim(xlim if xlim else (self.time[0], self.time[-1]))\n\n    if max_delay == np.inf or np.isnan(max_delay):\n        ax.set_ylim(0, None)\n    else:\n        ax.set_ylim(ylim if ylim else (0, max_delay * 1.1))\n\n    if with_grid:\n        ax.xaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.yaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.grid(which=\"major\", color=\"#CCCCCC\", linestyle=\"--\")\n        ax.grid(which=\"minor\", color=\"#CCCCCC\", linestyle=\":\")\n\n    # \u51e1\u4f8b\u306e\u8a2d\u5b9a\n    ax.legend(fontsize=legend_fontsize, loc=legend_loc)\n\n    # \u4fdd\u5b58\n    fig.savefig(save_path, bbox_inches=\"tight\")\n    logger.info(f\"Saved visualization: {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.plot_graph_animation","title":"plot_graph_animation","text":"<pre><code>plot_graph_animation(\n    time_index_from: int,\n    time_index_to: int,\n    time_index_step: int,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100\n) -&gt; None\n</code></pre> <p>\u6642\u9593\u7d4c\u904e\u306b\u4f34\u3046\u30b0\u30e9\u30d5\u306e\u5909\u5316\u3092\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u3067\u63cf\u753b\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_graph_animation(\n    self,\n    time_index_from: int,\n    time_index_to: int,\n    time_index_step: int,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100,\n) -&gt; None:\n    \"\"\"\u6642\u9593\u7d4c\u904e\u306b\u4f34\u3046\u30b0\u30e9\u30d5\u306e\u5909\u5316\u3092\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u3067\u63cf\u753b\u3059\u308b.\"\"\"\n    # TODO(Takashima): time_index \u3067\u306a\u304f time\u3092\u5f15\u6570\u306b\u53d6\u308c\u308b\u3088\u3046\u306b\u3059\u308b\n    time_index_for_plot = range(time_index_from, time_index_to, time_index_step)\n\n    fig, ax = plt.subplots(figsize=(15, 8))\n\n    def update(frame: int):  # noqa: ANN202\n        ax.clear()\n        time_index = time_index_for_plot[frame]\n\n        edges_with_demand_data = self._get_edges_with_demand_data(time_index) if with_demand_data else set()\n\n        edges_with_lsa_data = self._get_edges_with_lsa_data(time_index) if with_lsa_data else set()\n\n        title = f\"Time: {np.datetime_as_string(self.time[time_index], unit='ms').split('T')[1]}\"\n        ax.set_title(title)\n\n        draw_lat_lon_grid(ax=ax)\n        draw_countries(ax=ax)\n        draw_snapshot(\n            graph=self.packet_routing_result.all_graphs_after_simulation[time_index],\n            dynamics_data=dynamics_data[time_index],\n            ax=ax,\n            with_labels=False,\n            focus_edges_list=[edges_with_demand_data, edges_with_lsa_data],\n            focus_edges_label_list=[\"Demand data\", \"LSA data\"],\n        )\n        ax.legend(loc=\"lower left\")\n\n    ani = FuncAnimation(fig, update, frames=len(time_index_for_plot), interval=100)\n    ani.save(\n        save_path,\n        dpi=dpi,\n    )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.plot_graph_at_certain_time","title":"plot_graph_at_certain_time","text":"<pre><code>plot_graph_at_certain_time(\n    time: datetime64,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100\n) -&gt; None\n</code></pre> <p>\u6307\u5b9a\u3057\u305f\u6642\u9593\u306e\u30b0\u30e9\u30d5\u3092\u63cf\u753b\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_graph_at_certain_time(\n    self,\n    time: np.datetime64,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100,\n) -&gt; None:\n    \"\"\"\u6307\u5b9a\u3057\u305f\u6642\u9593\u306e\u30b0\u30e9\u30d5\u3092\u63cf\u753b\u3059\u308b.\"\"\"\n    time_indices = np.where(self.time == time)[0]\n    if len(time_indices) == 0:\n        msg = f\"Time {time} not found in self.time array.\"\n        raise ValueError(msg)\n    time_index = time_indices[0]\n\n    edges_with_demand_data = self._get_edges_with_demand_data(time_index) if with_demand_data else set()\n\n    edges_with_lsa_data = self._get_edges_with_lsa_data(time_index) if with_lsa_data else set()\n    # routing_table_arrows = get_routing_table_arrows(time_idx)\n\n    fig, ax = plt.subplots(figsize=(15, 8))\n\n    title = f\"Time: {np.datetime_as_string(time, unit='ms').split('T')[1]}\"\n    ax.set_title(title)\n\n    draw_lat_lon_grid(ax=ax)\n    draw_countries(ax=ax)\n    draw_snapshot(\n        graph=self.packet_routing_result.all_graphs_after_simulation[time_index],\n        dynamics_data=dynamics_data[time_index],\n        ax=ax,\n        with_labels=False,\n        focus_edges_list=[edges_with_demand_data, edges_with_lsa_data],\n        focus_edges_label_list=[\"Demand data\", \"LSA data\"],\n    )\n\n    ax.legend(loc=\"lower left\")\n\n    # \u4fdd\u5b58\n    fig.savefig(save_path, bbox_inches=\"tight\", dpi=dpi)\n    logger.info(f\"Saved visualization: {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.RoutingResultVisualizer.plot_graph_over_time","title":"plot_graph_over_time","text":"<pre><code>plot_graph_over_time(\n    time_index_from: int,\n    time_index_to: int,\n    time_index_step: int,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100\n) -&gt; None\n</code></pre> <p>\u6642\u9593\u7d4c\u904e\u306b\u4f34\u3046\u30b0\u30e9\u30d5\u306e\u5909\u5316\u3092\u63cf\u753b\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_graph_over_time(\n    self,\n    time_index_from: int,\n    time_index_to: int,\n    time_index_step: int,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100,\n) -&gt; None:\n    \"\"\"\u6642\u9593\u7d4c\u904e\u306b\u4f34\u3046\u30b0\u30e9\u30d5\u306e\u5909\u5316\u3092\u63cf\u753b\u3059\u308b.\"\"\"\n    # TODO(Takashima): time_index \u3067\u306a\u304f time\u3092\u5f15\u6570\u306b\u53d6\u308c\u308b\u3088\u3046\u306b\u3059\u308b\n    n_fig = (time_index_to - time_index_from) // time_index_step\n    ncols = 3\n    nrows = (n_fig + ncols - 1) // ncols\n\n    fig, axes = plt.subplots(\n        nrows=nrows,\n        ncols=ncols,\n        figsize=(15 * ncols, 8 * nrows),\n    )\n    fig.subplots_adjust(wspace=0.1, hspace=0.1)\n\n    for idx, time_index in enumerate(range(time_index_from, time_index_to, time_index_step)):\n        row, col = divmod(idx, ncols)\n\n        edges_with_demand_data = self._get_edges_with_demand_data(time_index) if with_demand_data else set()\n\n        edges_with_lsa_data = self._get_edges_with_lsa_data(time_index) if with_lsa_data else set()\n\n        title = f\"Time: {np.datetime_as_string(self.time[time_index], unit='ms').split('T')[1]}\"\n        axes[row, col].set_title(title)\n\n        draw_lat_lon_grid(ax=axes[row, col])\n        draw_countries(ax=axes[row, col])\n        draw_snapshot(\n            graph=self.packet_routing_result.all_graphs_after_simulation[time_index],\n            dynamics_data=dynamics_data[time_index],\n            ax=axes[row, col],\n            with_labels=False,\n            focus_edges_list=[edges_with_demand_data, edges_with_lsa_data],\n            focus_edges_label_list=[\"Demand data\", \"LSA data\"],\n        )\n\n    # \u4fdd\u5b58\n    fig.savefig(save_path, bbox_inches=\"tight\", dpi=dpi)\n    logger.info(f\"Saved visualization: {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.SpaceTimeGraph","title":"SpaceTimeGraph  <code>dataclass</code>","text":"<pre><code>SpaceTimeGraph(\n    time_for_snapshots: list[datetime64],\n    graph_for_snapshots: list[Graph],\n)\n</code></pre> <p>Base model for a space time graph.</p> Source code in <code>src/cosmica/experimental_packet_routing/space_time_graph.py</code> <pre><code>def __init__(\n    self,\n    time_for_snapshots: list[np.datetime64],\n    graph_for_snapshots: list[Graph],\n) -&gt; None:\n    self.time_for_snapshots = time_for_snapshots\n    self.graph_for_snapshots = graph_for_snapshots\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.SpaceTimeGraph.graph_for_snapshots","title":"graph_for_snapshots  <code>instance-attribute</code>","text":"<pre><code>graph_for_snapshots: list[Graph] = graph_for_snapshots\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.SpaceTimeGraph.time_for_snapshots","title":"time_for_snapshots  <code>instance-attribute</code>","text":"<pre><code>time_for_snapshots: list[datetime64] = time_for_snapshots\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.SpaceTimeGraph.get_space_time_graph_at_time","title":"get_space_time_graph_at_time","text":"<pre><code>get_space_time_graph_at_time(time: datetime64) -&gt; Graph\n</code></pre> <p>Get the space time graph at the specified time.</p> Source code in <code>src/cosmica/experimental_packet_routing/space_time_graph.py</code> <pre><code>def get_space_time_graph_at_time(self, time: np.datetime64) -&gt; Graph:\n    \"\"\"Get the space time graph at the specified time.\"\"\"\n    closest_snapshot_index: int = max(i for i, _time in enumerate(self.time_for_snapshots) if _time &lt;= time)\n    return self.graph_for_snapshots[closest_snapshot_index]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.SpaceTimeGraph.make_space_time_graph_from_graph","title":"make_space_time_graph_from_graph  <code>classmethod</code>","text":"<pre><code>make_space_time_graph_from_graph(\n    time: NDArray[datetime64],\n    graphs: list[Graph],\n    *,\n    check_interval_time: timedelta64 | None = None\n) -&gt; Self\n</code></pre> <p>Update time and graph lists if the graph shape changes.</p> Source code in <code>src/cosmica/experimental_packet_routing/space_time_graph.py</code> <pre><code>@classmethod\ndef make_space_time_graph_from_graph(  # noqa: C901, PLR0912\n    cls,\n    time: npt.NDArray[np.datetime64],\n    graphs: list[Graph],\n    *,\n    check_interval_time: np.timedelta64 | None = None,\n) -&gt; Self:\n    \"\"\"Update time and graph lists if the graph shape changes.\"\"\"\n    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    if check_interval_time is None:\n        # Old behaviour (unchanged) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        time_for_snapshots: list[np.datetime64] = [time[0]]\n        graph_for_snapshots: list[Graph] = [copy.deepcopy(graphs[0])]\n        for _time, _graph in tqdm(zip(time[1:], graphs[1:], strict=False), total=len(time) - 1):\n            if not nx.is_isomorphic(_graph, graph_for_snapshots[-1]):\n                time_for_snapshots.append(_time)\n                graph_for_snapshots.append(copy.deepcopy(_graph))\n        return cls(\n            time_for_snapshots=time_for_snapshots,\n            graph_for_snapshots=graph_for_snapshots,\n        )\n\n    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    # New t-second aggregation logic\n    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    start, stop = time[0], time[-1]\n    # Interval boundaries: t, 2t, \u2026, \u2264 stop\n    boundaries: npt.NDArray[np.datetime64] = np.arange(\n        start,\n        stop + check_interval_time,\n        check_interval_time,\n    )\n\n    time_for_snapshots = []\n    graph_for_snapshots = []\n\n    for boundary in tqdm(boundaries, total=len(boundaries)):\n        # \u2500\u2500 indices for past / future windows \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        past_mask = (time &gt; boundary - check_interval_time) &amp; (time &lt;= boundary)\n        future_mask = (time &gt; boundary) &amp; (time &lt; boundary + check_interval_time)\n\n        if not past_mask.any() and not future_mask.any():\n            continue  # no information\n\n        past_idx = np.where(past_mask)[0]\n        future_idx = np.where(future_mask)[0]\n\n        # \u2500\u2500 graph defined exactly at (or just before) boundary \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        idx_boundary = max(0, int(np.searchsorted(time, boundary, side=\"right\")) - 1)\n        graph_at_boundary = copy.deepcopy(graphs[idx_boundary])\n\n        # \u2500\u2500 \u2460 add every edge that ever appeared in the past window \u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        edges_past = set().union(*(graphs[i].edges() for i in past_idx)) if past_idx.size else set()\n        for u, v in edges_past:\n            if not has_edge_bidirectional(graph_at_boundary, u, v):\n                last_i = max(i for i in past_idx if has_edge_bidirectional(graphs[i], u, v))\n                # Find the actual edge direction that exists\n                if graphs[last_i].has_edge(u, v):\n                    graph_at_boundary.add_edge(u, v, **graphs[last_i].edges[u, v])\n                else:\n                    graph_at_boundary.add_edge(u, v, **graphs[last_i].edges[v, u])\n\n        # \u2500\u2500 \u2461 remove edges that will disappear in the coming interval \u2500\u2500\u2500\u2500\n        if future_idx.size:\n            stable_future = set.intersection(*(set(graphs[i].edges()) for i in future_idx))\n            for u, v in list(graph_at_boundary.edges()):\n                if (u, v) not in stable_future and (v, u) not in stable_future:\n                    remove_edge_safe(graph_at_boundary, u, v)\n\n        # \u2500\u2500 \u2462 overwrite attributes with those at the mid-point (n+\u00bd)t \u2500\u2500\u2500\n        half = check_interval_time // np.int64(2)\n        mid_time = boundary + half  # (n+\u00bd)t\n        mid_i = min(len(time) - 1, int(np.searchsorted(time, mid_time, side=\"left\")))\n        graph_at_midpoint = graphs[mid_i]\n\n        for node, data in graph_at_midpoint.nodes(data=True):\n            if graph_at_boundary.has_node(node):\n                graph_at_boundary.nodes[node].update(data)\n\n        for u, v, data in graph_at_midpoint.edges(data=True):\n            if has_edge_bidirectional(graph_at_boundary, u, v):\n                # Update the edge that actually exists in the boundary graph\n                if graph_at_boundary.has_edge(u, v):\n                    graph_at_boundary.edges[u, v].update(data)\n                else:\n                    graph_at_boundary.edges[v, u].update(data)\n\n        # \u2500\u2500 \u2463 recompute weights (edge delay + max node delay) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        for u, v, d in graph_at_boundary.edges(data=True):\n            edge_delay = d.get(\"delay\", 0)\n            node_delay = max(graph_at_boundary.nodes[u].get(\"delay\", 0), graph_at_boundary.nodes[v].get(\"delay\", 0))\n            graph_at_boundary.edges[u, v][\"weight\"] = edge_delay + node_delay\n        for n in graph_at_boundary.nodes:\n            graph_at_boundary.nodes[n][\"weight\"] = graph_at_boundary.nodes[n].get(\"delay\", 0)\n\n        # \u2500\u2500 \u2464 store snapshot, skipping duplicates \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        if (not graph_for_snapshots) or (not nx.is_isomorphic(graph_at_boundary, graph_for_snapshots[-1])):\n            time_for_snapshots.append(boundary)\n            graph_for_snapshots.append(graph_at_boundary)\n\n    return cls(\n        time_for_snapshots=time_for_snapshots,\n        graph_for_snapshots=graph_for_snapshots,\n    )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/#cosmica.experimental_packet_routing.SpaceTimeGraph.update_space_time_graph_for_failure_edge","title":"update_space_time_graph_for_failure_edge","text":"<pre><code>update_space_time_graph_for_failure_edge(\n    failure_edge: tuple[Node, Node], update_time: datetime64\n) -&gt; Self\n</code></pre> <p>Update the space time graph for the failure edge.</p> Source code in <code>src/cosmica/experimental_packet_routing/space_time_graph.py</code> <pre><code>def update_space_time_graph_for_failure_edge(\n    self,\n    failure_edge: tuple[Node, Node],\n    update_time: np.datetime64,\n) -&gt; Self:\n    \"\"\"Update the space time graph for the failure edge.\"\"\"\n    # Find the index of the closest time snapshot before or at graph_update_time\n    closest_snapshot_index: int = max(i for i, time in enumerate(self.time_for_snapshots) if time &lt;= update_time)\n\n    # If the closest snapshot is the last snapshot, add a new snapshot\n    if closest_snapshot_index == len(self.time_for_snapshots) - 1:\n        graph: Graph = copy.deepcopy(self.graph_for_snapshots[closest_snapshot_index])\n        if remove_edge_safe(graph, *failure_edge):\n            self.time_for_snapshots.append(update_time)\n            self.graph_for_snapshots.append(graph)\n\n    else:\n        for i in range(closest_snapshot_index + 1, len(self.time_for_snapshots)):\n            graph = self.graph_for_snapshots[i]\n            remove_edge_safe(graph, *failure_edge)\n\n        graph = copy.deepcopy(self.graph_for_snapshots[closest_snapshot_index])\n        if remove_edge_safe(graph, *failure_edge):\n            self.time_for_snapshots.insert(closest_snapshot_index + 1, update_time)\n            self.graph_for_snapshots.insert(closest_snapshot_index + 1, graph)\n\n    return self\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/calc_forwarding_table_from_graph/","title":"calc_forwarding_table_from_graph","text":""},{"location":"reference/cosmica/experimental_packet_routing/calc_forwarding_table_from_graph/#cosmica.experimental_packet_routing.calc_forwarding_table_from_graph","title":"cosmica.experimental_packet_routing.calc_forwarding_table_from_graph","text":""},{"location":"reference/cosmica/experimental_packet_routing/calc_forwarding_table_from_graph/#cosmica.experimental_packet_routing.calc_forwarding_table_from_graph.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/calc_forwarding_table_from_graph/#cosmica.experimental_packet_routing.calc_forwarding_table_from_graph.initialize_forwarding_table_list_from_space_time_graph","title":"initialize_forwarding_table_list_from_space_time_graph","text":"<pre><code>initialize_forwarding_table_list_from_space_time_graph(\n    space_time_graph: SpaceTimeGraph,\n    src_node: Node,\n    *,\n    weight: str | Callable = \"weight\",\n    backup_case: BackupCaseType = \"no-backup\",\n    hops_limit: int = 1\n) -&gt; ForwardingTableTimeList\n</code></pre> <p>Calculate the forwarding table for a given space-time graph.</p> Source code in <code>src/cosmica/experimental_packet_routing/calc_forwarding_table_from_graph.py</code> <pre><code>def initialize_forwarding_table_list_from_space_time_graph(  # noqa: C901\n    space_time_graph: SpaceTimeGraph,\n    src_node: Node,\n    *,\n    weight: str | Callable = \"weight\",\n    backup_case: BackupCaseType = \"no-backup\",\n    hops_limit: int = 1,\n) -&gt; ForwardingTableTimeList:\n    \"\"\"Calculate the forwarding table for a given space-time graph.\"\"\"\n    if backup_case == \"no-backup\":\n        nominal_forwarding_table_for_snapshots: list[ForwardingTable] = []\n\n        for graph in space_time_graph.graph_for_snapshots:\n            nominal_forwarding_table: ForwardingTable = _calc_nominal_forwarding_table_from_graph_optimized(\n                graph,\n                src_node,\n                weight=weight,\n            )\n            nominal_forwarding_table_for_snapshots.append(nominal_forwarding_table)\n        return ForwardingTableTimeList(\n            time_for_snapshots=space_time_graph.time_for_snapshots,\n            nominal_forwarding_table_for_snapshots=nominal_forwarding_table_for_snapshots,\n        )\n\n    elif backup_case == \"backup-feeder-links\":\n        nominal_forwarding_table_for_snapshots = []\n        backup_forwarding_tables_for_snapshots: list[dict[frozenset[frozenset[Node]], ForwardingTable]] = []\n\n        for graph in space_time_graph.graph_for_snapshots:\n            nominal_forwarding_table = _calc_nominal_forwarding_table_from_graph_optimized(\n                graph,\n                src_node,\n                weight=weight,\n            )\n            nominal_forwarding_table_for_snapshots.append(nominal_forwarding_table)\n            failure_assumed_edges: set = _find_edges_from_all_gateway_to_constellation(graph)\n            backup_forwarding_tables: dict[frozenset[frozenset[Node]], ForwardingTable] = (\n                _calc_multi_failure_backup_forwarding_table_from_graph(\n                    graph,\n                    src_node,\n                    failure_assumed_edges,\n                    combination_range=1,\n                    weight=weight,\n                )\n            )\n            backup_forwarding_tables_for_snapshots.append(backup_forwarding_tables)\n        return ForwardingTableTimeList(\n            time_for_snapshots=space_time_graph.time_for_snapshots,\n            nominal_forwarding_table_for_snapshots=nominal_forwarding_table_for_snapshots,\n            backup_forwarding_tables_for_snapshots=backup_forwarding_tables_for_snapshots,\n        )\n    elif backup_case == \"backup-n-hops-links\":\n        nominal_forwarding_table_for_snapshots = []\n        backup_forwarding_tables_for_snapshots = []\n\n        for graph in space_time_graph.graph_for_snapshots:\n            nominal_forwarding_table = _calc_nominal_forwarding_table_from_graph_optimized(\n                graph,\n                src_node,\n                weight=weight,\n            )\n            nominal_forwarding_table_for_snapshots.append(nominal_forwarding_table)\n            failure_assumed_edges = _find_edges_within_hops_from_source(\n                graph,\n                src_node,\n                hops_limit=hops_limit,\n            )\n            backup_forwarding_tables = _calc_multi_failure_backup_forwarding_table_from_graph(\n                graph,\n                src_node,\n                failure_assumed_edges,\n                combination_range=1,\n                weight=weight,\n            )\n            backup_forwarding_tables_for_snapshots.append(backup_forwarding_tables)\n        return ForwardingTableTimeList(\n            time_for_snapshots=space_time_graph.time_for_snapshots,\n            nominal_forwarding_table_for_snapshots=nominal_forwarding_table_for_snapshots,\n            backup_forwarding_tables_for_snapshots=backup_forwarding_tables_for_snapshots,\n        )\n    elif backup_case == \"backup-n-hops-links-and-feeder-links\":\n        nominal_forwarding_table_for_snapshots = []\n        backup_forwarding_tables_for_snapshots = []\n\n        for graph in space_time_graph.graph_for_snapshots:\n            nominal_forwarding_table = _calc_nominal_forwarding_table_from_graph_optimized(\n                graph,\n                src_node,\n                weight=weight,\n            )\n            nominal_forwarding_table_for_snapshots.append(nominal_forwarding_table)\n            failure_assumed_edges = _find_edges_within_hops_from_source(\n                graph,\n                src_node,\n                hops_limit=hops_limit,\n            ) | _find_edges_from_all_gateway_to_constellation(graph)\n            backup_forwarding_tables = _calc_multi_failure_backup_forwarding_table_from_graph(\n                graph,\n                src_node,\n                failure_assumed_edges,\n                combination_range=1,\n                weight=weight,\n            )\n            backup_forwarding_tables_for_snapshots.append(backup_forwarding_tables)\n        return ForwardingTableTimeList(\n            time_for_snapshots=space_time_graph.time_for_snapshots,\n            nominal_forwarding_table_for_snapshots=nominal_forwarding_table_for_snapshots,\n            backup_forwarding_tables_for_snapshots=backup_forwarding_tables_for_snapshots,\n        )\n    elif backup_case == \"dual-backup-n-hops-links-and-feeder-links\":\n        nominal_forwarding_table_for_snapshots = []\n        backup_forwarding_tables_for_snapshots = []\n\n        for graph in space_time_graph.graph_for_snapshots:\n            nominal_forwarding_table = _calc_nominal_forwarding_table_from_graph_optimized(\n                graph,\n                src_node,\n                weight=weight,\n            )\n            nominal_forwarding_table_for_snapshots.append(nominal_forwarding_table)\n            failure_assumed_edges = _find_edges_within_hops_from_source(\n                graph,\n                src_node,\n                hops_limit=hops_limit,\n            ) | _find_edges_from_all_gateway_to_constellation(graph)\n\n            backup_forwarding_tables = _calc_multi_failure_backup_forwarding_table_from_graph(\n                graph,\n                src_node,\n                failure_assumed_edges,\n                combination_range=2,\n                weight=weight,\n            )\n\n            # single backup\u3068dual backup\u3092\u7d71\u5408\n            backup_forwarding_tables_for_snapshots.append(backup_forwarding_tables)\n        return ForwardingTableTimeList(\n            time_for_snapshots=space_time_graph.time_for_snapshots,\n            nominal_forwarding_table_for_snapshots=nominal_forwarding_table_for_snapshots,\n            backup_forwarding_tables_for_snapshots=backup_forwarding_tables_for_snapshots,\n        )\n    # TODO(Takashima): \u5fc5\u8981\u306b\u5fdc\u3058\u3066\u4ed6\u306e\u30b1\u30fc\u30b9\u3092\u8ffd\u52a0\n    else:\n        logger.warning(f\"Backup case '{backup_case}' not recognized. Returning None.\")\n        return None\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/case_definitions/","title":"case_definitions","text":""},{"location":"reference/cosmica/experimental_packet_routing/case_definitions/#cosmica.experimental_packet_routing.case_definitions","title":"cosmica.experimental_packet_routing.case_definitions","text":""},{"location":"reference/cosmica/experimental_packet_routing/case_definitions/#cosmica.experimental_packet_routing.case_definitions.BackupCaseType","title":"BackupCaseType  <code>module-attribute</code>","text":"<pre><code>BackupCaseType = Literal[\n    \"no-backup\",\n    \"backup-feeder-links\",\n    \"backup-n-hops-links\",\n    \"backup-n-hops-links-and-feeder-links\",\n    \"dual-backup-n-hops-links-and-feeder-links\",\n]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/","title":"comm_data","text":""},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data","title":"cosmica.experimental_packet_routing.comm_data","text":""},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['CommData', 'CommDataDemand', 'CommDataLSA']\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData","title":"CommData  <code>dataclass</code>","text":"<pre><code>CommData(\n    *,\n    data_size: int,\n    packet_size: int = 10000,\n    packet_num: int,\n    dst_node: Node,\n    next_node: Node,\n    current_position: Node | tuple[Node, Node],\n    path: list[Node],\n    generated_time: datetime64,\n    time: datetime64,\n    time_from_generated: float,\n    time_remaining_for_current_position: float,\n    delay: float = nan,\n    reach_dst: bool = False,\n    packet_loss: bool = False\n)\n</code></pre> <p>Base model for a communication data.</p>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.current_position","title":"current_position  <code>instance-attribute</code>","text":"<pre><code>current_position: Node | tuple[Node, Node]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.data_size","title":"data_size  <code>instance-attribute</code>","text":"<pre><code>data_size: int\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.delay","title":"delay  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delay: float = nan\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.dst_node","title":"dst_node  <code>instance-attribute</code>","text":"<pre><code>dst_node: Node\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.generated_time","title":"generated_time  <code>instance-attribute</code>","text":"<pre><code>generated_time: datetime64\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.next_node","title":"next_node  <code>instance-attribute</code>","text":"<pre><code>next_node: Node\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.packet_loss","title":"packet_loss  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>packet_loss: bool = False\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.packet_num","title":"packet_num  <code>instance-attribute</code>","text":"<pre><code>packet_num: int\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.packet_size","title":"packet_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>packet_size: int = 10000\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: list[Node]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.reach_dst","title":"reach_dst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reach_dst: bool = False\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: datetime64\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.time_from_generated","title":"time_from_generated  <code>instance-attribute</code>","text":"<pre><code>time_from_generated: float\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommData.time_remaining_for_current_position","title":"time_remaining_for_current_position  <code>instance-attribute</code>","text":"<pre><code>time_remaining_for_current_position: float\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand","title":"CommDataDemand  <code>dataclass</code>","text":"<pre><code>CommDataDemand(\n    *,\n    data_size: int,\n    packet_size: int = 10000,\n    packet_num: int,\n    dst_node: Node,\n    next_node: Node,\n    current_position: Node | tuple[Node, Node],\n    path: list[Node],\n    generated_time: datetime64,\n    time: datetime64,\n    time_from_generated: float,\n    time_remaining_for_current_position: float,\n    delay: float = nan,\n    reach_dst: bool = False,\n    packet_loss: bool = False,\n    demand_id: Hashable\n)\n</code></pre> <p>               Bases: <code>CommData</code></p> <p>Model for a communication data for demand.</p>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.current_position","title":"current_position  <code>instance-attribute</code>","text":"<pre><code>current_position: Node | tuple[Node, Node]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.data_size","title":"data_size  <code>instance-attribute</code>","text":"<pre><code>data_size: int\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.delay","title":"delay  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delay: float = nan\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.demand_id","title":"demand_id  <code>instance-attribute</code>","text":"<pre><code>demand_id: Hashable\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.dst_node","title":"dst_node  <code>instance-attribute</code>","text":"<pre><code>dst_node: Node\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.generated_time","title":"generated_time  <code>instance-attribute</code>","text":"<pre><code>generated_time: datetime64\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.next_node","title":"next_node  <code>instance-attribute</code>","text":"<pre><code>next_node: Node\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.packet_loss","title":"packet_loss  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>packet_loss: bool = False\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.packet_num","title":"packet_num  <code>instance-attribute</code>","text":"<pre><code>packet_num: int\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.packet_size","title":"packet_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>packet_size: int = 10000\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: list[Node]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.reach_dst","title":"reach_dst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reach_dst: bool = False\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: datetime64\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.time_from_generated","title":"time_from_generated  <code>instance-attribute</code>","text":"<pre><code>time_from_generated: float\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataDemand.time_remaining_for_current_position","title":"time_remaining_for_current_position  <code>instance-attribute</code>","text":"<pre><code>time_remaining_for_current_position: float\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA","title":"CommDataLSA  <code>dataclass</code>","text":"<pre><code>CommDataLSA(\n    *,\n    data_size: int,\n    packet_size: int = 10000,\n    packet_num: int,\n    dst_node: Node,\n    next_node: Node,\n    current_position: Node | tuple[Node, Node],\n    path: list[Node],\n    generated_time: datetime64,\n    time: datetime64,\n    time_from_generated: float,\n    time_remaining_for_current_position: float,\n    delay: float = nan,\n    reach_dst: bool = False,\n    packet_loss: bool = False,\n    failure_position: Node | tuple[Node, Node]\n)\n</code></pre> <p>               Bases: <code>CommData</code></p> <p>Model for a communication data for LSA.</p>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.current_position","title":"current_position  <code>instance-attribute</code>","text":"<pre><code>current_position: Node | tuple[Node, Node]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.data_size","title":"data_size  <code>instance-attribute</code>","text":"<pre><code>data_size: int\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.delay","title":"delay  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delay: float = nan\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.dst_node","title":"dst_node  <code>instance-attribute</code>","text":"<pre><code>dst_node: Node\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.failure_position","title":"failure_position  <code>instance-attribute</code>","text":"<pre><code>failure_position: Node | tuple[Node, Node]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.generated_time","title":"generated_time  <code>instance-attribute</code>","text":"<pre><code>generated_time: datetime64\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.next_node","title":"next_node  <code>instance-attribute</code>","text":"<pre><code>next_node: Node\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.packet_loss","title":"packet_loss  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>packet_loss: bool = False\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.packet_num","title":"packet_num  <code>instance-attribute</code>","text":"<pre><code>packet_num: int\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.packet_size","title":"packet_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>packet_size: int = 10000\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: list[Node]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.reach_dst","title":"reach_dst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reach_dst: bool = False\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: datetime64\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.time_from_generated","title":"time_from_generated  <code>instance-attribute</code>","text":"<pre><code>time_from_generated: float\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/comm_data/#cosmica.experimental_packet_routing.comm_data.CommDataLSA.time_remaining_for_current_position","title":"time_remaining_for_current_position  <code>instance-attribute</code>","text":"<pre><code>time_remaining_for_current_position: float\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/","title":"dtos","text":""},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos","title":"cosmica.experimental_packet_routing.dtos","text":""},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['PacketRoutingResult', 'PacketRoutingSetting']\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger: Logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingResult","title":"PacketRoutingResult  <code>dataclass</code>","text":"<pre><code>PacketRoutingResult(\n    *,\n    all_graphs_after_simulation: list[Graph] = list[\n        Graph\n    ](),\n    node_knowledge_known_by_each_node: dict[\n        Node, NodeKnowledge\n    ] = dict[Node, NodeKnowledge](),\n    comm_data_demand_list: list[CommDataDemand] = list[\n        CommDataDemand\n    ](),\n    comm_data_lsa_list: list[CommDataLSA] = list[\n        CommDataLSA\n    ]()\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingResult.all_graphs_after_simulation","title":"all_graphs_after_simulation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>all_graphs_after_simulation: list[Graph] = field(\n    default_factory=list[Graph]\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingResult.comm_data_demand_list","title":"comm_data_demand_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_data_demand_list: list[CommDataDemand] = field(\n    default_factory=list[CommDataDemand]\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingResult.comm_data_lsa_list","title":"comm_data_lsa_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_data_lsa_list: list[CommDataLSA] = field(\n    default_factory=list[CommDataLSA]\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingResult.node_knowledge_known_by_each_node","title":"node_knowledge_known_by_each_node  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>node_knowledge_known_by_each_node: dict[\n    Node, NodeKnowledge\n] = field(default_factory=dict[Node, NodeKnowledge])\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingResult.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(\n    graphs_path: Path | None = None,\n    node_knowledge_path: Path | None = None,\n    comm_data_demand_path: Path | None = None,\n    comm_data_lsa_path: Path | None = None,\n) -&gt; Self\n</code></pre> <p>\u6307\u5b9a\u3055\u308c\u305f\u30d1\u30b9\u304b\u3089pickle\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f.</p> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    graphs_path: Path | None = None,\n    node_knowledge_path: Path | None = None,\n    comm_data_demand_path: Path | None = None,\n    comm_data_lsa_path: Path | None = None,\n) -&gt; Self:\n    \"\"\"\u6307\u5b9a\u3055\u308c\u305f\u30d1\u30b9\u304b\u3089pickle\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f.\"\"\"\n    all_graphs_after_simulation = []\n    if graphs_path is not None and graphs_path.exists():\n        with graphs_path.open(\"rb\") as f:\n            all_graphs_after_simulation = pickle.load(f)  # noqa: S301\n        logger.info(f\"Loaded all graphs after simulation: {len(all_graphs_after_simulation)}\")\n    else:\n        logger.info(\"No graph data to load.\")\n\n    node_knowledge_known_by_each_node = {}\n    if node_knowledge_path is not None and node_knowledge_path.exists():\n        with node_knowledge_path.open(\"rb\") as f:\n            node_knowledge_known_by_each_node = pickle.load(f)  # noqa: S301\n        logger.info(f\"Loaded network information: {len(node_knowledge_known_by_each_node)}\")\n    else:\n        logger.info(\"No node knowledge data to load.\")\n\n    comm_data_demand_list = []\n    if comm_data_demand_path is not None and comm_data_demand_path.exists():\n        with comm_data_demand_path.open(\"rb\") as f:\n            comm_data_demand_list = pickle.load(f)  # noqa: S301\n        logger.info(f\"Loaded comm data demand: {len(comm_data_demand_list)}\")\n    else:\n        logger.info(\"No comm data demand to load.\")\n\n    comm_data_lsa_list = []\n    if comm_data_lsa_path is not None and comm_data_lsa_path.exists():\n        with comm_data_lsa_path.open(\"rb\") as f:\n            comm_data_lsa_list = pickle.load(f)  # noqa: S301\n        logger.info(f\"Loaded comm data lsa: {len(comm_data_lsa_list)}\")\n    else:\n        logger.info(\"No comm data lsa to load.\")\n\n    return cls(\n        all_graphs_after_simulation=all_graphs_after_simulation,\n        node_knowledge_known_by_each_node=node_knowledge_known_by_each_node,\n        comm_data_demand_list=comm_data_demand_list,\n        comm_data_lsa_list=comm_data_lsa_list,\n    )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingResult.save_all_graphs_after_simulation","title":"save_all_graphs_after_simulation","text":"<pre><code>save_all_graphs_after_simulation(save_path: Path) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>def save_all_graphs_after_simulation(self, save_path: Path) -&gt; None:\n    if self.all_graphs_after_simulation is not None:\n        with save_path.open(\"wb\") as f:\n            pickle.dump(self.all_graphs_after_simulation, f)\n        logger.info(f\"Saved the simulation results of graph to {save_path}\")\n    else:\n        logger.info(\"No graph data to save.\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingResult.save_comm_data_demand_list","title":"save_comm_data_demand_list","text":"<pre><code>save_comm_data_demand_list(save_path: Path) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>def save_comm_data_demand_list(self, save_path: Path) -&gt; None:\n    if self.comm_data_demand_list is not None:\n        with save_path.open(\"wb\") as f:\n            pickle.dump(self.comm_data_demand_list, f)\n        logger.info(f\"Saved the simulation results of comm data demand to {save_path}\")\n    else:\n        logger.info(\"No comm data demand to save.\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingResult.save_comm_data_lsa_list","title":"save_comm_data_lsa_list","text":"<pre><code>save_comm_data_lsa_list(save_path: Path) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>def save_comm_data_lsa_list(self, save_path: Path) -&gt; None:\n    if self.comm_data_lsa_list is not None:\n        with save_path.open(\"wb\") as f:\n            pickle.dump(self.comm_data_lsa_list, f)\n        logger.info(f\"Saved the simulation results of comm data lsa to {save_path}\")\n    else:\n        logger.info(\"No comm data lsa to save.\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingResult.save_node_knowledge_known_by_each_node","title":"save_node_knowledge_known_by_each_node","text":"<pre><code>save_node_knowledge_known_by_each_node(\n    save_path: Path,\n) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>def save_node_knowledge_known_by_each_node(self, save_path: Path) -&gt; None:\n    if self.node_knowledge_known_by_each_node is not None:\n        with save_path.open(\"wb\") as f:\n            pickle.dump(self.node_knowledge_known_by_each_node, f)\n        logger.info(f\"Saved the simulation results of node knowledge to {save_path}\")\n    else:\n        logger.info(\"No node knowledge data to save.\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingSetting","title":"PacketRoutingSetting  <code>dataclass</code>","text":"<pre><code>PacketRoutingSetting(\n    *,\n    time: NDArray[datetime64],\n    nodes_dict: dict[NodeGID, Node],\n    demands: list[Demand],\n    backup_case: BackupCaseType,\n    hop_limit: int,\n    packet_size: int\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingSetting.backup_case","title":"backup_case  <code>instance-attribute</code>","text":"<pre><code>backup_case: BackupCaseType\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingSetting.demands","title":"demands  <code>instance-attribute</code>","text":"<pre><code>demands: list[Demand]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingSetting.hop_limit","title":"hop_limit  <code>instance-attribute</code>","text":"<pre><code>hop_limit: int\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingSetting.nodes_dict","title":"nodes_dict  <code>instance-attribute</code>","text":"<pre><code>nodes_dict: dict[NodeGID, Node]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingSetting.packet_size","title":"packet_size  <code>instance-attribute</code>","text":"<pre><code>packet_size: int\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingSetting.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: NDArray[datetime64]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingSetting.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(load_path: Path) -&gt; PacketRoutingSetting\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>@classmethod\ndef load(cls, load_path: Path) -&gt; PacketRoutingSetting:\n    with load_path.open(\"rb\") as f:\n        return pickle.load(f)  # noqa: S301\n    logger.info(f\"Loaded the packet routing setting from {load_path}\")\n    return None\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/dtos/#cosmica.experimental_packet_routing.dtos.PacketRoutingSetting.save","title":"save","text":"<pre><code>save(save_path: Path) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/dtos.py</code> <pre><code>def save(self, save_path: Path) -&gt; None:\n    with save_path.open(\"wb\") as f:\n        pickle.dump(self, f)\n    logger.info(f\"Saved the packet routing setting to {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/","title":"forwarding_table","text":""},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table","title":"cosmica.experimental_packet_routing.forwarding_table","text":""},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ForwardingTable', 'ForwardingTableInformation']\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table.ForwardingTable","title":"ForwardingTable  <code>dataclass</code>","text":"<pre><code>ForwardingTable(\n    *,\n    entries: dict[Node, ForwardingTableInformation] = dict()\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table.ForwardingTable.entries","title":"entries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entries: dict[Node, ForwardingTableInformation] = field(\n    default_factory=dict\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table.ForwardingTable.find_entry","title":"find_entry","text":"<pre><code>find_entry(\n    destination: Node,\n) -&gt; ForwardingTableInformation | None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/forwarding_table.py</code> <pre><code>def find_entry(\n    self,\n    destination: Node,\n) -&gt; ForwardingTableInformation | None:\n    return self.entries.get(destination, None)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table.ForwardingTable.remove_entry","title":"remove_entry","text":"<pre><code>remove_entry(destination: Node) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/forwarding_table.py</code> <pre><code>def remove_entry(\n    self,\n    destination: Node,\n) -&gt; None:\n    if destination in self.entries:\n        del self.entries[destination]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table.ForwardingTable.update_entry","title":"update_entry","text":"<pre><code>update_entry(\n    destination: Node, next_node: Node, cost: float = 0.0\n) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/forwarding_table.py</code> <pre><code>def update_entry(\n    self,\n    destination: Node,\n    next_node: Node,\n    cost: float = 0.0,\n) -&gt; None:\n    if destination in self.entries:\n        entry: ForwardingTableInformation = self.entries[destination]\n        entry.next_node = next_node\n        entry.cost = cost\n    else:\n        self.entries[destination] = ForwardingTableInformation(\n            destination=destination,\n            next_node=next_node,\n            cost=cost,\n        )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table.ForwardingTableInformation","title":"ForwardingTableInformation  <code>dataclass</code>","text":"<pre><code>ForwardingTableInformation(\n    *, destination: Node, next_node: Node, cost: float = 0.0\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table.ForwardingTableInformation.cost","title":"cost  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cost: float = 0.0\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table.ForwardingTableInformation.destination","title":"destination  <code>instance-attribute</code>","text":"<pre><code>destination: Node\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table/#cosmica.experimental_packet_routing.forwarding_table.ForwardingTableInformation.next_node","title":"next_node  <code>instance-attribute</code>","text":"<pre><code>next_node: Node\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table_time_list/","title":"forwarding_table_time_list","text":""},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table_time_list/#cosmica.experimental_packet_routing.forwarding_table_time_list","title":"cosmica.experimental_packet_routing.forwarding_table_time_list","text":""},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table_time_list/#cosmica.experimental_packet_routing.forwarding_table_time_list.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ForwardingTableTimeList']\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table_time_list/#cosmica.experimental_packet_routing.forwarding_table_time_list.ForwardingTableTimeList","title":"ForwardingTableTimeList  <code>dataclass</code>","text":"<pre><code>ForwardingTableTimeList(\n    *,\n    time_for_snapshots: list[datetime64],\n    nominal_forwarding_table_for_snapshots: list[\n        ForwardingTable\n    ],\n    backup_forwarding_tables_for_snapshots: list[\n        dict[frozenset[frozenset[Node]], ForwardingTable]\n    ] = list()\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table_time_list/#cosmica.experimental_packet_routing.forwarding_table_time_list.ForwardingTableTimeList.backup_forwarding_tables_for_snapshots","title":"backup_forwarding_tables_for_snapshots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>backup_forwarding_tables_for_snapshots: list[\n    dict[frozenset[frozenset[Node]], ForwardingTable]\n] = field(default_factory=list)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table_time_list/#cosmica.experimental_packet_routing.forwarding_table_time_list.ForwardingTableTimeList.nominal_forwarding_table_for_snapshots","title":"nominal_forwarding_table_for_snapshots  <code>instance-attribute</code>","text":"<pre><code>nominal_forwarding_table_for_snapshots: list[\n    ForwardingTable\n]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/forwarding_table_time_list/#cosmica.experimental_packet_routing.forwarding_table_time_list.ForwardingTableTimeList.time_for_snapshots","title":"time_for_snapshots  <code>instance-attribute</code>","text":"<pre><code>time_for_snapshots: list[datetime64]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/lsa_case_definition/","title":"lsa_case_definition","text":""},{"location":"reference/cosmica/experimental_packet_routing/lsa_case_definition/#cosmica.experimental_packet_routing.lsa_case_definition","title":"cosmica.experimental_packet_routing.lsa_case_definition","text":""},{"location":"reference/cosmica/experimental_packet_routing/lsa_case_definition/#cosmica.experimental_packet_routing.lsa_case_definition.LsaCaseType","title":"LsaCaseType  <code>module-attribute</code>","text":"<pre><code>LsaCaseType = Literal['from-source-to-all', 'adjacent']\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/","title":"node_knowledge","text":""},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge","title":"cosmica.experimental_packet_routing.node_knowledge","text":""},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['NodeKnowledge']\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge.NodeKnowledge","title":"NodeKnowledge  <code>dataclass</code>","text":"<pre><code>NodeKnowledge(\n    *,\n    target_node: Node,\n    space_time_graph: SpaceTimeGraph,\n    forwarding_table_time_list: ForwardingTableTimeList,\n    failure_assumed_edge_list: list[\n        tuple[Node, Node]\n    ] = list(),\n    routing_recalculation_period: list[\n        list[datetime64]\n    ] = list(),\n    receive_lsa_time_list: list[datetime64] | None = None,\n    routing_recalculation_interval: timedelta64 = (\n        lambda: timedelta64(2, \"s\")\n    )()\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge.NodeKnowledge.failure_assumed_edge_list","title":"failure_assumed_edge_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>failure_assumed_edge_list: list[tuple[Node, Node]] = field(\n    default_factory=list\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge.NodeKnowledge.forwarding_table_time_list","title":"forwarding_table_time_list  <code>instance-attribute</code>","text":"<pre><code>forwarding_table_time_list: ForwardingTableTimeList\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge.NodeKnowledge.receive_lsa_time_list","title":"receive_lsa_time_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>receive_lsa_time_list: list[datetime64] | None = None\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge.NodeKnowledge.routing_recalculation_interval","title":"routing_recalculation_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_recalculation_interval: timedelta64 = field(\n    default_factory=lambda: timedelta64(2, \"s\")\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge.NodeKnowledge.routing_recalculation_period","title":"routing_recalculation_period  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_recalculation_period: list[list[datetime64]] = (\n    field(default_factory=list)\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge.NodeKnowledge.space_time_graph","title":"space_time_graph  <code>instance-attribute</code>","text":"<pre><code>space_time_graph: SpaceTimeGraph\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge.NodeKnowledge.target_node","title":"target_node  <code>instance-attribute</code>","text":"<pre><code>target_node: Node\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/node_knowledge/#cosmica.experimental_packet_routing.node_knowledge.NodeKnowledge.update_node_knowledge_based_on_lsa","title":"update_node_knowledge_based_on_lsa","text":"<pre><code>update_node_knowledge_based_on_lsa(\n    comm_data_lsa: CommDataLSA,\n    current_time: datetime64,\n    weight: str | Callable = \"weight\",\n    *,\n    backup_case: BackupCaseType = \"no-backup\",\n    hops_limit: int = 1\n) -&gt; None\n</code></pre> <p>Receive LSA and edit the network information.</p> Source code in <code>src/cosmica/experimental_packet_routing/node_knowledge.py</code> <pre><code>def update_node_knowledge_based_on_lsa(\n    self,\n    comm_data_lsa: CommDataLSA,\n    current_time: np.datetime64,\n    weight: str | Callable = \"weight\",\n    *,\n    backup_case: BackupCaseType = \"no-backup\",\n    hops_limit: int = 1,\n) -&gt; None:\n    \"\"\"Receive LSA and edit the network information.\"\"\"\n    if isinstance(comm_data_lsa.failure_position, tuple):\n        # Edit the failure assumed edge\n        self.failure_assumed_edge_list.append(comm_data_lsa.failure_position)\n\n        # Edit the routing recalculation period\n        # TODO(Takashima): routing_recalculation_period\u306b\u3064\u3044\u3066Node\u5185\u306e\u51e6\u7406\u8ca0\u8377\u306e\u5f71\u97ff\u3092\u8003\u616e\u3059\u308b\n        self.routing_recalculation_period.append(\n            [current_time, current_time + self.routing_recalculation_interval],\n        )\n\n        # TODO(Takashima): \u6301\u3063\u3066\u3044\u308bSpaceTimeGraph\u3084ForwardingTableTimeList\u81ea\u4f53\u304c\u5909\u66f4\u3055\u308c\u308b\u306e\u3067, \u8907\u88fd\u3059\u308b\u304b\u3069\u3046\u304b\u691c\u8a0e  # noqa: E501\n        # \u65b0\u3057\u3044 SpaceTimeGraph \u306e\u4f5c\u6210\n        self.space_time_graph.update_space_time_graph_for_failure_edge(\n            comm_data_lsa.failure_position,\n            current_time + self.routing_recalculation_interval,\n        )\n        # \u65b0\u3057\u3044 ForwardingTableTimeList \u306e\u4f5c\u6210\n        # TODO(takashima): \u65b0\u3057\u3044 SpaceTimeGraph \u304c\u4f5c\u6210\u3055\u308c\u308b\u305f\u3073\u306b ForwardingTableTimeList \u3092\u4f5c\u6210\u3059\u308b\u306e\u306f\u52b9\u7387\u304c\u60aa\u3044\u306e\u3067, \u4fee\u6b63\u304c\u5fc5\u8981  # noqa: E501\n        # TODO(Takashima): case\u3084hops_limit\u306b\u3064\u3044\u3066\u53c2\u7167\u3059\u308b\u306e\u306f\u30b3\u30fc\u30c9\u304c\u3084\u3084\u3053\u3057\u304f\u306a\u308b\u306e\u3067, \u3069\u3053\u304b\u3067\u8a2d\u5b9a\u3059\u308b\u3088\u3046\u306b\u3059\u308b  # noqa: E501\n        self.forwarding_table_time_list = initialize_forwarding_table_list_from_space_time_graph(\n            self.space_time_graph,\n            self.target_node,\n            weight=weight,\n            backup_case=backup_case,\n            hops_limit=hops_limit,\n        )\n        return\n\n    else:\n        # TODO(Takashima): failure_position \u304c Node \u306e\u5834\u5408\u306e\u51e6\u7406\u3092\u691c\u8a0e\n        return\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/","title":"routing_result_visualizer","text":""},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer","title":"cosmica.experimental_packet_routing.routing_result_visualizer","text":""},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer","title":"RoutingResultVisualizer","text":"<pre><code>RoutingResultVisualizer(\n    simulation_settings: PacketRoutingSetting,\n    packet_routing_result: PacketRoutingResult,\n)\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def __init__(\n    self,\n    simulation_settings: PacketRoutingSetting,\n    packet_routing_result: PacketRoutingResult,\n) -&gt; None:\n    self.simulation_settings: PacketRoutingSetting = simulation_settings\n    self.packet_routing_result: PacketRoutingResult = packet_routing_result\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.packet_routing_result","title":"packet_routing_result  <code>instance-attribute</code>","text":"<pre><code>packet_routing_result: PacketRoutingResult = (\n    packet_routing_result\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.simulation_settings","title":"simulation_settings  <code>instance-attribute</code>","text":"<pre><code>simulation_settings: PacketRoutingSetting = (\n    simulation_settings\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.time","title":"time  <code>cached</code> <code>property</code>","text":"<pre><code>time: NDArray\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.time_from_epoch","title":"time_from_epoch  <code>cached</code> <code>property</code>","text":"<pre><code>time_from_epoch: NDArray\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.time_step_array","title":"time_step_array  <code>cached</code> <code>property</code>","text":"<pre><code>time_step_array: NDArray\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.calculate_average_delay","title":"calculate_average_delay","text":"<pre><code>calculate_average_delay(\n    *,\n    time_from: datetime64 | None = None,\n    time_to: datetime64 | None = None,\n    weighted_data_size: bool = True\n) -&gt; float\n</code></pre> <p>\u5230\u7740\u3057\u305f\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def calculate_average_delay(\n    self,\n    *,\n    time_from: np.datetime64 | None = None,\n    time_to: np.datetime64 | None = None,\n    weighted_data_size: bool = True,\n) -&gt; float:\n    \"\"\"\u5230\u7740\u3057\u305f\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\u3059\u308b.\"\"\"\n    calc_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"delay\": [\n                comm_data_demand.delay for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"data_size\": [\n                comm_data_demand.data_size for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n\n    # \u6642\u9593\u7bc4\u56f2\u3092\u6307\u5b9a\u3057\u3066\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    if time_from is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &gt;= time_from]\n    if time_to is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &lt;= time_to]\n\n    # \u6709\u9650\u306a\u9045\u5ef6\u5024\u306e\u307f\u3092\u9078\u629e\n    finite_delay_ser: Series = calc_df[\"delay\"][np.isfinite(calc_df[\"delay\"])]\n    finite_data_size_ser: pd.Series = calc_df[\"data_size\"][np.isfinite(calc_df[\"delay\"])]\n\n    if weighted_data_size:\n        # \u30c7\u30fc\u30bf\u30b5\u30a4\u30ba\u3067\u91cd\u307f\u4ed8\u3051\u3057\u305f\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\n        average_delay: float = np.average(finite_delay_ser, weights=finite_data_size_ser)\n    else:\n        # \u5358\u7d14\u306a\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\n        average_delay = finite_delay_ser.mean()\n\n    logger.info(f\"Average delay: {average_delay} s\")\n\n    return average_delay\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.calculate_average_increased_delay","title":"calculate_average_increased_delay","text":"<pre><code>calculate_average_increased_delay(\n    time_baseline: datetime64,\n    *,\n    time_from: datetime64 | None = None,\n    time_to: datetime64 | None = None,\n    weighted_data_size: bool = True\n) -&gt; float\n</code></pre> <p>\u5230\u7740\u3057\u305f\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u5e73\u5747\u9045\u5ef6\u6642\u9593\u306e\u3001\u3042\u308b\u6642\u523b\u306e\u9045\u5ef6\u6642\u9593\u306b\u5bfe\u3059\u308b\u5897\u52a0\u91cf\u3092\u8a08\u7b97\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def calculate_average_increased_delay(\n    self,\n    time_baseline: np.datetime64,\n    *,\n    time_from: np.datetime64 | None = None,\n    time_to: np.datetime64 | None = None,\n    weighted_data_size: bool = True,\n) -&gt; float:\n    \"\"\"\u5230\u7740\u3057\u305f\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u5e73\u5747\u9045\u5ef6\u6642\u9593\u306e\u3001\u3042\u308b\u6642\u523b\u306e\u9045\u5ef6\u6642\u9593\u306b\u5bfe\u3059\u308b\u5897\u52a0\u91cf\u3092\u8a08\u7b97\u3059\u308b.\"\"\"\n    calc_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"delay\": [\n                comm_data_demand.delay for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"data_size\": [\n                comm_data_demand.data_size for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n\n    # \u6642\u9593\u7bc4\u56f2\u3092\u6307\u5b9a\u3057\u3066\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    if time_from is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &gt;= time_from]\n    if time_to is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &lt;= time_to]\n\n    # \u6709\u9650\u306a\u9045\u5ef6\u5024\u306e\u307f\u3092\u9078\u629e\n    finite_delay_ser: Series = calc_df[\"delay\"][np.isfinite(calc_df[\"delay\"])]\n    finite_data_size_ser: pd.Series = calc_df[\"data_size\"][np.isfinite(calc_df[\"delay\"])]\n\n    if weighted_data_size:\n        # \u30c7\u30fc\u30bf\u30b5\u30a4\u30ba\u3067\u91cd\u307f\u4ed8\u3051\u3057\u305f\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\n        average_delay: float = np.average(\n            finite_delay_ser,\n            weights=finite_data_size_ser,\n        )\n    else:\n        # \u5358\u7d14\u306a\u5e73\u5747\u9045\u5ef6\u6642\u9593\u3092\u8a08\u7b97\n        average_delay = finite_delay_ser.mean()\n\n    # \u6307\u5b9a\u3057\u305f\u6642\u523b\u306e\u9045\u5ef6\u6642\u9593\u304b\u3089\u306e\u5dee\u5206\u3092\u8a08\u7b97\n    closest_idx = (calc_df[\"generated_time\"] - pd.to_datetime(time_baseline)).abs().idxmin()\n    average_increased_delay = average_delay - pd.to_numeric(\n        calc_df.loc[closest_idx, \"delay\"],\n    )\n\n    logger.info(f\"Average increased delay: {average_increased_delay} s\")\n\n    return average_delay\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.calculate_average_packet_loss_rate","title":"calculate_average_packet_loss_rate","text":"<pre><code>calculate_average_packet_loss_rate(\n    *,\n    time_from: datetime64 | None = None,\n    time_to: datetime64 | None = None,\n    weighted_data_size: bool = True\n) -&gt; float\n</code></pre> <p>\u751f\u6210\u30c7\u30fc\u30bf\u306e\u5e73\u5747\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u7387\u3092\u8a08\u7b97\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def calculate_average_packet_loss_rate(\n    self,\n    *,\n    time_from: np.datetime64 | None = None,\n    time_to: np.datetime64 | None = None,\n    weighted_data_size: bool = True,\n) -&gt; float:\n    \"\"\"\u751f\u6210\u30c7\u30fc\u30bf\u306e\u5e73\u5747\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u7387\u3092\u8a08\u7b97\u3059\u308b.\"\"\"\n    calc_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"reach_dst\": [\n                comm_data_demand.reach_dst for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"data_size\": [\n                comm_data_demand.data_size for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n\n    # \u6642\u9593\u7bc4\u56f2\u3092\u6307\u5b9a\u3057\u3066\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    if time_from is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &gt;= time_from]\n    if time_to is not None:\n        calc_df = calc_df[calc_df[\"generated_time\"] &lt;= time_to]\n\n    if weighted_data_size:\n        # \u30c7\u30fc\u30bf\u30b5\u30a4\u30ba\u3067\u91cd\u307f\u4ed8\u3051\u3057\u305f\u5e73\u5747\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u7387\u3092\u8a08\u7b97\n        average_packet_reach_rate: float = np.average(calc_df[\"reach_dst\"], weights=calc_df[\"data_size\"])\n    else:\n        average_packet_reach_rate = calc_df[\"reach_dst\"].mean()\n\n    average_packet_loss_rate = 1 - average_packet_reach_rate\n    logger.info(f\"Average packet loss rate: {average_packet_loss_rate}\")\n\n    return average_packet_loss_rate\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.plot_accumulated_arrival_data_size","title":"plot_accumulated_arrival_data_size","text":"<pre><code>plot_accumulated_arrival_data_size(\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False\n) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_accumulated_arrival_data_size(\n    self,\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False,\n    # link_failure_timing=None,\n) -&gt; None:\n    ## Convert comm_data_demand_list into a pandas DataFrame\n    # \u5230\u9054\u3057\u305f\u30c7\u30fc\u30bf, \u3082\u3057\u304f\u306f\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u3057\u305f\u30c7\u30fc\u30bf\u306e\u307f\u30d7\u30ed\u30c3\u30c8\u3059\u308b\n    plot_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"delay\": [\n                comm_data_demand.delay for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"data_size\": [\n                comm_data_demand.data_size for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"reach_dst\": [\n                comm_data_demand.reach_dst for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n    plot_df = plot_df[plot_df[\"reach_dst\"]]\n\n    plot_df[\"arrival_time\"] = plot_df[\"generated_time\"] + pd.to_timedelta(plot_df[\"delay\"], unit=\"s\")\n    plot_df = plot_df.sort_values(\"arrival_time\")\n\n    plot_df[\"accumulated_arrival_data_size\"] = plot_df.groupby(\"reach_dst\")[\"data_size\"].cumsum()\n\n    if use_time_from_epoch:\n        x_data = (plot_df[\"arrival_time\"] - self.time[0]) / np.timedelta64(1, \"s\")\n    else:\n        x_data = plot_df[\"arrival_time\"]\n\n    ## \u30d7\u30ed\u30c3\u30c8\n    fig, ax = plt.subplots(figsize=(10, 6), dpi=dpi)\n\n    ax.plot(\n        x_data,\n        plot_df[\"accumulated_arrival_data_size\"],\n        label=\"Accumulated arrival data size\",\n        color=\"blue\",\n    )\n\n    # Customizing title and labels font size\n    if with_title:\n        ax.set_title(\"Accumulated Arrival Data Size\", fontsize=title_fontsize)\n    ax.set_ylabel(\"Accumulated arrival data size [bit]\", fontsize=label_fontsize)\n    if use_time_from_epoch:\n        ax.set_xlabel(\"Time from Epoch [s]\", fontsize=label_fontsize)\n    else:\n        ax.set_xlabel(\"Time\", fontsize=label_fontsize)\n        # Formatting the x-axis with date and time, and rotating the text\n        ax.xaxis.set_major_formatter(DateFormatter(\"%Y/%m/%d %H:%M:%S\"))\n        plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\")\n\n    # Customizing tick label font size\n    ax.tick_params(axis=\"both\", labelsize=tick_label_fontsize)\n\n    # \u8ef8\u306e\u7bc4\u56f2\u8a2d\u5b9a\n    if use_time_from_epoch:\n        ax.set_xlim(xlim if xlim else (self.time_from_epoch[0], self.time_from_epoch[-1]))\n    else:\n        ax.set_xlim(xlim if xlim else (self.time[0], self.time[-1]))\n    ax.set_ylim(ylim if ylim else (0, None))\n\n    if with_grid:\n        ax.xaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.yaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.grid(which=\"major\", color=\"#CCCCCC\", linestyle=\"--\")\n        ax.grid(which=\"minor\", color=\"#CCCCCC\", linestyle=\":\")\n\n    # \u51e1\u4f8b\u306e\u8a2d\u5b9a\n    ax.legend(fontsize=legend_fontsize, loc=legend_loc)\n\n    # \u4fdd\u5b58\n    fig.savefig(save_path, bbox_inches=\"tight\")\n    logger.info(f\"Saved visualization: {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.plot_arrival_data_rate","title":"plot_arrival_data_rate","text":"<pre><code>plot_arrival_data_rate(\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False\n) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_arrival_data_rate(\n    self,\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False,\n    # link_failure_timing=None,\n) -&gt; None:\n    # --- 1. \u5fc5\u8981\u30c7\u30fc\u30bf\u3092\u6574\u5f62 ---------------------------------------------------\n    plot_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"delay\": [\n                comm_data_demand.delay for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"data_size\": [\n                comm_data_demand.data_size for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"reach_dst\": [\n                comm_data_demand.reach_dst for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n    plot_df = plot_df[plot_df[\"reach_dst\"]]\n    plot_df[\"arrival_time\"] = (plot_df[\"generated_time\"] + pd.to_timedelta(plot_df[\"delay\"], unit=\"s\")).astype(\n        \"datetime64[ms]\",\n    )\n\n    # --- 2. \u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u60c5\u5831 --------------------------------------------------\n    time_index = pd.Series(self.time).astype(\"datetime64[ms]\")\n    dt_seconds = np.asarray(self.time_step_array, dtype=float)\n\n    # --- 3. \u5404 arrival \u3092\u76f4\u524d\u306e time_index \u306b\u5272\u308a\u5f53\u3066 ---------------------------\n    # np.searchsorted \u3067\u633f\u5165\u4f4d\u7f6e\u3092\u53d6\u5f97 \u2192 1 \u3064\u524d\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u304c\u300c\u5c5e\u3059\u308b\u30b9\u30c6\u30c3\u30d7\u300d\n    idx = np.searchsorted(time_index.to_numpy(), plot_df[\"arrival_time\"].to_numpy(), side=\"right\") - 1\n    valid = idx &gt;= 0  # \u8ca0\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306f epoch \u4ee5\u524d\u306a\u306e\u3067\u9664\u5916\n\n    # --- 4. \u30b9\u30c6\u30c3\u30d7\u6bce\u306b\u30d0\u30a4\u30c8\u6570\u3092\u52a0\u7b97 -----------------------------------------\n    bytes_per_step = np.zeros(len(time_index), dtype=float)\n    np.add.at(bytes_per_step, idx[valid], plot_df[\"data_size\"].to_numpy()[valid])\n\n    arrival_rate = bytes_per_step / dt_seconds\n\n    # --- 5. \u53ef\u8996\u5316 -------------------------------------------------------------\n    x_data = (time_index - time_index.iloc[0]).dt.total_seconds() if use_time_from_epoch else time_index\n\n    fig, ax = plt.subplots(figsize=(10, 6), dpi=dpi)\n    ax.plot(x_data, arrival_rate, label=\"Arrival data rate\", lw=1)\n\n    if with_title:\n        ax.set_title(\"Arrival Data Rate\", fontsize=title_fontsize)\n    ax.set_ylabel(\"Arrival data rate [bit/s]\", fontsize=label_fontsize)\n    if use_time_from_epoch:\n        ax.set_xlabel(\"Time from Epoch [s]\", fontsize=label_fontsize)\n    else:\n        ax.set_xlabel(\"Time\", fontsize=label_fontsize)\n        ax.xaxis.set_major_formatter(DateFormatter(\"%Y/%m/%d %H:%M:%S\"))\n        plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\")\n\n    ax.tick_params(axis=\"both\", labelsize=tick_label_fontsize)\n    ax.set_xlim(xlim if xlim else (x_data.iloc[0], x_data.iloc[-1]))\n    ax.set_ylim(ylim if ylim else (0, None))\n\n    if with_grid:\n        ax.xaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.yaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.grid(which=\"major\", linestyle=\"--\", alpha=0.6)\n        ax.grid(which=\"minor\", linestyle=\":\", alpha=0.4)\n\n    ax.legend(fontsize=legend_fontsize, loc=legend_loc)\n    fig.savefig(save_path, bbox_inches=\"tight\")\n    logger.info(f\"Saved visualization: {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.plot_delay","title":"plot_delay","text":"<pre><code>plot_delay(\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False,\n    replace_inf: bool = False\n) -&gt; None\n</code></pre> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_delay(\n    self,\n    save_path: Path,\n    *,\n    with_title: bool = False,\n    title_fontsize: int = 16,\n    label_fontsize: int = 14,\n    legend_fontsize: int = 12,\n    tick_label_fontsize: int = 12,\n    legend_loc: str = \"best\",\n    xlim: tuple | None = None,\n    ylim: tuple | None = None,\n    dpi: int = 300,\n    with_grid: bool = False,\n    use_time_from_epoch: bool = False,\n    replace_inf: bool = False,\n    # link_failure_timing=None,\n) -&gt; None:\n    ## Convert comm_data_demand_list into a pandas DataFrame\n    # \u5230\u9054\u3057\u305f\u30c7\u30fc\u30bf, \u3082\u3057\u304f\u306f\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u3057\u305f\u30c7\u30fc\u30bf\u306e\u307f\u30d7\u30ed\u30c3\u30c8\u3059\u308b\n    plot_df = pd.DataFrame(\n        {\n            \"generated_time\": [\n                comm_data_demand.generated_time\n                for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n            \"delay\": [\n                comm_data_demand.delay for comm_data_demand in self.packet_routing_result.comm_data_demand_list\n            ],\n        },\n    )\n    plot_df = plot_df.sort_values(\"generated_time\")\n\n    if use_time_from_epoch:\n        x_data = (plot_df[\"generated_time\"] - self.time[0]) / np.timedelta64(1, \"s\")\n    else:\n        x_data = plot_df[\"generated_time\"]\n\n    max_delay = plot_df[\"delay\"][plot_df[\"delay\"] != np.inf].max()\n\n    if replace_inf:\n        # np.inf\u3060\u3068\u30d7\u30ed\u30c3\u30c8\u3055\u308c\u306a\u3044\u306e\u3067\u3001\u9069\u5f53\u306a\u5927\u304d\u3044\u5024\u306b\u7f6e\u63db\n        plot_df[\"delay\"] = plot_df[\"delay\"].replace(np.inf, 1e5)\n\n    ## \u30d7\u30ed\u30c3\u30c8\n    fig, ax = plt.subplots(figsize=(10, 6), dpi=dpi)\n\n    ax.plot(x_data, plot_df[\"delay\"], label=\"Delay\", color=\"blue\")\n\n    # Customizing title and labels font size\n    if with_title:\n        ax.set_title(\"Delay\", fontsize=title_fontsize)\n    ax.set_ylabel(\"Average delay time [s]\", fontsize=label_fontsize)\n    if use_time_from_epoch:\n        ax.set_xlabel(\"Time from epoch[s]\", fontsize=label_fontsize)\n    else:\n        ax.set_xlabel(\"Time\", fontsize=label_fontsize)\n        # Formatting the x-axis with date and time, and rotating the text\n        ax.xaxis.set_major_formatter(DateFormatter(\"%Y/%m/%d %H:%M:%S\"))\n        plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\")\n\n    # Customizing tick label font size\n    ax.tick_params(axis=\"both\", labelsize=tick_label_fontsize)\n\n    # \u8ef8\u306e\u7bc4\u56f2\u8a2d\u5b9a\n    if use_time_from_epoch:\n        ax.set_xlim(xlim if xlim else (self.time_from_epoch[0], self.time_from_epoch[-1]))\n    else:\n        ax.set_xlim(xlim if xlim else (self.time[0], self.time[-1]))\n\n    if max_delay == np.inf or np.isnan(max_delay):\n        ax.set_ylim(0, None)\n    else:\n        ax.set_ylim(ylim if ylim else (0, max_delay * 1.1))\n\n    if with_grid:\n        ax.xaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.yaxis.set_minor_locator(AutoMinorLocator(5))\n        ax.grid(which=\"major\", color=\"#CCCCCC\", linestyle=\"--\")\n        ax.grid(which=\"minor\", color=\"#CCCCCC\", linestyle=\":\")\n\n    # \u51e1\u4f8b\u306e\u8a2d\u5b9a\n    ax.legend(fontsize=legend_fontsize, loc=legend_loc)\n\n    # \u4fdd\u5b58\n    fig.savefig(save_path, bbox_inches=\"tight\")\n    logger.info(f\"Saved visualization: {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.plot_graph_animation","title":"plot_graph_animation","text":"<pre><code>plot_graph_animation(\n    time_index_from: int,\n    time_index_to: int,\n    time_index_step: int,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100\n) -&gt; None\n</code></pre> <p>\u6642\u9593\u7d4c\u904e\u306b\u4f34\u3046\u30b0\u30e9\u30d5\u306e\u5909\u5316\u3092\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u3067\u63cf\u753b\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_graph_animation(\n    self,\n    time_index_from: int,\n    time_index_to: int,\n    time_index_step: int,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100,\n) -&gt; None:\n    \"\"\"\u6642\u9593\u7d4c\u904e\u306b\u4f34\u3046\u30b0\u30e9\u30d5\u306e\u5909\u5316\u3092\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u3067\u63cf\u753b\u3059\u308b.\"\"\"\n    # TODO(Takashima): time_index \u3067\u306a\u304f time\u3092\u5f15\u6570\u306b\u53d6\u308c\u308b\u3088\u3046\u306b\u3059\u308b\n    time_index_for_plot = range(time_index_from, time_index_to, time_index_step)\n\n    fig, ax = plt.subplots(figsize=(15, 8))\n\n    def update(frame: int):  # noqa: ANN202\n        ax.clear()\n        time_index = time_index_for_plot[frame]\n\n        edges_with_demand_data = self._get_edges_with_demand_data(time_index) if with_demand_data else set()\n\n        edges_with_lsa_data = self._get_edges_with_lsa_data(time_index) if with_lsa_data else set()\n\n        title = f\"Time: {np.datetime_as_string(self.time[time_index], unit='ms').split('T')[1]}\"\n        ax.set_title(title)\n\n        draw_lat_lon_grid(ax=ax)\n        draw_countries(ax=ax)\n        draw_snapshot(\n            graph=self.packet_routing_result.all_graphs_after_simulation[time_index],\n            dynamics_data=dynamics_data[time_index],\n            ax=ax,\n            with_labels=False,\n            focus_edges_list=[edges_with_demand_data, edges_with_lsa_data],\n            focus_edges_label_list=[\"Demand data\", \"LSA data\"],\n        )\n        ax.legend(loc=\"lower left\")\n\n    ani = FuncAnimation(fig, update, frames=len(time_index_for_plot), interval=100)\n    ani.save(\n        save_path,\n        dpi=dpi,\n    )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.plot_graph_at_certain_time","title":"plot_graph_at_certain_time","text":"<pre><code>plot_graph_at_certain_time(\n    time: datetime64,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100\n) -&gt; None\n</code></pre> <p>\u6307\u5b9a\u3057\u305f\u6642\u9593\u306e\u30b0\u30e9\u30d5\u3092\u63cf\u753b\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_graph_at_certain_time(\n    self,\n    time: np.datetime64,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100,\n) -&gt; None:\n    \"\"\"\u6307\u5b9a\u3057\u305f\u6642\u9593\u306e\u30b0\u30e9\u30d5\u3092\u63cf\u753b\u3059\u308b.\"\"\"\n    time_indices = np.where(self.time == time)[0]\n    if len(time_indices) == 0:\n        msg = f\"Time {time} not found in self.time array.\"\n        raise ValueError(msg)\n    time_index = time_indices[0]\n\n    edges_with_demand_data = self._get_edges_with_demand_data(time_index) if with_demand_data else set()\n\n    edges_with_lsa_data = self._get_edges_with_lsa_data(time_index) if with_lsa_data else set()\n    # routing_table_arrows = get_routing_table_arrows(time_idx)\n\n    fig, ax = plt.subplots(figsize=(15, 8))\n\n    title = f\"Time: {np.datetime_as_string(time, unit='ms').split('T')[1]}\"\n    ax.set_title(title)\n\n    draw_lat_lon_grid(ax=ax)\n    draw_countries(ax=ax)\n    draw_snapshot(\n        graph=self.packet_routing_result.all_graphs_after_simulation[time_index],\n        dynamics_data=dynamics_data[time_index],\n        ax=ax,\n        with_labels=False,\n        focus_edges_list=[edges_with_demand_data, edges_with_lsa_data],\n        focus_edges_label_list=[\"Demand data\", \"LSA data\"],\n    )\n\n    ax.legend(loc=\"lower left\")\n\n    # \u4fdd\u5b58\n    fig.savefig(save_path, bbox_inches=\"tight\", dpi=dpi)\n    logger.info(f\"Saved visualization: {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/routing_result_visualizer/#cosmica.experimental_packet_routing.routing_result_visualizer.RoutingResultVisualizer.plot_graph_over_time","title":"plot_graph_over_time","text":"<pre><code>plot_graph_over_time(\n    time_index_from: int,\n    time_index_to: int,\n    time_index_step: int,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100\n) -&gt; None\n</code></pre> <p>\u6642\u9593\u7d4c\u904e\u306b\u4f34\u3046\u30b0\u30e9\u30d5\u306e\u5909\u5316\u3092\u63cf\u753b\u3059\u308b.</p> Source code in <code>src/cosmica/experimental_packet_routing/routing_result_visualizer.py</code> <pre><code>def plot_graph_over_time(\n    self,\n    time_index_from: int,\n    time_index_to: int,\n    time_index_step: int,\n    dynamics_data: DynamicsData[ConstellationSatellite],\n    save_path: Path,\n    *,\n    with_demand_data: bool = True,\n    with_lsa_data: bool = False,\n    dpi: int = 100,\n) -&gt; None:\n    \"\"\"\u6642\u9593\u7d4c\u904e\u306b\u4f34\u3046\u30b0\u30e9\u30d5\u306e\u5909\u5316\u3092\u63cf\u753b\u3059\u308b.\"\"\"\n    # TODO(Takashima): time_index \u3067\u306a\u304f time\u3092\u5f15\u6570\u306b\u53d6\u308c\u308b\u3088\u3046\u306b\u3059\u308b\n    n_fig = (time_index_to - time_index_from) // time_index_step\n    ncols = 3\n    nrows = (n_fig + ncols - 1) // ncols\n\n    fig, axes = plt.subplots(\n        nrows=nrows,\n        ncols=ncols,\n        figsize=(15 * ncols, 8 * nrows),\n    )\n    fig.subplots_adjust(wspace=0.1, hspace=0.1)\n\n    for idx, time_index in enumerate(range(time_index_from, time_index_to, time_index_step)):\n        row, col = divmod(idx, ncols)\n\n        edges_with_demand_data = self._get_edges_with_demand_data(time_index) if with_demand_data else set()\n\n        edges_with_lsa_data = self._get_edges_with_lsa_data(time_index) if with_lsa_data else set()\n\n        title = f\"Time: {np.datetime_as_string(self.time[time_index], unit='ms').split('T')[1]}\"\n        axes[row, col].set_title(title)\n\n        draw_lat_lon_grid(ax=axes[row, col])\n        draw_countries(ax=axes[row, col])\n        draw_snapshot(\n            graph=self.packet_routing_result.all_graphs_after_simulation[time_index],\n            dynamics_data=dynamics_data[time_index],\n            ax=axes[row, col],\n            with_labels=False,\n            focus_edges_list=[edges_with_demand_data, edges_with_lsa_data],\n            focus_edges_label_list=[\"Demand data\", \"LSA data\"],\n        )\n\n    # \u4fdd\u5b58\n    fig.savefig(save_path, bbox_inches=\"tight\", dpi=dpi)\n    logger.info(f\"Saved visualization: {save_path}\")\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/","title":"simulator","text":""},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator","title":"cosmica.experimental_packet_routing.simulator","text":""},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator","title":"PacketCommunicationSimulator","text":"<pre><code>PacketCommunicationSimulator(\n    time: NDArray[datetime64],\n    all_graphs_with_comm_performance: list[Graph],\n    nodes_dict: dict[NodeGID, Node],\n    demands: list[Demand],\n    *,\n    backup_case: BackupCaseType = \"no-backup\",\n    hop_limit: int = 1,\n    packet_size: int = int(10000.0),\n    space_time_graph: SpaceTimeGraph\n)\n</code></pre> <p>\u6642\u7cfb\u5217\u306e\u30d1\u30b1\u30c3\u30c8\u30ec\u30d9\u30eb\u306e\u901a\u4fe1\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u5b9f\u65bd\u3059\u308b\u30af\u30e9\u30b9.</p> PARAMETER DESCRIPTION <code>time</code> <p>Array of datetime64 representing the time points</p> <p> TYPE: <code>NDArray[datetime64]</code> </p> <code>all_graphs_with_comm_performance</code> <p>List of Graph objects representing communication performance over time</p> <p> TYPE: <code>list[Graph]</code> </p> <code>nodes_dict</code> <p>Dictionary mapping NodeGID to Node objects</p> <p> TYPE: <code>dict[NodeGID, Node]</code> </p> <code>demands</code> <p>List of demands</p> <p> TYPE: <code>list[Demand]</code> </p> <code>backup_case</code> <p>Backup case scenario identifier, default is 'no-backup'</p> <p> TYPE: <code>BackupCaseType</code> DEFAULT: <code>'no-backup'</code> </p> <code>hop_limit</code> <p>Hop limit for backup routing, default is 1</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>packet_size</code> <p>Size of the packet for communication [bit], default is 10,000</p> <p> TYPE: <code>int</code> DEFAULT: <code>int(10000.0)</code> </p> <code>space_time_graph</code> <p>SpaceTimeGraph object</p> <p> TYPE: <code>SpaceTimeGraph</code> </p> Source code in <code>src/cosmica/experimental_packet_routing/simulator.py</code> <pre><code>def __init__(\n    self,\n    time: Annotated[\n        npt.NDArray[np.datetime64],\n        Doc(\"Array of datetime64 representing the time points\"),\n    ],\n    all_graphs_with_comm_performance: Annotated[\n        list[Graph],\n        Doc(\"List of Graph objects representing communication performance over time\"),\n    ],\n    nodes_dict: Annotated[dict[NodeGID, Node], Doc(\"Dictionary mapping NodeGID to Node objects\")],\n    demands: Annotated[list[Demand], Doc(\"List of demands\")],\n    *,\n    backup_case: Annotated[\n        BackupCaseType,\n        Doc(\"Backup case scenario identifier, default is 'no-backup'\"),\n    ] = \"no-backup\",\n    hop_limit: Annotated[int, Doc(\"Hop limit for backup routing, default is 1\")] = 1,\n    packet_size: Annotated[int, Doc(\"Size of the packet for communication [bit], default is 10,000\")] = int(1e4),\n    space_time_graph: Annotated[\n        SpaceTimeGraph,\n        Doc(\"SpaceTimeGraph object\"),\n    ],\n) -&gt; None:\n    assert len(time) == len(all_graphs_with_comm_performance)\n\n    self.time: npt.NDArray[np.datetime64] = time\n    self.all_graphs_with_comm_performance: list[Graph] = all_graphs_with_comm_performance\n    self.nodes_dict: dict[NodeGID, Node] = nodes_dict\n    self.demands: list[Demand] = demands\n\n    self.backup_case: BackupCaseType = backup_case\n    self.hop_limit: int = hop_limit\n    self.packet_size: int = packet_size\n\n    self.node_knowledge_known_by_each_node: dict[Node, NodeKnowledge] = {}\n    self.space_time_graph = space_time_graph\n    for node in tqdm(self.nodes_dict.values(), desc=\"Initializing node knowledge\"):\n        self.node_knowledge_known_by_each_node[node] = NodeKnowledge(\n            target_node=node,\n            space_time_graph=copy.deepcopy(self.space_time_graph),\n            forwarding_table_time_list=initialize_forwarding_table_list_from_space_time_graph(\n                space_time_graph=self.space_time_graph,\n                src_node=node,\n                weight=\"weight\",\n                backup_case=self.backup_case,\n                hops_limit=self.hop_limit,\n            ),\n        )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.all_graphs_with_comm_performance","title":"all_graphs_with_comm_performance  <code>instance-attribute</code>","text":"<pre><code>all_graphs_with_comm_performance: list[Graph] = (\n    all_graphs_with_comm_performance\n)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.backup_case","title":"backup_case  <code>instance-attribute</code>","text":"<pre><code>backup_case: BackupCaseType = backup_case\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.demands","title":"demands  <code>instance-attribute</code>","text":"<pre><code>demands: list[Demand] = demands\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.hop_limit","title":"hop_limit  <code>instance-attribute</code>","text":"<pre><code>hop_limit: int = hop_limit\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.node_knowledge_known_by_each_node","title":"node_knowledge_known_by_each_node  <code>instance-attribute</code>","text":"<pre><code>node_knowledge_known_by_each_node: dict[\n    Node, NodeKnowledge\n] = {}\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.nodes_dict","title":"nodes_dict  <code>instance-attribute</code>","text":"<pre><code>nodes_dict: dict[NodeGID, Node] = nodes_dict\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.packet_size","title":"packet_size  <code>instance-attribute</code>","text":"<pre><code>packet_size: int = packet_size\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.space_time_graph","title":"space_time_graph  <code>instance-attribute</code>","text":"<pre><code>space_time_graph = space_time_graph\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: NDArray[datetime64] = time\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.create_packet_routing_setting","title":"create_packet_routing_setting","text":"<pre><code>create_packet_routing_setting() -&gt; PacketRoutingSetting\n</code></pre> <p>Generate and return a PacketRoutingSetting object.</p> Source code in <code>src/cosmica/experimental_packet_routing/simulator.py</code> <pre><code>def create_packet_routing_setting(self) -&gt; PacketRoutingSetting:\n    \"\"\"Generate and return a PacketRoutingSetting object.\"\"\"\n    return PacketRoutingSetting(\n        time=self.time,\n        nodes_dict=self.nodes_dict,\n        demands=self.demands,\n        backup_case=self.backup_case,\n        hop_limit=self.hop_limit,\n        packet_size=self.packet_size,\n    )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/simulator/#cosmica.experimental_packet_routing.simulator.PacketCommunicationSimulator.run","title":"run","text":"<pre><code>run(\n    *,\n    rng: Generator | None = None,\n    edge_remove_schedule: (\n        list[tuple[datetime64, tuple[Node, Node]]] | None\n    ) = None,\n    failure_detection_time: timedelta64 | None = None,\n    enable_random_routing_when_edge_failure: bool = False,\n    prevent_loop: bool = False,\n    with_lsa: bool = True,\n    lsa_case: LsaCaseType = \"from-source-to-all\"\n) -&gt; PacketRoutingResult\n</code></pre> PARAMETER DESCRIPTION <code>rng</code> <p>NumPy random number generator. If None, use default.</p> <p> TYPE: <code>Generator | None</code> DEFAULT: <code>None</code> </p> <code>edge_remove_schedule</code> <p>List of edge removal schedule</p> <p> TYPE: <code>list[tuple[datetime64, tuple[Node, Node]]] | None</code> DEFAULT: <code>None</code> </p> <code>failure_detection_time</code> <p>Time taken for failure detection</p> <p> TYPE: <code>timedelta64 | None</code> DEFAULT: <code>None</code> </p> <code>enable_random_routing_when_edge_failure</code> <p>Flag to enable random routing when edge failure</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>prevent_loop</code> <p>Flag to prevent loop in routing</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>with_lsa</code> <p>Flag to enable LSA data</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>lsa_case</code> <p>Case scenario identifier for LSA data, default is 'nominal'</p> <p> TYPE: <code>LsaCaseType</code> DEFAULT: <code>'from-source-to-all'</code> </p> Source code in <code>src/cosmica/experimental_packet_routing/simulator.py</code> <pre><code>def run(  # noqa: C901, PLR0912, PLR0915\n    self,\n    *,\n    rng: Annotated[\n        np.random.Generator | None,\n        Doc(\"NumPy random number generator. If None, use default.\"),\n    ] = None,\n    edge_remove_schedule: Annotated[\n        list[tuple[np.datetime64, tuple[Node, Node]]] | None,\n        Doc(\"List of edge removal schedule\"),\n    ] = None,\n    failure_detection_time: Annotated[np.timedelta64 | None, Doc(\"Time taken for failure detection\")] = None,\n    enable_random_routing_when_edge_failure: Annotated[\n        bool,\n        Doc(\"Flag to enable random routing when edge failure\"),\n    ] = False,\n    prevent_loop: Annotated[bool, Doc(\"Flag to prevent loop in routing\")] = False,\n    with_lsa: Annotated[bool, Doc(\"Flag to enable LSA data\")] = True,\n    lsa_case: Annotated[\n        LsaCaseType,\n        Doc(\"Case scenario identifier for LSA data, default is 'nominal'\"),\n    ] = \"from-source-to-all\",\n) -&gt; PacketRoutingResult:\n    ## \u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u306e\u8a2d\u5b9a ========================================\n    rng = rng if rng is not None else np.random.default_rng()\n    edge_remove_schedule = edge_remove_schedule if edge_remove_schedule is not None else []\n    failure_detection_time = (\n        failure_detection_time if failure_detection_time is not None else np.timedelta64(10, \"ms\")\n    )\n\n    ## \u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u60c5\u5831\u3092\u30ed\u30b0\u51fa\u529b ========================================\n    logger.info(f\"Starting packet communication simulation with {len(self.time)} time steps\")\n    logger.info(f\"Number of nodes: {len(self.nodes_dict)}\")\n    logger.info(f\"Number of demands: {len(self.demands)}\")\n    if edge_remove_schedule:\n        logger.info(f\"Edge removal schedule: {len(edge_remove_schedule)} events\")\n        for timing, edge in edge_remove_schedule:\n            logger.info(f\"  - {edge[0].id} &lt;-&gt; {edge[1].id} at {timing}\")\n\n    ## \u30c7\u30fc\u30bf\u683c\u7d0d\u7528\u306e\u30ea\u30b9\u30c8 ========================================\n    all_graphs_after_simulation: list[Graph] = []  # \u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u5f8c\u306e\u30b0\u30e9\u30d5\u5c65\u6b74\n    comm_data_demand_list: list[CommDataDemand] = []\n    comm_data_lsa_list: list[CommDataLSA] = []\n\n    ## \u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u306e\u5b9f\u884c ========================================\n    for time_idx, current_time in tqdm(\n        enumerate(self.time),\n        desc=\"Running packet simulation\",\n        total=len(self.time),\n    ):\n        if time_idx &lt; len(self.time) - 1:\n            time_step: np.timedelta64 = self.time[time_idx + 1] - self.time[time_idx]\n            time_step_s: float = float(time_step / np.timedelta64(1, \"s\"))\n\n        ## \u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u306b\u304a\u3051\u308b\u30b0\u30e9\u30d5\u306e\u751f\u6210 ========================================\n        _graph: Graph = copy.deepcopy(self.all_graphs_with_comm_performance[time_idx])\n\n        # Initialize the edge attributes\n        nx.set_edge_attributes(\n            _graph,\n            {edge: {\"bandwidth_usage_for_demand_data\": 0} for edge in _graph.edges},\n        )\n        nx.set_edge_attributes(\n            _graph,\n            {edge: {\"bandwidth_usage_for_lsa_data\": 0} for edge in _graph.edges},\n        )\n\n        ## Edge\u306e\u5207\u65ad ========================================\n        for edge_remove_timing, edge_to_remove in edge_remove_schedule:\n            if current_time &gt;= edge_remove_timing:\n                logger.info(\n                    f\"Edge {edge_to_remove[0].id} &lt;-&gt; {edge_to_remove[1].id} disconnected at {current_time}\",\n                )\n                remove_edge_safe(_graph, *edge_to_remove)\n                # Edge\u4e0a\u306b\u3042\u308b\u30c7\u30fc\u30bf\u306f\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u3068\u5224\u65ad\n                packet_loss_count_demand = 0\n                for comm_data_demand in comm_data_demand_list:\n                    if isinstance(comm_data_demand.current_position, tuple) and set(\n                        comm_data_demand.current_position,\n                    ) == set(edge_to_remove):\n                        comm_data_demand.packet_loss = True\n                        comm_data_demand.delay = np.inf\n                        packet_loss_count_demand += 1\n                packet_loss_count_lsa = 0\n                for comm_data_lsa in comm_data_lsa_list:\n                    if isinstance(comm_data_lsa.current_position, tuple) and set(\n                        comm_data_lsa.current_position,\n                    ) == set(edge_to_remove):\n                        comm_data_lsa.packet_loss = True\n                        comm_data_lsa.delay = np.inf\n                        packet_loss_count_lsa += 1\n                if packet_loss_count_demand &gt; 0 or packet_loss_count_lsa &gt; 0:\n                    logger.info(\n                        f\"Packet loss due to edge disconnection: \"\n                        f\"{packet_loss_count_demand} demand packets, {packet_loss_count_lsa} LSA packets\",\n                    )\n\n        ## Edge\u306e\u5fa9\u65e7 ========================================\n        # TODO(Takashima): \u672a\u5b9f\u88c5\n\n        ## \u901a\u4fe1\u30c7\u30fc\u30bf\u306e\u751f\u6210 ========================================\n        # LSA\u30c7\u30fc\u30bf\u306e\u751f\u6210\n        if with_lsa:\n            for edge_remove_timing, edge_to_remove in edge_remove_schedule:\n                failure_detection_timing: np.datetime64 = edge_remove_timing + failure_detection_time\n                if (time_idx == 0 and failure_detection_timing &lt;= self.time[time_idx]) or (\n                    time_idx &gt; 0 and self.time[time_idx - 1] &lt; failure_detection_timing &lt;= self.time[time_idx]\n                ):\n                    # \u5207\u65adEdge\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b node \u60c5\u5831\u3092\u66f4\u65b0\n                    for detect_node in edge_to_remove:\n                        # \u81ea\u8eab\u306e\u60c5\u5831\u3092\u66f4\u65b0\n                        self.node_knowledge_known_by_each_node[detect_node].update_node_knowledge_based_on_lsa(\n                            comm_data_lsa=CommDataLSA(\n                                data_size=self.packet_size,\n                                packet_size=self.packet_size,\n                                packet_num=1,\n                                dst_node=detect_node,\n                                next_node=detect_node,\n                                current_position=detect_node,\n                                path=[detect_node],\n                                generated_time=current_time,\n                                time=current_time,\n                                time_from_generated=0.0,\n                                time_remaining_for_current_position=0.0,\n                                failure_position=edge_to_remove,\n                            ),\n                            current_time=current_time,\n                            weight=\"weight\",\n                            backup_case=self.backup_case,\n                            hops_limit=self.hop_limit,\n                        )\n                    # LSA\u30c7\u30fc\u30bf\u306e\u751f\u6210\n                    if lsa_case == \"from-source-to-all\":\n                        #  \u5207\u65adEdge\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b node \u304b\u3089 \u4ed6\u306e\u3059\u3079\u3066\u306e node \u306b\u5bfe\u3057\u3066 LSA \u30c7\u30fc\u30bf\u3092\u751f\u6210\n                        for detect_node in edge_to_remove:\n                            for dst_node in self.nodes_dict.values():\n                                if dst_node == detect_node:\n                                    # dst_node = detect_node \u306e\u5834\u5408\u306f\u30b9\u30ad\u30c3\u30d7\n                                    continue\n                                next_node = calc_next_node_from_node_knowledge(\n                                    node_knowledge=self.node_knowledge_known_by_each_node[detect_node],\n                                    dst_node=dst_node,\n                                    path=[detect_node],\n                                    current_time=current_time,\n                                    enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                                    prevent_loop=prevent_loop,\n                                )\n                                if next_node is None:\n                                    continue\n                                comm_data_lsa = CommDataLSA(\n                                    data_size=self.packet_size,\n                                    packet_size=self.packet_size,\n                                    packet_num=1,\n                                    dst_node=dst_node,\n                                    next_node=next_node,\n                                    current_position=detect_node,\n                                    path=[detect_node],\n                                    generated_time=current_time,\n                                    time=current_time,\n                                    time_from_generated=0.0,\n                                    time_remaining_for_current_position=0.0,\n                                    failure_position=edge_to_remove,\n                                )\n                                comm_data_lsa_list.append(comm_data_lsa)\n                    elif lsa_case == \"adjacent\":\n                        # \u5207\u65adEdge\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b node \u304b\u3089 \u96a3\u63a5 node \u306b\u5bfe\u3057\u3066 LSA \u30c7\u30fc\u30bf\u3092\u751f\u6210\n                        for detect_node in edge_to_remove:\n                            for dst_node in list(_graph.neighbors(detect_node)):\n                                next_node = calc_next_node_from_node_knowledge(\n                                    node_knowledge=self.node_knowledge_known_by_each_node[detect_node],\n                                    dst_node=dst_node,\n                                    path=[detect_node],\n                                    current_time=current_time,\n                                    enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                                    prevent_loop=prevent_loop,\n                                )\n                                if next_node is None:\n                                    continue\n                                comm_data_lsa = CommDataLSA(\n                                    data_size=self.packet_size,\n                                    packet_size=self.packet_size,\n                                    packet_num=1,\n                                    dst_node=dst_node,\n                                    next_node=next_node,\n                                    current_position=detect_node,\n                                    path=[detect_node],\n                                    generated_time=current_time,\n                                    time=current_time,\n                                    time_from_generated=0.0,\n                                    time_remaining_for_current_position=0.0,\n                                    failure_position=edge_to_remove,\n                                )\n                                comm_data_lsa_list.append(comm_data_lsa)\n\n        # Demand\u30c7\u30fc\u30bf\u306e\u751f\u6210\n        # 1\u30d1\u30b1\u30c3\u30c8\u305a\u3064\u6271\u3046\u3068\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u6642\u9593\u304c\u304b\u304b\u308b\u306e\u3067\u3001\u5b9b\u5148\u304c\u540c\u3058 &amp; \u751f\u6210\u6642\u523b\u304c\u540c\u3058\u30d1\u30b1\u30c3\u30c8\u3092comm_data\u3068\u3057\u3066\u307e\u3068\u3081\u3066\u3044\u308b  # noqa: E501\n        for demand in self.demands:\n            if isinstance(demand, ConstantCommunicationDemand) or (\n                isinstance(demand, TemporaryCommunicationDemand) and demand.is_active(current_time)\n            ):\n                if demand.distribution == \"uniform\":\n                    packet_num = int(demand.transmission_rate * time_step_s / self.packet_size)\n                elif demand.distribution == \"poisson\":\n                    packet_num = int(rng.poisson(lam=demand.transmission_rate * time_step_s / self.packet_size))\n\n                next_node = calc_next_node_from_node_knowledge(\n                    node_knowledge=self.node_knowledge_known_by_each_node[self.nodes_dict[demand.source]],\n                    dst_node=self.nodes_dict[demand.destination],\n                    path=[self.nodes_dict[demand.source]],\n                    current_time=current_time,\n                    enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                    prevent_loop=prevent_loop,\n                )\n                if next_node is None:\n                    continue\n                comm_data_demand = CommDataDemand(\n                    demand_id=demand.id,\n                    data_size=packet_num * self.packet_size,\n                    packet_size=self.packet_size,\n                    packet_num=packet_num,\n                    dst_node=self.nodes_dict[demand.destination],\n                    next_node=next_node,\n                    current_position=self.nodes_dict[demand.source],\n                    path=[self.nodes_dict[demand.source]],\n                    generated_time=current_time,\n                    time=current_time,\n                    time_from_generated=0.0,\n                    time_remaining_for_current_position=0.0,\n                )\n                comm_data_demand_list.append(comm_data_demand)\n\n        ## \u901a\u4fe1\u30c7\u30fc\u30bf\u306e\u4f1d\u64ad ========================================\n        # TODO(Takashima): comm_data_lsa_list\u3084comm_data_demand_list\u306b\u3064\u3044\u3066\u3001\u5c4a\u3044\u305f\u30c7\u30fc\u30bf\u3084\u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u306e\u30c7\u30fc\u30bf\u3092\u524a\u9664\u3057\u306a\u3044\u5834\u5408\u3001for\u306e\u30eb\u30fc\u30d7\u56de\u6570\u304c\u5897\u5927\u3057\u3066\u3044\u304f\u306e\u3067\u3001\u51e6\u7406\u3092\u691c\u8a0e  # noqa: E501\n\n        # LSA\u30c7\u30fc\u30bf\u306e\u4f1d\u64ad\n        if with_lsa:\n            for comm_data_lsa in comm_data_lsa_list:\n                if comm_data_lsa.packet_loss or comm_data_lsa.reach_dst:\n                    continue\n                if comm_data_lsa.generated_time &gt; current_time + time_step:\n                    continue\n\n                # \u5171\u901a\u51e6\u7406\n                if comm_data_lsa.time &gt; current_time:\n                    comm_data_lsa.time_remaining_for_current_position -= float(\n                        (current_time + time_step - comm_data_lsa.time) / np.timedelta64(1, \"s\"),\n                    )\n                    comm_data_lsa.time = current_time + time_step\n                else:\n                    comm_data_lsa.time_remaining_for_current_position -= time_step_s\n                    comm_data_lsa.time += time_step\n\n                # Node -&gt; Edge\u3001Edge -&gt; Node\u306a\u3069\u5883\u754c\u3092\u8d85\u3048\u308b\u6642\u306e\u30c7\u30fc\u30bf\u306e\u51e6\u7406\n                while comm_data_lsa.time_remaining_for_current_position &lt; 0:\n                    # Node -&gt; Edge\n                    if not isinstance(comm_data_lsa.current_position, tuple):\n                        next_edge: tuple[Node, Node] = (\n                            comm_data_lsa.current_position,\n                            comm_data_lsa.next_node,\n                        )\n\n                        # \u8ee2\u9001\u5148\u306eEdge\u304c\u5b58\u5728\u3057\u306a\u3044\u6642 -&gt; \u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u3068\u5224\u65ad\n                        if not has_edge_bidirectional(_graph, *next_edge):\n                            comm_data_lsa.packet_loss = True\n                            comm_data_lsa.delay = np.inf\n                            break\n\n                        # Congestion\u306e\u8003\u616e -&gt; LSA\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u306f\u3001\u5360\u6709bandwidth\u306e\u8003\u616e\u306f\u884c\u308f\u306a\u3044\n\n                        # \u73fe\u5728\u4f4d\u7f6e\u306e\u66f4\u65b0\n                        comm_data_lsa.current_position = next_edge\n                        edge_data = get_edge_data(_graph, *next_edge)\n                        if edge_data is not None:\n                            edge_data[\"bandwidth_usage_for_lsa_data\"] += comm_data_lsa.data_size / time_step_s\n\n                            # \u73fe\u5728\u4f4d\u7f6e\u306b\u7559\u307e\u308b\u6b8b\u6642\u9593\u306e\u66f4\u65b0\n                            comm_data_lsa.time_remaining_for_current_position += edge_data[\"delay\"]\n                            comm_data_lsa.time_from_generated += edge_data[\"delay\"]\n\n                    # Edge -&gt; Node\n                    elif isinstance(comm_data_lsa.current_position, tuple):\n                        # \u73fe\u5728\u4f4d\u7f6e\u306e\u66f4\u65b0\n                        comm_data_lsa.current_position = comm_data_lsa.next_node\n                        comm_data_lsa.path.append(comm_data_lsa.current_position)\n\n                        # \u73fe\u5728\u306e\u4f4d\u7f6e\u304c\u76ee\u7684\u5730\u306e\u5834\u5408\n                        if comm_data_lsa.current_position == comm_data_lsa.dst_node:\n                            comm_data_lsa.reach_dst = True\n                            comm_data_lsa.delay = comm_data_lsa.time_from_generated\n                            logger.info(\n                                f\"LSA data received at {comm_data_lsa.dst_node.id} \"\n                                f\"(delay: {comm_data_lsa.delay:.6f}s, failure: {comm_data_lsa.failure_position})\",\n                            )\n                            if lsa_case == \"from-source-to-all\":\n                                self.node_knowledge_known_by_each_node[\n                                    comm_data_lsa.current_position\n                                ].update_node_knowledge_based_on_lsa(\n                                    comm_data_lsa,\n                                    current_time,\n                                    weight=\"weight\",\n                                    backup_case=self.backup_case,\n                                    hops_limit=self.hop_limit,\n                                )\n                            elif lsa_case == \"adjacent\":\n                                already_registered = False\n                                for failure_assumed_edge in self.node_knowledge_known_by_each_node[\n                                    comm_data_lsa.current_position\n                                ].failure_assumed_edge_list:\n                                    if isinstance(comm_data_lsa.failure_position, tuple) and (\n                                        set(failure_assumed_edge) == set(comm_data_lsa.failure_position)\n                                    ):\n                                        already_registered = True\n\n                                # \u540c\u3058\u30ea\u30f3\u30af\u5207\u65ad\u304c\u65e2\u306b\u767b\u9332\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044\n                                if already_registered:\n                                    logger.info(\n                                        f\"LSA data received at {comm_data_lsa.dst_node.id} \"\n                                        f\"(already registered failure: {comm_data_lsa.failure_position})\",\n                                    )\n                                # \u767b\u9332\u3055\u308c\u3066\u3044\u306a\u3044\u30ea\u30f3\u30af\u5207\u65ad\u60c5\u5831\u306e\u5834\u5408\u306e\u307f\u3001\u60c5\u5831\u3092\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u3057\u3001\u96a3\u63a5\u30ce\u30fc\u30c9\u306b\u4f1d\u642c\n                                else:\n                                    logger.info(\n                                        f\"LSA data received at {comm_data_lsa.dst_node.id} \"\n                                        f\"(new failure info: {comm_data_lsa.failure_position})\",\n                                    )\n                                    self.node_knowledge_known_by_each_node[\n                                        comm_data_lsa.current_position\n                                    ].update_node_knowledge_based_on_lsa(\n                                        comm_data_lsa,\n                                        current_time,\n                                        weight=\"weight\",\n                                        backup_case=self.backup_case,\n                                        hops_limit=self.hop_limit,\n                                    )\n\n                                    # \u96a3\u63a5node\u306bLSA\u30c7\u30fc\u30bf\u3092\u4f1d\u642c\n                                    graph_known_by_node = self.node_knowledge_known_by_each_node[\n                                        comm_data_lsa.current_position\n                                    ].space_time_graph.get_space_time_graph_at_time(current_time)\n                                    next_destination_list = list(\n                                        graph_known_by_node.neighbors(comm_data_lsa.current_position),\n                                    )\n\n                                    for dst_node in next_destination_list:\n                                        next_node = calc_next_node_from_node_knowledge(\n                                            node_knowledge=self.node_knowledge_known_by_each_node[\n                                                comm_data_lsa.current_position\n                                            ],\n                                            dst_node=dst_node,\n                                            path=[comm_data_lsa.current_position],\n                                            current_time=current_time,\n                                            enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                                            prevent_loop=prevent_loop,\n                                        )\n                                        if next_node is None:\n                                            continue\n\n                                        generated_time = (\n                                            comm_data_lsa.generated_time\n                                            + np.timedelta64(\n                                                int(comm_data_lsa.delay * 1e3),\n                                                \"ms\",\n                                            )  # TODO(): \u73fe\u72b6\u3060\u3068ms\u5358\u4f4d\u3067\u751f\u6210\u3055\u308c\u3001\u3088\u308a\u7d30\u304b\u3044\u5358\u4f4d\u306b\u5bfe\u5fdc\u3067\u304d\u306a\u3044\n                                            + np.timedelta64(\n                                                10,\n                                                \"ms\",\n                                            )  # TODO(): \u51e6\u7406\u9045\u5ef6\u306b\u3064\u3044\u3066\u30d1\u30e9\u30e1\u30fc\u30bf\u3067\u8a2d\u5b9a\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b\n                                        )\n                                        comm_data_lsa_new = CommDataLSA(\n                                            data_size=self.packet_size,\n                                            packet_size=self.packet_size,\n                                            packet_num=1,\n                                            dst_node=dst_node,\n                                            next_node=next_node,\n                                            current_position=comm_data_lsa.current_position,\n                                            path=[comm_data_lsa.current_position],\n                                            generated_time=generated_time,\n                                            time=generated_time,\n                                            time_from_generated=0,\n                                            time_remaining_for_current_position=0,\n                                            failure_position=comm_data_lsa.failure_position,\n                                        )\n                                        comm_data_lsa_list.append(comm_data_lsa_new)\n                            else:\n                                pass\n\n                            break  # \u76ee\u7684\u5730\u306b\u5230\u9054\u3057\u305f\u5834\u5408\u306f\u3001\u6b21\u306e\u901a\u4fe1\u30c7\u30fc\u30bf\u306b\u79fb\u308b\n\n                        # \u73fe\u5728\u306e\u4f4d\u7f6e\u304c\u76ee\u7684\u5730\u3067\u306a\u3044\u5834\u5408\n                        # \u73fe\u5728\u4f4d\u7f6e\u306b\u7559\u307e\u308b\u6b8b\u6642\u9593\u306e\u66f4\u65b0\n                        # TODO(Takashima): \u5b9f\u969b\u306b\u306fBuffer\u306b\u5165\u308c\u305f\u308a\u3059\u308b\u306e\u3067\u305d\u306e\u51e6\u7406\u3092\u691c\u8a0e\n                        comm_data_lsa.time_remaining_for_current_position += _graph.nodes[\n                            comm_data_lsa.current_position\n                        ][\"delay\"]\n                        comm_data_lsa.time_from_generated += _graph.nodes[comm_data_lsa.current_position][\"delay\"]\n\n                        # \u30eb\u30fc\u30c6\u30a3\u30f3\u30b0\u30c6\u30fc\u30d6\u30eb\u306e\u53c2\u7167\n                        next_node = calc_next_node_from_node_knowledge(\n                            node_knowledge=self.node_knowledge_known_by_each_node[comm_data_lsa.current_position],\n                            dst_node=comm_data_lsa.dst_node,\n                            path=comm_data_lsa.path,\n                            current_time=current_time,\n                            enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                            prevent_loop=prevent_loop,\n                        )\n                        if next_node is None:\n                            comm_data_lsa.packet_loss = True\n                            comm_data_lsa.delay = np.inf\n                            break\n                        comm_data_lsa.next_node = next_node\n\n        # Demand\u30c7\u30fc\u30bf\u306e\u4f1d\u64ad\n        # TODO(Takashima): \u73fe\u72b6\u306f\u5148\u306b\u751f\u6210\u3055\u308c\u305f\u30c7\u30fc\u30bf\u306e\u4f1d\u64ad\u304c\u512a\u5148\u3055\u308c\u308b\u306e\u3067, \u512a\u5148\u9806\u4f4d\u306b\u3064\u3044\u3066\u691c\u8a0e\n        for comm_data_demand in comm_data_demand_list:\n            if comm_data_demand.packet_loss or comm_data_demand.reach_dst:\n                continue\n            if comm_data_demand.generated_time &gt; current_time + time_step:\n                continue\n\n            # \u5171\u901a\u51e6\u7406\n            if comm_data_demand.time &gt; current_time:\n                comm_data_demand.time_remaining_for_current_position -= float(\n                    (current_time + time_step - comm_data_demand.time) / np.timedelta64(1, \"s\"),\n                )\n                comm_data_demand.time = current_time + time_step\n            else:\n                comm_data_demand.time_remaining_for_current_position -= time_step_s\n                comm_data_demand.time += time_step\n\n            # Node -&gt; Edge\u3001Edge -&gt; Node\u306a\u3069\u5883\u754c\u3092\u8d85\u3048\u308b\u6642\u306e\u30c7\u30fc\u30bf\u306e\u51e6\u7406\n            while comm_data_demand.time_remaining_for_current_position &lt; 0:\n                # Node -&gt; Edge\n                if not isinstance(comm_data_demand.current_position, tuple):\n                    next_edge = (\n                        comm_data_demand.current_position,\n                        comm_data_demand.next_node,\n                    )\n\n                    # \u8ee2\u9001\u5148\u306eEdge\u304c\u5b58\u5728\u3057\u306a\u3044\u6642 -&gt; \u30d1\u30b1\u30c3\u30c8\u30ed\u30b9\u3068\u5224\u65ad\n                    if not has_edge_bidirectional(_graph, *next_edge):\n                        comm_data_demand.packet_loss = True\n                        comm_data_demand.delay = np.inf\n                        break\n\n                    # Congestion\u306e\u8003\u616e\n                    edge_data = get_edge_data(_graph, *next_edge)\n                    if edge_data is None:\n                        comm_data_demand.packet_loss = True\n                        comm_data_demand.delay = np.inf\n                        break\n\n                    if (\n                        edge_data[\"bandwidth_usage_for_demand_data\"] + comm_data_demand.data_size / time_step_s\n                        &gt; edge_data[\"link_capacity\"]\n                    ):\n                        comm_data_demand.packet_loss = True\n                        comm_data_demand.delay = np.inf\n                        break\n\n                    # \u73fe\u5728\u4f4d\u7f6e\u306e\u66f4\u65b0\n                    comm_data_demand.current_position = next_edge\n                    edge_data[\"bandwidth_usage_for_demand_data\"] += comm_data_demand.data_size / time_step_s\n\n                    # \u73fe\u5728\u4f4d\u7f6e\u306b\u7559\u307e\u308b\u6b8b\u6642\u9593\u306e\u66f4\u65b0\n                    comm_data_demand.time_remaining_for_current_position += edge_data[\"delay\"]\n                    comm_data_demand.time_from_generated += edge_data[\"delay\"]\n\n                # Edge -&gt; Node\n                elif isinstance(comm_data_demand.current_position, tuple):\n                    # \u73fe\u5728\u4f4d\u7f6e\u306e\u66f4\u65b0\n                    comm_data_demand.current_position = comm_data_demand.next_node\n                    comm_data_demand.path.append(comm_data_demand.current_position)\n\n                    # \u73fe\u5728\u306e\u4f4d\u7f6e\u304c\u76ee\u7684\u5730\u306e\u5834\u5408\n                    if comm_data_demand.current_position == comm_data_demand.dst_node:\n                        comm_data_demand.reach_dst = True\n                        comm_data_demand.delay = comm_data_demand.time_from_generated\n                        break  # \u76ee\u7684\u5730\u306b\u5230\u9054\u3057\u305f\u5834\u5408\u306f\u3001\u6b21\u306e\u901a\u4fe1\u30c7\u30fc\u30bf\u306b\u79fb\u308b\n\n                    # \u73fe\u5728\u306e\u4f4d\u7f6e\u304c\u76ee\u7684\u5730\u3067\u306a\u3044\u5834\u5408\n                    # \u73fe\u5728\u4f4d\u7f6e\u306b\u7559\u307e\u308b\u6b8b\u6642\u9593\u306e\u66f4\u65b0\n                    # TODO(Takashima): \u5b9f\u969b\u306b\u306fBuffer\u306b\u5165\u308c\u305f\u308a\u3059\u308b\u306e\u3067\u305d\u306e\u51e6\u7406\u3092\u691c\u8a0e\n                    # -&gt; \u624b\u8a08\u7b97\u3067\u306f, forwarding rate \u304c10Gbps\u306e\u5834\u5408 Queuing Delay\u306f10-100\u03bcs\u306b\u306a\u308a\u305d\u3046\u3067\u5c0f\u3055\u3044\n                    comm_data_demand.time_remaining_for_current_position += _graph.nodes[\n                        comm_data_demand.current_position\n                    ][\"delay\"]\n                    comm_data_demand.time_from_generated += _graph.nodes[comm_data_demand.current_position][\"delay\"]\n\n                    # \u30eb\u30fc\u30c6\u30a3\u30f3\u30b0\u30c6\u30fc\u30d6\u30eb\u306e\u53c2\u7167\n                    next_node = calc_next_node_from_node_knowledge(\n                        node_knowledge=self.node_knowledge_known_by_each_node[comm_data_demand.current_position],\n                        dst_node=comm_data_demand.dst_node,\n                        path=comm_data_demand.path,\n                        current_time=current_time,\n                        enable_random_routing_when_edge_failure=enable_random_routing_when_edge_failure,\n                        prevent_loop=prevent_loop,\n                    )\n                    if next_node is None:\n                        comm_data_demand.packet_loss = True\n                        comm_data_demand.delay = np.inf\n                        break\n                    comm_data_demand.next_node = next_node\n\n        ## Save the graph to the list of graphs after simulation for each time step ================================\n        all_graphs_after_simulation.append(_graph)\n\n    ## Save simulation results ========================================\n    # \u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u7d50\u679c\u306e\u7d71\u8a08\u3092\u30ed\u30b0\u51fa\u529b\n    total_demand_packets = len(comm_data_demand_list)\n    successful_demand_packets = sum(1 for comm in comm_data_demand_list if comm.reach_dst)\n    packet_loss_demand_packets = sum(1 for comm in comm_data_demand_list if comm.packet_loss)\n\n    total_lsa_packets = len(comm_data_lsa_list)\n    successful_lsa_packets = sum(1 for comm in comm_data_lsa_list if comm.reach_dst)\n    packet_loss_lsa_packets = sum(1 for comm in comm_data_lsa_list if comm.packet_loss)\n\n    logger.info(\"Simulation completed\")\n    logger.info(\n        f\"Demand packets - Total: {total_demand_packets}, \"\n        f\"Successful: {successful_demand_packets}, \"\n        f\"Lost: {packet_loss_demand_packets}\",\n    )\n    logger.info(\n        f\"LSA packets - Total: {total_lsa_packets}, \"\n        f\"Successful: {successful_lsa_packets}, \"\n        f\"Lost: {packet_loss_lsa_packets}\",\n    )\n\n    if successful_demand_packets &gt; 0:\n        avg_delay_demand = np.mean([comm.delay for comm in comm_data_demand_list if comm.reach_dst])\n        logger.info(f\"Average delay for successful demand packets: {avg_delay_demand:.6f}s\")\n\n    return PacketRoutingResult(\n        all_graphs_after_simulation=all_graphs_after_simulation,\n        comm_data_demand_list=comm_data_demand_list,\n        comm_data_lsa_list=comm_data_lsa_list,\n        node_knowledge_known_by_each_node=self.node_knowledge_known_by_each_node,\n    )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/space_time_graph/","title":"space_time_graph","text":""},{"location":"reference/cosmica/experimental_packet_routing/space_time_graph/#cosmica.experimental_packet_routing.space_time_graph","title":"cosmica.experimental_packet_routing.space_time_graph","text":""},{"location":"reference/cosmica/experimental_packet_routing/space_time_graph/#cosmica.experimental_packet_routing.space_time_graph.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['SpaceTimeGraph']\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/space_time_graph/#cosmica.experimental_packet_routing.space_time_graph.SpaceTimeGraph","title":"SpaceTimeGraph  <code>dataclass</code>","text":"<pre><code>SpaceTimeGraph(\n    time_for_snapshots: list[datetime64],\n    graph_for_snapshots: list[Graph],\n)\n</code></pre> <p>Base model for a space time graph.</p> Source code in <code>src/cosmica/experimental_packet_routing/space_time_graph.py</code> <pre><code>def __init__(\n    self,\n    time_for_snapshots: list[np.datetime64],\n    graph_for_snapshots: list[Graph],\n) -&gt; None:\n    self.time_for_snapshots = time_for_snapshots\n    self.graph_for_snapshots = graph_for_snapshots\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/space_time_graph/#cosmica.experimental_packet_routing.space_time_graph.SpaceTimeGraph.graph_for_snapshots","title":"graph_for_snapshots  <code>instance-attribute</code>","text":"<pre><code>graph_for_snapshots: list[Graph] = graph_for_snapshots\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/space_time_graph/#cosmica.experimental_packet_routing.space_time_graph.SpaceTimeGraph.time_for_snapshots","title":"time_for_snapshots  <code>instance-attribute</code>","text":"<pre><code>time_for_snapshots: list[datetime64] = time_for_snapshots\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/space_time_graph/#cosmica.experimental_packet_routing.space_time_graph.SpaceTimeGraph.get_space_time_graph_at_time","title":"get_space_time_graph_at_time","text":"<pre><code>get_space_time_graph_at_time(time: datetime64) -&gt; Graph\n</code></pre> <p>Get the space time graph at the specified time.</p> Source code in <code>src/cosmica/experimental_packet_routing/space_time_graph.py</code> <pre><code>def get_space_time_graph_at_time(self, time: np.datetime64) -&gt; Graph:\n    \"\"\"Get the space time graph at the specified time.\"\"\"\n    closest_snapshot_index: int = max(i for i, _time in enumerate(self.time_for_snapshots) if _time &lt;= time)\n    return self.graph_for_snapshots[closest_snapshot_index]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/space_time_graph/#cosmica.experimental_packet_routing.space_time_graph.SpaceTimeGraph.make_space_time_graph_from_graph","title":"make_space_time_graph_from_graph  <code>classmethod</code>","text":"<pre><code>make_space_time_graph_from_graph(\n    time: NDArray[datetime64],\n    graphs: list[Graph],\n    *,\n    check_interval_time: timedelta64 | None = None\n) -&gt; Self\n</code></pre> <p>Update time and graph lists if the graph shape changes.</p> Source code in <code>src/cosmica/experimental_packet_routing/space_time_graph.py</code> <pre><code>@classmethod\ndef make_space_time_graph_from_graph(  # noqa: C901, PLR0912\n    cls,\n    time: npt.NDArray[np.datetime64],\n    graphs: list[Graph],\n    *,\n    check_interval_time: np.timedelta64 | None = None,\n) -&gt; Self:\n    \"\"\"Update time and graph lists if the graph shape changes.\"\"\"\n    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    if check_interval_time is None:\n        # Old behaviour (unchanged) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        time_for_snapshots: list[np.datetime64] = [time[0]]\n        graph_for_snapshots: list[Graph] = [copy.deepcopy(graphs[0])]\n        for _time, _graph in tqdm(zip(time[1:], graphs[1:], strict=False), total=len(time) - 1):\n            if not nx.is_isomorphic(_graph, graph_for_snapshots[-1]):\n                time_for_snapshots.append(_time)\n                graph_for_snapshots.append(copy.deepcopy(_graph))\n        return cls(\n            time_for_snapshots=time_for_snapshots,\n            graph_for_snapshots=graph_for_snapshots,\n        )\n\n    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    # New t-second aggregation logic\n    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    start, stop = time[0], time[-1]\n    # Interval boundaries: t, 2t, \u2026, \u2264 stop\n    boundaries: npt.NDArray[np.datetime64] = np.arange(\n        start,\n        stop + check_interval_time,\n        check_interval_time,\n    )\n\n    time_for_snapshots = []\n    graph_for_snapshots = []\n\n    for boundary in tqdm(boundaries, total=len(boundaries)):\n        # \u2500\u2500 indices for past / future windows \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        past_mask = (time &gt; boundary - check_interval_time) &amp; (time &lt;= boundary)\n        future_mask = (time &gt; boundary) &amp; (time &lt; boundary + check_interval_time)\n\n        if not past_mask.any() and not future_mask.any():\n            continue  # no information\n\n        past_idx = np.where(past_mask)[0]\n        future_idx = np.where(future_mask)[0]\n\n        # \u2500\u2500 graph defined exactly at (or just before) boundary \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        idx_boundary = max(0, int(np.searchsorted(time, boundary, side=\"right\")) - 1)\n        graph_at_boundary = copy.deepcopy(graphs[idx_boundary])\n\n        # \u2500\u2500 \u2460 add every edge that ever appeared in the past window \u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        edges_past = set().union(*(graphs[i].edges() for i in past_idx)) if past_idx.size else set()\n        for u, v in edges_past:\n            if not has_edge_bidirectional(graph_at_boundary, u, v):\n                last_i = max(i for i in past_idx if has_edge_bidirectional(graphs[i], u, v))\n                # Find the actual edge direction that exists\n                if graphs[last_i].has_edge(u, v):\n                    graph_at_boundary.add_edge(u, v, **graphs[last_i].edges[u, v])\n                else:\n                    graph_at_boundary.add_edge(u, v, **graphs[last_i].edges[v, u])\n\n        # \u2500\u2500 \u2461 remove edges that will disappear in the coming interval \u2500\u2500\u2500\u2500\n        if future_idx.size:\n            stable_future = set.intersection(*(set(graphs[i].edges()) for i in future_idx))\n            for u, v in list(graph_at_boundary.edges()):\n                if (u, v) not in stable_future and (v, u) not in stable_future:\n                    remove_edge_safe(graph_at_boundary, u, v)\n\n        # \u2500\u2500 \u2462 overwrite attributes with those at the mid-point (n+\u00bd)t \u2500\u2500\u2500\n        half = check_interval_time // np.int64(2)\n        mid_time = boundary + half  # (n+\u00bd)t\n        mid_i = min(len(time) - 1, int(np.searchsorted(time, mid_time, side=\"left\")))\n        graph_at_midpoint = graphs[mid_i]\n\n        for node, data in graph_at_midpoint.nodes(data=True):\n            if graph_at_boundary.has_node(node):\n                graph_at_boundary.nodes[node].update(data)\n\n        for u, v, data in graph_at_midpoint.edges(data=True):\n            if has_edge_bidirectional(graph_at_boundary, u, v):\n                # Update the edge that actually exists in the boundary graph\n                if graph_at_boundary.has_edge(u, v):\n                    graph_at_boundary.edges[u, v].update(data)\n                else:\n                    graph_at_boundary.edges[v, u].update(data)\n\n        # \u2500\u2500 \u2463 recompute weights (edge delay + max node delay) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        for u, v, d in graph_at_boundary.edges(data=True):\n            edge_delay = d.get(\"delay\", 0)\n            node_delay = max(graph_at_boundary.nodes[u].get(\"delay\", 0), graph_at_boundary.nodes[v].get(\"delay\", 0))\n            graph_at_boundary.edges[u, v][\"weight\"] = edge_delay + node_delay\n        for n in graph_at_boundary.nodes:\n            graph_at_boundary.nodes[n][\"weight\"] = graph_at_boundary.nodes[n].get(\"delay\", 0)\n\n        # \u2500\u2500 \u2464 store snapshot, skipping duplicates \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        if (not graph_for_snapshots) or (not nx.is_isomorphic(graph_at_boundary, graph_for_snapshots[-1])):\n            time_for_snapshots.append(boundary)\n            graph_for_snapshots.append(graph_at_boundary)\n\n    return cls(\n        time_for_snapshots=time_for_snapshots,\n        graph_for_snapshots=graph_for_snapshots,\n    )\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/space_time_graph/#cosmica.experimental_packet_routing.space_time_graph.SpaceTimeGraph.update_space_time_graph_for_failure_edge","title":"update_space_time_graph_for_failure_edge","text":"<pre><code>update_space_time_graph_for_failure_edge(\n    failure_edge: tuple[Node, Node], update_time: datetime64\n) -&gt; Self\n</code></pre> <p>Update the space time graph for the failure edge.</p> Source code in <code>src/cosmica/experimental_packet_routing/space_time_graph.py</code> <pre><code>def update_space_time_graph_for_failure_edge(\n    self,\n    failure_edge: tuple[Node, Node],\n    update_time: np.datetime64,\n) -&gt; Self:\n    \"\"\"Update the space time graph for the failure edge.\"\"\"\n    # Find the index of the closest time snapshot before or at graph_update_time\n    closest_snapshot_index: int = max(i for i, time in enumerate(self.time_for_snapshots) if time &lt;= update_time)\n\n    # If the closest snapshot is the last snapshot, add a new snapshot\n    if closest_snapshot_index == len(self.time_for_snapshots) - 1:\n        graph: Graph = copy.deepcopy(self.graph_for_snapshots[closest_snapshot_index])\n        if remove_edge_safe(graph, *failure_edge):\n            self.time_for_snapshots.append(update_time)\n            self.graph_for_snapshots.append(graph)\n\n    else:\n        for i in range(closest_snapshot_index + 1, len(self.time_for_snapshots)):\n            graph = self.graph_for_snapshots[i]\n            remove_edge_safe(graph, *failure_edge)\n\n        graph = copy.deepcopy(self.graph_for_snapshots[closest_snapshot_index])\n        if remove_edge_safe(graph, *failure_edge):\n            self.time_for_snapshots.insert(closest_snapshot_index + 1, update_time)\n            self.graph_for_snapshots.insert(closest_snapshot_index + 1, graph)\n\n    return self\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/use_node_knowledge/","title":"use_node_knowledge","text":""},{"location":"reference/cosmica/experimental_packet_routing/use_node_knowledge/#cosmica.experimental_packet_routing.use_node_knowledge","title":"cosmica.experimental_packet_routing.use_node_knowledge","text":""},{"location":"reference/cosmica/experimental_packet_routing/use_node_knowledge/#cosmica.experimental_packet_routing.use_node_knowledge.calc_next_node_from_node_knowledge","title":"calc_next_node_from_node_knowledge","text":"<pre><code>calc_next_node_from_node_knowledge(\n    node_knowledge: NodeKnowledge,\n    dst_node: Node,\n    path: list[Node],\n    current_time: datetime64,\n    *,\n    enable_random_routing_when_edge_failure: bool = False,\n    prevent_loop: bool = False\n) -&gt; Node | None\n</code></pre> <p>Calculate the next node from the network information.</p> Source code in <code>src/cosmica/experimental_packet_routing/use_node_knowledge.py</code> <pre><code>def calc_next_node_from_node_knowledge(  # noqa: C901, PLR0912, PLR0915\n    node_knowledge: NodeKnowledge,\n    dst_node: Node,\n    path: list[Node],\n    current_time: np.datetime64,\n    *,\n    enable_random_routing_when_edge_failure: bool = False,\n    prevent_loop: bool = False,\n) -&gt; Node | None:\n    \"\"\"Calculate the next node from the network information.\"\"\"\n    rng: np.random.Generator = np.random.default_rng()\n\n    # Step 1: Find the index of the closest time snapshot before or at current_time\n    time_index = max(\n        i for i, time in enumerate(node_knowledge.forwarding_table_time_list.time_for_snapshots) if time &lt;= current_time\n    )\n\n    # Step 2: Select the forwarding table\n    do_backup: bool = False\n\n    # Use the nominal forwarding table for the identified time snapshot\n    forwarding_table: ForwardingTable = (\n        node_knowledge.forwarding_table_time_list.nominal_forwarding_table_for_snapshots[time_index]\n    )\n\n    # TODO(Takashima): 3\u3064\u4ee5\u4e0a\u306e\u30ea\u30f3\u30af\u5207\u65ad\u30d0\u30c3\u30af\u30a2\u30c3\u30d7\u306e\u51e6\u7406\u3092\u691c\u8a0e\u3059\u308b\n\n    # Backup forwarding tables (both single and dual) are used when the routing recalculation period is active\n    if node_knowledge.forwarding_table_time_list.backup_forwarding_tables_for_snapshots:\n        backup_forwarding_tables: dict[frozenset[frozenset[Node]], ForwardingTable] = (\n            node_knowledge.forwarding_table_time_list.backup_forwarding_tables_for_snapshots[time_index]\n        )\n        if any(start &lt;= current_time &lt;= end for start, end in node_knowledge.routing_recalculation_period):\n            # Dual link backup forwarding tables\n            dual_backup_forwarding_table_candidates: dict[frozenset[frozenset[Node]], ForwardingTable] = {}\n\n            for failure_assumed_edges, backup_table in backup_forwarding_tables.items():\n                if len(failure_assumed_edges) == 2:  # Dual backup case\n                    # frozenset\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u306e\u3067\u3001\u96c6\u5408\u6f14\u7b97\u3067\u76f4\u63a5\u6bd4\u8f03\u53ef\u80fd\n                    failure_edge_frozensets = {frozenset([u, v]) for u, v in node_knowledge.failure_assumed_edge_list}\n                    if failure_assumed_edges.issubset(failure_edge_frozensets):\n                        dual_backup_forwarding_table_candidates[failure_assumed_edges] = backup_table\n\n            # TODO(Takashima): \u5019\u88dc\u304c\u8907\u6570\u3042\u308b\u5834\u5408\u306e\u51e6\u7406\u306b\u3064\u3044\u3066\u306f\u3001\u3082\u3046\u5c11\u3057\u691c\u8a0e\u3059\u308b\n            if len(dual_backup_forwarding_table_candidates) == 0:\n                pass\n            elif len(dual_backup_forwarding_table_candidates) == 1:\n                forwarding_table = next(iter(dual_backup_forwarding_table_candidates.values()))\n                do_backup = True\n            elif len(dual_backup_forwarding_table_candidates) &gt; 1:\n                pass\n\n        # Single link backup forwarding tables are used when the routing recalculation period is active\n        if any(start &lt;= current_time &lt;= end for start, end in node_knowledge.routing_recalculation_period):\n            # TODO(Takashima): \u8907\u6570\u306e\u540c\u6642\u30ea\u30f3\u30af\u5207\u65ad\u3078\u306e\u5bfe\u5fdc\u65b9\u6cd5\u306f\u8272\u3005\u3042\u308b\u306e\u3067\u691c\u8a0e\u3059\u308b\n            single_backup_forwarding_table_candidates: dict[frozenset[frozenset[Node]], ForwardingTable] = {}\n            # TODO(Takashima): \u30a8\u30c3\u30b8\u3092\u63a2\u3059\u3068\u304d\u306b\u3001frozenset\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u305f\u3081\u9806\u5e8f\u3092\u6c17\u306b\u3059\u308b\u5fc5\u8981\u306f\u306a\u3044\n            for edge_key, backup_table in backup_forwarding_tables.items():\n                if len(edge_key) == 1:  # Single edge failure\n                    edge_set = next(iter(edge_key))  # Get the single edge frozenset\n                    # frozenset\u306a\u306e\u3067\u9806\u5e8f\u3092\u6c17\u306b\u305b\u305a\u306b\u76f4\u63a5\u6bd4\u8f03\u53ef\u80fd\n                    failure_edge_frozensets = {frozenset([u, v]) for u, v in node_knowledge.failure_assumed_edge_list}\n                    if edge_set in failure_edge_frozensets:\n                        single_backup_forwarding_table_candidates[edge_key] = backup_table\n\n            # TODO(Takashima): \u5019\u88dc\u304c\u8907\u6570\u3042\u308b\u5834\u5408\u306e\u51e6\u7406\u306b\u3064\u3044\u3066\u306f\u3001\u3082\u3046\u5c11\u3057\u691c\u8a0e\u3059\u308b\n            if len(single_backup_forwarding_table_candidates) == 0:\n                pass\n            elif len(single_backup_forwarding_table_candidates) == 1:\n                forwarding_table = next(iter(single_backup_forwarding_table_candidates.values()))\n                do_backup = True\n            elif len(single_backup_forwarding_table_candidates) &gt; 1:\n                # # \u3059\u3079\u3066\u306e\u30d0\u30c3\u30af\u30a2\u30c3\u30d7\u30d5\u30a9\u30ef\u30fc\u30c7\u30a3\u30f3\u30b0\u30c6\u30fc\u30d6\u30eb\u306e\u6b21\u5b9b\u5148\u304c\u540c\u3058\u5834\u5408\u306f\u3001\u30d0\u30c3\u30af\u30a2\u30c3\u30d7\u30d5\u30a9\u30ef\u30fc\u30c7\u30a3\u30f3\u30b0\u30c6\u30fc\u30d6\u30eb\u306e\u3044\u305a\u308c\u304b\u3092\u9078\u629e\u3059\u308b  # noqa: E501\n                # if all(\n                #     forwarding_table_candidate.find_entry(dst_node).next_node\n                #     == next(iter(forwarding_table_candidates.values())).find_entry(dst_node).next_node\n                #     for forwarding_table_candidate in forwarding_table_candidates.values()\n                # ):\n                #     forwarding_table = next(iter(forwarding_table_candidates.values()))\n                #     do_backup = True\n\n                # # (u,v)\u304c\u5730\u4e0a\u5c40-\u30b3\u30f3\u30b9\u30c6\u9593\u306e\u30a8\u30c3\u30b8\u306e\u5834\u5408\u306f\u3001\u305d\u306e\u30a8\u30f3\u30c8\u30ea\u3092\u9078\u629e\u3059\u308b\n                # for (u, v), forwarding_table_candidate in forwarding_table_candidates.items():\n                #     if (isinstance(u, Gateway) and isinstance(v, ConstellationSatellite)) or (\n                #         isinstance(v, Gateway) and isinstance(u, ConstellationSatellite)\n                #     ):\n                #         forwarding_table = forwarding_table_candidate\n                #         do_backup = True\n                #         break\n                pass\n\n        # \u30eb\u30fc\u30d7\u3092\u9632\u3050\u305f\u3081\u306b\u3001\u76f4\u524d\u306b\u901a\u3063\u305f\u30a8\u30c3\u30b8\u306e\u30d0\u30c3\u30af\u30a2\u30c3\u30d7\u30c6\u30fc\u30d6\u30eb\u3092\u4fdd\u6301\u3057\u3066\u3044\u308b\u5834\u5408\u306f\u3001\u305d\u306e\u30a8\u30c3\u30b8\u306e\u30d0\u30c3\u30af\u30a2\u30c3\u30d7\u30d5\u30a9\u30ef\u30fc\u30c7\u30a3\u30f3\u30b0\u30c6\u30fc\u30d6\u30eb\u3092\u4f7f\u7528\u3059\u308b  # noqa: E501\n        # \u305f\u3060\u3057\u30d0\u30c3\u30af\u30a2\u30c3\u30d7\u30d5\u30a9\u30ef\u30fc\u30c7\u30a3\u30f3\u30b0\u30c6\u30fc\u30d6\u30eb\u3092\u4f7f\u7528\u3059\u308b\u5834\u5408\u306f\u3001\u305d\u306e\u30d0\u30c3\u30af\u30a2\u30c3\u30d7\u30d5\u30a9\u30ef\u30fc\u30c7\u30a3\u30f3\u30b0\u30c6\u30fc\u30d6\u30eb\u306b\u5f93\u3046\n        if prevent_loop and (not do_backup) and (len(path) &gt;= 2):\n            # frozenset\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u306e\u3067\u9806\u5e8f\u3092\u6c17\u306b\u305b\u305a\u306b\u76f4\u63a5\u691c\u7d22\u53ef\u80fd\n            edge_key = frozenset([frozenset([path[-2], path[-1]])])\n\n            if edge_key in backup_forwarding_tables:\n                forwarding_table = backup_forwarding_tables[edge_key]\n\n    # Step 3: Find the forwarding entry for the destination node\n    forwarding_entry: ForwardingTableInformation | None = forwarding_table.find_entry(dst_node)\n\n    if forwarding_entry:\n        # Step 4: Return the next node for the destination\n        # If random routing is enabled, return a random next node from the list of next nodes\n        next_node: Node | None = forwarding_entry.next_node\n    else:\n        # If no forwarding entry is found, raise an exception or return random next node\n        msg: str = f\"No forwarding entry found for destination node {dst_node}\"\n        warnings.warn(msg, stacklevel=2)\n        next_node = None\n\n    # \u30ea\u30f3\u30af\u5207\u65ad\u6642\u306b\u30e9\u30f3\u30c0\u30e0\u306bnext node\u3092\u9078\u629e\u3059\u308b\n    # (\u30a8\u30c3\u30b8\u304c\u5207\u65ad\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u77e5\u3063\u3066\u3044\u308b\u304c, \u30d5\u30a9\u30ef\u30fc\u30c7\u30a3\u30f3\u30b0\u30c6\u30fc\u30d6\u30eb\u306b\u306f\u53cd\u6620\u3055\u308c\u3066\u3044\u306a\u3044\u5834\u5408)\n    if enable_random_routing_when_edge_failure:\n        graph: Graph = node_knowledge.space_time_graph.graph_for_snapshots[time_index]\n        src_node: Node = node_knowledge.target_node\n        neighbor_nodes = list(graph.neighbors(src_node))\n        if next_node is None or (\n            {(src_node, next_node), (next_node, src_node)} &amp; set(node_knowledge.failure_assumed_edge_list)\n        ):\n            next_node = rng.choice(neighbor_nodes)\n\n    # next_node\u304c\u904e\u53bb\u901a\u3063\u3066\u304d\u305f\u30d1\u30b9\u306b\u542b\u307e\u308c\u308b\u5834\u5408\u306b\u3001\u30d1\u30b9\u306b\u542b\u307e\u308c\u306a\u3044\u96a3\u63a5\u30ce\u30fc\u30c9\u3092\u30e9\u30f3\u30c0\u30e0\u306b\u9078\u629e\u3059\u308b\n    # \u96a3\u63a5\u306e\u5168\u3066\u306e\u30ce\u30fc\u30c9\u304c\u904e\u53bb\u901a\u3063\u3066\u304d\u305f\u30d1\u30b9\u306b\u542b\u307e\u308c\u308b\u5834\u5408\u306f\u3001\u30e9\u30f3\u30c0\u30e0\u306b\u9078\u629e\u3059\u308b\n    if prevent_loop and (not do_backup) and (next_node in path):\n        graph = node_knowledge.space_time_graph.graph_for_snapshots[time_index]\n        src_node = node_knowledge.target_node\n        neighbor_nodes = list(graph.neighbors(src_node))\n        if all(node in path for node in neighbor_nodes):\n            next_node = rng.choice(neighbor_nodes)\n        else:\n            remain_neighbor_nodes: list = [node for node in neighbor_nodes if node not in path]\n            next_node = rng.choice(remain_neighbor_nodes)\n\n    return next_node\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/utility/","title":"utility","text":""},{"location":"reference/cosmica/experimental_packet_routing/utility/#cosmica.experimental_packet_routing.utility","title":"cosmica.experimental_packet_routing.utility","text":"<p>Utility functions for experimental packet routing.</p>"},{"location":"reference/cosmica/experimental_packet_routing/utility/#cosmica.experimental_packet_routing.utility.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"get_edge_data\",\n    \"has_edge_bidirectional\",\n    \"remove_edge_safe\",\n]\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/utility/#cosmica.experimental_packet_routing.utility.get_edge_data","title":"get_edge_data","text":"<pre><code>get_edge_data(\n    graph: Graph, u: Node, v: Node\n) -&gt; dict | None\n</code></pre> <p>Get edge data for either direction (u,v) or (v,u).</p> Source code in <code>src/cosmica/experimental_packet_routing/utility.py</code> <pre><code>def get_edge_data(graph: Graph, u: Node, v: Node) -&gt; dict | None:\n    \"\"\"Get edge data for either direction (u,v) or (v,u).\"\"\"\n    if graph.has_edge(u, v):\n        return graph.edges[u, v]\n    elif graph.has_edge(v, u):\n        return graph.edges[v, u]\n    return None\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/utility/#cosmica.experimental_packet_routing.utility.has_edge_bidirectional","title":"has_edge_bidirectional","text":"<pre><code>has_edge_bidirectional(\n    graph: Graph, u: Node, v: Node\n) -&gt; bool\n</code></pre> <p>Check if edge exists in either direction (u,v) or (v,u).</p> Source code in <code>src/cosmica/experimental_packet_routing/utility.py</code> <pre><code>def has_edge_bidirectional(graph: Graph, u: Node, v: Node) -&gt; bool:\n    \"\"\"Check if edge exists in either direction (u,v) or (v,u).\"\"\"\n    return graph.has_edge(u, v) or graph.has_edge(v, u)\n</code></pre>"},{"location":"reference/cosmica/experimental_packet_routing/utility/#cosmica.experimental_packet_routing.utility.remove_edge_safe","title":"remove_edge_safe","text":"<pre><code>remove_edge_safe(graph: Graph, u: Node, v: Node) -&gt; bool\n</code></pre> <p>Safely remove edge in either direction. Returns True if edge was removed.</p> Source code in <code>src/cosmica/experimental_packet_routing/utility.py</code> <pre><code>def remove_edge_safe(graph: Graph, u: Node, v: Node) -&gt; bool:\n    \"\"\"Safely remove edge in either direction. Returns True if edge was removed.\"\"\"\n    if graph.has_edge(u, v):\n        graph.remove_edge(u, v)\n        return True\n    elif graph.has_edge(v, u):\n        graph.remove_edge(v, u)\n        return True\n    return False\n</code></pre>"},{"location":"reference/cosmica/models/","title":"models","text":""},{"location":"reference/cosmica/models/#cosmica.models","title":"cosmica.models","text":""},{"location":"reference/cosmica/models/#cosmica.models.NodeGID","title":"NodeGID  <code>module-attribute</code>","text":"<pre><code>NodeGID = NewType('NodeGID', str)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"CircularSatelliteOrbitModel\",\n    \"CommunicationTerminal\",\n    \"ConstantCommunicationDemand\",\n    \"ConstellationSatellite\",\n    \"Demand\",\n    \"EllipticalSatelliteOrbitModel\",\n    \"Gateway\",\n    \"GatewayOGS\",\n    \"GravityModel\",\n    \"Internet\",\n    \"Node\",\n    \"NodeGID\",\n    \"OneTimeCommunicationDemand\",\n    \"OpticalCommunicationTerminal\",\n    \"RFCommunicationTerminal\",\n    \"Satellite\",\n    \"SatelliteTerminal\",\n    \"Scenario\",\n    \"StationaryOnGroundUser\",\n    \"User\",\n    \"UserOpticalCommunicationTerminal\",\n    \"UserSatellite\",\n    \"load_demands_from_toml_file\",\n    \"load_users_from_toml_file\",\n]\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.CircularSatelliteOrbitModel","title":"CircularSatelliteOrbitModel","text":"<p>               Bases: <code>SatelliteOrbitModel</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.CircularSatelliteOrbitModel.epoch","title":"epoch  <code>instance-attribute</code>","text":"<pre><code>epoch: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.CircularSatelliteOrbitModel.inclination","title":"inclination  <code>instance-attribute</code>","text":"<pre><code>inclination: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.CircularSatelliteOrbitModel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.CircularSatelliteOrbitModel.phase_at_epoch","title":"phase_at_epoch  <code>instance-attribute</code>","text":"<pre><code>phase_at_epoch: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.CircularSatelliteOrbitModel.raan","title":"raan  <code>instance-attribute</code>","text":"<pre><code>raan: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.CircularSatelliteOrbitModel.semi_major_axis","title":"semi_major_axis  <code>instance-attribute</code>","text":"<pre><code>semi_major_axis: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.CommunicationTerminal","title":"CommunicationTerminal  <code>dataclass</code>","text":"<pre><code>CommunicationTerminal(*, id: T)\n</code></pre> <p>               Bases: <code>Node[T]</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.CommunicationTerminal.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.CommunicationTerminal.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.CommunicationTerminal.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.CommunicationTerminal.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/terminal.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"CT\"\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.ConstantCommunicationDemand","title":"ConstantCommunicationDemand  <code>dataclass</code>","text":"<pre><code>ConstantCommunicationDemand(\n    *,\n    id: T,\n    source: NodeGID,\n    destination: NodeGID,\n    distribution: Literal[\"uniform\", \"poisson\"],\n    transmission_rate: float\n)\n</code></pre> <p>               Bases: <code>Demand[T]</code></p> <p>Constant communication demand model.</p>"},{"location":"reference/cosmica/models/#cosmica.models.ConstantCommunicationDemand.destination","title":"destination  <code>instance-attribute</code>","text":"<pre><code>destination: NodeGID\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.ConstantCommunicationDemand.distribution","title":"distribution  <code>instance-attribute</code>","text":"<pre><code>distribution: Literal['uniform', 'poisson']\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.ConstantCommunicationDemand.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.ConstantCommunicationDemand.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: NodeGID\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.ConstantCommunicationDemand.transmission_rate","title":"transmission_rate  <code>instance-attribute</code>","text":"<pre><code>transmission_rate: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.ConstantCommunicationDemand.parse_demand_item","title":"parse_demand_item  <code>classmethod</code>","text":"<pre><code>parse_demand_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_demand_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    return cls(\n        id=item[\"id\"],\n        source=item[\"src_gid\"],\n        destination=item[\"dst_gid\"],\n        transmission_rate=item[\"transmission_rate_bps\"],\n        distribution=item[\"distribution\"],\n    )\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.ConstellationSatellite","title":"ConstellationSatellite  <code>dataclass</code>","text":"<pre><code>ConstellationSatellite(\n    *, id: T, orbit: SatelliteOrbitModel | None = None\n)\n</code></pre> <p>               Bases: <code>Satellite[T]</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.ConstellationSatellite.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.ConstellationSatellite.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.ConstellationSatellite.orbit","title":"orbit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>orbit: SatelliteOrbitModel | None = None\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.ConstellationSatellite.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.ConstellationSatellite.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/satellite.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"CSAT\"\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Demand","title":"Demand  <code>dataclass</code>","text":"<pre><code>Demand(*, id: T)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base model for a demand.</p>"},{"location":"reference/cosmica/models/#cosmica.models.Demand.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Demand.parse_demand_item","title":"parse_demand_item  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>parse_demand_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> <p>Parse a demand item.</p> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>@classmethod\n@abstractmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_demand_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    \"\"\"Parse a demand item.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel","title":"EllipticalSatelliteOrbitModel","text":"<p>               Bases: <code>SatelliteOrbitModel</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.argpo","title":"argpo  <code>instance-attribute</code>","text":"<pre><code>argpo: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.drag_coeff","title":"drag_coeff  <code>instance-attribute</code>","text":"<pre><code>drag_coeff: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.eccentricity","title":"eccentricity  <code>instance-attribute</code>","text":"<pre><code>eccentricity: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.epoch","title":"epoch  <code>instance-attribute</code>","text":"<pre><code>epoch: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.gravity_model","title":"gravity_model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gravity_model: GravityModel = WGS84\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.inclination","title":"inclination  <code>instance-attribute</code>","text":"<pre><code>inclination: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.phase_at_epoch","title":"phase_at_epoch  <code>instance-attribute</code>","text":"<pre><code>phase_at_epoch: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.raan","title":"raan  <code>instance-attribute</code>","text":"<pre><code>raan: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.satnum","title":"satnum  <code>instance-attribute</code>","text":"<pre><code>satnum: int\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.EllipticalSatelliteOrbitModel.semi_major_axis","title":"semi_major_axis  <code>instance-attribute</code>","text":"<pre><code>semi_major_axis: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway","title":"Gateway  <code>dataclass</code>","text":"<pre><code>Gateway(\n    *,\n    id: T,\n    latitude: float,\n    longitude: float,\n    minimum_elevation: float,\n    altitude: float = 0.0,\n    n_terminals: int = 1\n)\n</code></pre> <p>               Bases: <code>Node[T]</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.altitude","title":"altitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>altitude: float = field(default=0.0, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.minimum_elevation","title":"minimum_elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minimum_elevation: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.n_terminals","title":"n_terminals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_terminals: int = field(default=1, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"GW\"\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.from_toml_file","title":"from_toml_file  <code>classmethod</code>","text":"<pre><code>from_toml_file(toml_file_path: Path | str) -&gt; list[Self]\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef from_toml_file(cls, toml_file_path: Path | str) -&gt; list[Self]:\n    toml_file_path = Path(toml_file_path)\n    with toml_file_path.open(\"rb\") as f:\n        toml_data = tomllib.load(f)\n    return list(map(cls.parse_gateway_item, toml_data[\"gateways\"]))\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Gateway.parse_gateway_item","title":"parse_gateway_item  <code>classmethod</code>","text":"<pre><code>parse_gateway_item(item: MutableMapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_gateway_item(cls, item: MutableMapping[str, Any]) -&gt; Self:\n    item[\"latitude\"] = np.deg2rad(item.pop(\"lat_deg\"))\n    item[\"longitude\"] = np.deg2rad(item.pop(\"lon_deg\"))\n    item[\"minimum_elevation\"] = np.deg2rad(item.pop(\"min_el_deg\"))\n    return cls(**item)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS","title":"GatewayOGS  <code>dataclass</code>","text":"<pre><code>GatewayOGS(\n    *,\n    id: T,\n    latitude: float,\n    longitude: float,\n    minimum_elevation: float,\n    altitude: float = 0.0,\n    n_terminals: int = 1,\n    aperture_size: float = 1.0,\n    rytov_variance: float = 0.5\n)\n</code></pre> <p>               Bases: <code>Node[T]</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.altitude","title":"altitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>altitude: float = field(default=0.0, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.aperture_size","title":"aperture_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aperture_size: float = field(default=1.0, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.minimum_elevation","title":"minimum_elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minimum_elevation: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.n_terminals","title":"n_terminals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_terminals: int = field(default=1, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.rytov_variance","title":"rytov_variance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rytov_variance: float = field(default=0.5, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"GW_OGS\"\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.from_toml_file","title":"from_toml_file  <code>classmethod</code>","text":"<pre><code>from_toml_file(toml_file_path: Path | str) -&gt; list[Self]\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef from_toml_file(cls, toml_file_path: Path | str) -&gt; list[Self]:\n    toml_file_path = Path(toml_file_path)\n    with toml_file_path.open(\"rb\") as f:\n        toml_data = tomllib.load(f)\n    return list(map(cls.parse_gateway_item, toml_data[\"gateways\"]))\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GatewayOGS.parse_gateway_item","title":"parse_gateway_item  <code>classmethod</code>","text":"<pre><code>parse_gateway_item(item: MutableMapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_gateway_item(cls, item: MutableMapping[str, Any]) -&gt; Self:\n    item[\"latitude\"] = np.deg2rad(item.pop(\"lat_deg\"))\n    item[\"longitude\"] = np.deg2rad(item.pop(\"lon_deg\"))\n    item[\"minimum_elevation\"] = np.deg2rad(item.pop(\"min_el_deg\"))\n    item[\"aperture_size\"] = item.pop(\"aperture_size_m\")\n    item[\"rytov_variance\"] = item.pop(\"rytov_variance\")\n\n    return cls(**item)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GravityModel","title":"GravityModel","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.GravityModel.WGS72","title":"WGS72  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WGS72 = WGS72\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GravityModel.WGS72OLD","title":"WGS72OLD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WGS72OLD = WGS72OLD\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.GravityModel.WGS84","title":"WGS84  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WGS84 = WGS84\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Internet","title":"Internet  <code>dataclass</code>","text":"<pre><code>Internet(*, id: T | None = None)\n</code></pre> <p>               Bases: <code>Node[T | None]</code></p> <p>The Internet node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.Internet.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.Internet.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: T | None = None\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Internet.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Internet.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/internet.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"Internet\"\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Node","title":"Node  <code>dataclass</code>","text":"<pre><code>Node(*, id: T)\n</code></pre> <p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.Node.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.Node.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Node.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Node.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> <p>Class name as a string used for the key generation.</p> <p>Override this method if you want to use a different class name for the key generation.</p> Source code in <code>src/cosmica/models/node.py</code> <pre><code>@classmethod\ndef class_name(cls) -&gt; str:\n    \"\"\"Class name as a string used for the key generation.\n\n    Override this method if you want to use a different class name for the key generation.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OneTimeCommunicationDemand","title":"OneTimeCommunicationDemand  <code>dataclass</code>","text":"<pre><code>OneTimeCommunicationDemand(\n    *,\n    id: T,\n    source: NodeGID,\n    destination: NodeGID,\n    data_size: float,\n    generation_time: datetime64,\n    deadline: datetime64\n)\n</code></pre> <p>               Bases: <code>Demand[T]</code></p> <p>One-time communication demand model.</p> <p>This model is used for the communication demand to transfer a certain amount of data from a source to a destination. The data is generated at the source at a certain time and the communication demand is created at the same time. The time by which the data transfer should be completed is also given.</p>"},{"location":"reference/cosmica/models/#cosmica.models.OneTimeCommunicationDemand.data_size","title":"data_size  <code>instance-attribute</code>","text":"<pre><code>data_size: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OneTimeCommunicationDemand.deadline","title":"deadline  <code>instance-attribute</code>","text":"<pre><code>deadline: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OneTimeCommunicationDemand.destination","title":"destination  <code>instance-attribute</code>","text":"<pre><code>destination: NodeGID\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OneTimeCommunicationDemand.generation_time","title":"generation_time  <code>instance-attribute</code>","text":"<pre><code>generation_time: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OneTimeCommunicationDemand.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OneTimeCommunicationDemand.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: NodeGID\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OneTimeCommunicationDemand.parse_demand_item","title":"parse_demand_item  <code>classmethod</code>","text":"<pre><code>parse_demand_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_demand_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    return cls(\n        id=item[\"id\"],\n        source=item[\"src_gid\"],\n        destination=item[\"dst_gid\"],\n        data_size=item[\"data_size\"],\n        generation_time=item[\"generation_time\"],\n        deadline=item[\"deadline\"],\n    )\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OpticalCommunicationTerminal","title":"OpticalCommunicationTerminal  <code>dataclass</code>","text":"<pre><code>OpticalCommunicationTerminal(\n    *,\n    id: T,\n    azimuth_min: float,\n    azimuth_max: float,\n    elevation_min: float,\n    elevation_max: float,\n    angular_velocity_max: float\n)\n</code></pre> <p>               Bases: <code>CommunicationTerminal[T]</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.OpticalCommunicationTerminal.angular_velocity_max","title":"angular_velocity_max  <code>instance-attribute</code>","text":"<pre><code>angular_velocity_max: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OpticalCommunicationTerminal.azimuth_max","title":"azimuth_max  <code>instance-attribute</code>","text":"<pre><code>azimuth_max: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OpticalCommunicationTerminal.azimuth_min","title":"azimuth_min  <code>instance-attribute</code>","text":"<pre><code>azimuth_min: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OpticalCommunicationTerminal.elevation_max","title":"elevation_max  <code>instance-attribute</code>","text":"<pre><code>elevation_max: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OpticalCommunicationTerminal.elevation_min","title":"elevation_min  <code>instance-attribute</code>","text":"<pre><code>elevation_min: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OpticalCommunicationTerminal.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.OpticalCommunicationTerminal.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OpticalCommunicationTerminal.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.OpticalCommunicationTerminal.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/terminal.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"OCT\"\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.RFCommunicationTerminal","title":"RFCommunicationTerminal  <code>dataclass</code>","text":"<pre><code>RFCommunicationTerminal(*, id: T)\n</code></pre> <p>               Bases: <code>CommunicationTerminal[T]</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.RFCommunicationTerminal.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.RFCommunicationTerminal.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.RFCommunicationTerminal.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.RFCommunicationTerminal.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/terminal.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"RFCT\"\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Satellite","title":"Satellite  <code>dataclass</code>","text":"<pre><code>Satellite(*, id: T)\n</code></pre> <p>               Bases: <code>Node[T]</code>, <code>ABC</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.Satellite.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.Satellite.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Satellite.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Satellite.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> <p>Class name as a string used for the key generation.</p> <p>Override this method if you want to use a different class name for the key generation.</p> Source code in <code>src/cosmica/models/node.py</code> <pre><code>@classmethod\ndef class_name(cls) -&gt; str:\n    \"\"\"Class name as a string used for the key generation.\n\n    Override this method if you want to use a different class name for the key generation.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal","title":"SatelliteTerminal  <code>dataclass</code>","text":"<pre><code>SatelliteTerminal(\n    *,\n    id: T,\n    terminal_id: T,\n    azimuth_min: float,\n    azimuth_max: float,\n    elevation_min: float,\n    elevation_max: float,\n    angular_velocity_max: float\n)\n</code></pre> <p>               Bases: <code>Satellite[T]</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.angular_velocity_max","title":"angular_velocity_max  <code>instance-attribute</code>","text":"<pre><code>angular_velocity_max: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.azimuth_max","title":"azimuth_max  <code>instance-attribute</code>","text":"<pre><code>azimuth_max: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.azimuth_min","title":"azimuth_min  <code>instance-attribute</code>","text":"<pre><code>azimuth_min: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.elevation_max","title":"elevation_max  <code>instance-attribute</code>","text":"<pre><code>elevation_max: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.elevation_min","title":"elevation_min  <code>instance-attribute</code>","text":"<pre><code>elevation_min: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.terminal","title":"terminal  <code>property</code>","text":"<pre><code>terminal: OpticalCommunicationTerminal[T]\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.terminal_id","title":"terminal_id  <code>instance-attribute</code>","text":"<pre><code>terminal_id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.SatelliteTerminal.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> <p>Class name as a string used for the key generation.</p> <p>Override this method if you want to use a different class name for the key generation.</p> Source code in <code>src/cosmica/models/node.py</code> <pre><code>@classmethod\ndef class_name(cls) -&gt; str:\n    \"\"\"Class name as a string used for the key generation.\n\n    Override this method if you want to use a different class name for the key generation.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Scenario","title":"Scenario  <code>dataclass</code>","text":"<pre><code>Scenario(\n    *,\n    time: NDArray[datetime64],\n    gateways: list[Gateway] = list(),\n    users: list[User] = list(),\n    demands: list[Demand] = list()\n)\n</code></pre> <p>The simulation scenario.</p>"},{"location":"reference/cosmica/models/#cosmica.models.Scenario.demands","title":"demands  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>demands: list[Demand] = field(default_factory=list)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Scenario.gateways","title":"gateways  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gateways: list[Gateway] = field(default_factory=list)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Scenario.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: NDArray[datetime64]\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Scenario.users","title":"users  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>users: list[User] = field(default_factory=list)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.Scenario.build_topology","title":"build_topology","text":"<pre><code>build_topology() -&gt; None\n</code></pre> <p>Build the topology of the scenario.</p> Source code in <code>src/cosmica/models/scenario.py</code> <pre><code>def build_topology(self) -&gt; None:\n    \"\"\"Build the topology of the scenario.\"\"\"\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser","title":"StationaryOnGroundUser  <code>dataclass</code>","text":"<pre><code>StationaryOnGroundUser(\n    *,\n    id: T,\n    terminals: list[\n        CommunicationTerminal[Hashable]\n    ] = list(),\n    latitude: float,\n    longitude: float,\n    altitude: float = 0.0,\n    minimum_elevation: float\n)\n</code></pre> <p>               Bases: <code>User[T]</code></p> <p>Model for a stationary user on the ground.</p>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser.altitude","title":"altitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>altitude: float = field(default=0.0, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser.minimum_elevation","title":"minimum_elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minimum_elevation: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser.terminals","title":"terminals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>terminals: list[CommunicationTerminal[Hashable]] = field(\n    default_factory=list, compare=False\n)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> <p>Class name as a string used for the key generation.</p> <p>Override this method if you want to use a different class name for the key generation.</p> Source code in <code>src/cosmica/models/node.py</code> <pre><code>@classmethod\ndef class_name(cls) -&gt; str:\n    \"\"\"Class name as a string used for the key generation.\n\n    Override this method if you want to use a different class name for the key generation.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.StationaryOnGroundUser.parse_user_item","title":"parse_user_item  <code>classmethod</code>","text":"<pre><code>parse_user_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/user.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_user_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    return cls(\n        id=item[\"id\"],\n        latitude=np.deg2rad(item[\"lat_deg\"]),\n        longitude=np.deg2rad(item[\"lon_deg\"]),\n        altitude=item[\"alt_m\"],\n        minimum_elevation=np.deg2rad(item[\"min_el_deg\"]),\n    )\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.User","title":"User  <code>dataclass</code>","text":"<pre><code>User(\n    *,\n    id: T,\n    terminals: list[\n        CommunicationTerminal[Hashable]\n    ] = list()\n)\n</code></pre> <p>               Bases: <code>Node[T]</code>, <code>ABC</code></p> <p>Base model for a user.</p>"},{"location":"reference/cosmica/models/#cosmica.models.User.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.User.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.User.terminals","title":"terminals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>terminals: list[CommunicationTerminal[Hashable]] = field(\n    default_factory=list\n)\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.User.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.User.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> <p>Class name as a string used for the key generation.</p> <p>Override this method if you want to use a different class name for the key generation.</p> Source code in <code>src/cosmica/models/node.py</code> <pre><code>@classmethod\ndef class_name(cls) -&gt; str:\n    \"\"\"Class name as a string used for the key generation.\n\n    Override this method if you want to use a different class name for the key generation.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.User.parse_user_item","title":"parse_user_item  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>parse_user_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> <p>Parse a user item.</p> Source code in <code>src/cosmica/models/user.py</code> <pre><code>@classmethod\n@abstractmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_user_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    \"\"\"Parse a user item.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserOpticalCommunicationTerminal","title":"UserOpticalCommunicationTerminal  <code>dataclass</code>","text":"<pre><code>UserOpticalCommunicationTerminal(\n    *,\n    id: T,\n    azimuth_min: float,\n    azimuth_max: float,\n    elevation_min: float,\n    elevation_max: float,\n    angular_velocity_max: float\n)\n</code></pre> <p>               Bases: <code>OpticalCommunicationTerminal[T]</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.UserOpticalCommunicationTerminal.angular_velocity_max","title":"angular_velocity_max  <code>instance-attribute</code>","text":"<pre><code>angular_velocity_max: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserOpticalCommunicationTerminal.azimuth_max","title":"azimuth_max  <code>instance-attribute</code>","text":"<pre><code>azimuth_max: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserOpticalCommunicationTerminal.azimuth_min","title":"azimuth_min  <code>instance-attribute</code>","text":"<pre><code>azimuth_min: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserOpticalCommunicationTerminal.elevation_max","title":"elevation_max  <code>instance-attribute</code>","text":"<pre><code>elevation_max: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserOpticalCommunicationTerminal.elevation_min","title":"elevation_min  <code>instance-attribute</code>","text":"<pre><code>elevation_min: float\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserOpticalCommunicationTerminal.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.UserOpticalCommunicationTerminal.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserOpticalCommunicationTerminal.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserOpticalCommunicationTerminal.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/terminal.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"UOCT\"\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserSatellite","title":"UserSatellite  <code>dataclass</code>","text":"<pre><code>UserSatellite(*, id: T)\n</code></pre> <p>               Bases: <code>Satellite[T]</code></p>"},{"location":"reference/cosmica/models/#cosmica.models.UserSatellite.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/#cosmica.models.UserSatellite.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserSatellite.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.UserSatellite.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/satellite.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"USAT\"\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.load_demands_from_toml_file","title":"load_demands_from_toml_file","text":"<pre><code>load_demands_from_toml_file(\n    toml_file_path: str | Path,\n) -&gt; list[Demand[Hashable]]\n</code></pre> <p>Load demands from a TOML file.</p> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef load_demands_from_toml_file(toml_file_path: str | Path) -&gt; list[Demand[Hashable]]:\n    \"\"\"Load demands from a TOML file.\"\"\"\n    toml_file_path = Path(toml_file_path)\n    with toml_file_path.open(\"rb\") as f:\n        toml_data = tomllib.load(f)\n    return list(map(parse_demand_item, toml_data[\"demands\"]))\n</code></pre>"},{"location":"reference/cosmica/models/#cosmica.models.load_users_from_toml_file","title":"load_users_from_toml_file","text":"<pre><code>load_users_from_toml_file(\n    toml_file_path: str | Path,\n) -&gt; list[User[Hashable]]\n</code></pre> <p>Load users from a TOML file.</p> Source code in <code>src/cosmica/models/user.py</code> <pre><code>@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef load_users_from_toml_file(toml_file_path: str | Path) -&gt; list[User[Hashable]]:\n    \"\"\"Load users from a TOML file.\"\"\"\n    toml_file_path = Path(toml_file_path)\n    with toml_file_path.open(\"rb\") as f:\n        toml_data = tomllib.load(f)\n    return list(map(parse_user_item, toml_data[\"users\"]))\n</code></pre>"},{"location":"reference/cosmica/models/constellation/","title":"constellation","text":""},{"location":"reference/cosmica/models/constellation/#cosmica.models.constellation","title":"cosmica.models.constellation","text":""},{"location":"reference/cosmica/models/constellation/#cosmica.models.constellation.ConstellationModel","title":"ConstellationModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Constellation model.</p>"},{"location":"reference/cosmica/models/constellation/#cosmica.models.constellation.MultiOrbitalPlaneConstellationModel","title":"MultiOrbitalPlaneConstellationModel","text":"<p>               Bases: <code>ConstellationModel</code></p> <p>Multi-orbital plane constellation model.</p>"},{"location":"reference/cosmica/models/constellation/#cosmica.models.constellation.MultiOrbitalPlaneConstellationModel.epoch","title":"epoch  <code>instance-attribute</code>","text":"<pre><code>epoch: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/constellation/#cosmica.models.constellation.MultiOrbitalPlaneConstellationModel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"reference/cosmica/models/constellation/#cosmica.models.constellation.MultiOrbitalPlaneConstellationModel.satellites","title":"satellites  <code>instance-attribute</code>","text":"<pre><code>satellites: list[list[ConstellationSatellite]]\n</code></pre>"},{"location":"reference/cosmica/models/demand/","title":"demand","text":""},{"location":"reference/cosmica/models/demand/#cosmica.models.demand","title":"cosmica.models.demand","text":""},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"ConstantCommunicationDemand\",\n    \"Demand\",\n    \"OneTimeCommunicationDemand\",\n    \"load_demands_from_toml_file\",\n    \"parse_demand_item\",\n]\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.ConstantCommunicationDemand","title":"ConstantCommunicationDemand  <code>dataclass</code>","text":"<pre><code>ConstantCommunicationDemand(\n    *,\n    id: T,\n    source: NodeGID,\n    destination: NodeGID,\n    distribution: Literal[\"uniform\", \"poisson\"],\n    transmission_rate: float\n)\n</code></pre> <p>               Bases: <code>Demand[T]</code></p> <p>Constant communication demand model.</p>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.ConstantCommunicationDemand.destination","title":"destination  <code>instance-attribute</code>","text":"<pre><code>destination: NodeGID\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.ConstantCommunicationDemand.distribution","title":"distribution  <code>instance-attribute</code>","text":"<pre><code>distribution: Literal['uniform', 'poisson']\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.ConstantCommunicationDemand.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.ConstantCommunicationDemand.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: NodeGID\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.ConstantCommunicationDemand.transmission_rate","title":"transmission_rate  <code>instance-attribute</code>","text":"<pre><code>transmission_rate: float\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.ConstantCommunicationDemand.parse_demand_item","title":"parse_demand_item  <code>classmethod</code>","text":"<pre><code>parse_demand_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_demand_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    return cls(\n        id=item[\"id\"],\n        source=item[\"src_gid\"],\n        destination=item[\"dst_gid\"],\n        transmission_rate=item[\"transmission_rate_bps\"],\n        distribution=item[\"distribution\"],\n    )\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.Demand","title":"Demand  <code>dataclass</code>","text":"<pre><code>Demand(*, id: T)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base model for a demand.</p>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.Demand.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.Demand.parse_demand_item","title":"parse_demand_item  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>parse_demand_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> <p>Parse a demand item.</p> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>@classmethod\n@abstractmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_demand_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    \"\"\"Parse a demand item.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.OneTimeCommunicationDemand","title":"OneTimeCommunicationDemand  <code>dataclass</code>","text":"<pre><code>OneTimeCommunicationDemand(\n    *,\n    id: T,\n    source: NodeGID,\n    destination: NodeGID,\n    data_size: float,\n    generation_time: datetime64,\n    deadline: datetime64\n)\n</code></pre> <p>               Bases: <code>Demand[T]</code></p> <p>One-time communication demand model.</p> <p>This model is used for the communication demand to transfer a certain amount of data from a source to a destination. The data is generated at the source at a certain time and the communication demand is created at the same time. The time by which the data transfer should be completed is also given.</p>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.OneTimeCommunicationDemand.data_size","title":"data_size  <code>instance-attribute</code>","text":"<pre><code>data_size: float\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.OneTimeCommunicationDemand.deadline","title":"deadline  <code>instance-attribute</code>","text":"<pre><code>deadline: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.OneTimeCommunicationDemand.destination","title":"destination  <code>instance-attribute</code>","text":"<pre><code>destination: NodeGID\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.OneTimeCommunicationDemand.generation_time","title":"generation_time  <code>instance-attribute</code>","text":"<pre><code>generation_time: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.OneTimeCommunicationDemand.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.OneTimeCommunicationDemand.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: NodeGID\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.OneTimeCommunicationDemand.parse_demand_item","title":"parse_demand_item  <code>classmethod</code>","text":"<pre><code>parse_demand_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_demand_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    return cls(\n        id=item[\"id\"],\n        source=item[\"src_gid\"],\n        destination=item[\"dst_gid\"],\n        data_size=item[\"data_size\"],\n        generation_time=item[\"generation_time\"],\n        deadline=item[\"deadline\"],\n    )\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.TemporaryCommunicationDemand","title":"TemporaryCommunicationDemand  <code>dataclass</code>","text":"<pre><code>TemporaryCommunicationDemand(\n    *,\n    id: T,\n    source: NodeGID,\n    destination: NodeGID,\n    transmission_rate: float,\n    distribution: Literal[\"uniform\", \"poisson\"],\n    start_time: datetime64,\n    end_time: datetime64\n)\n</code></pre> <p>               Bases: <code>Demand[T]</code></p> <p>Temporary communication demand model.</p>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.TemporaryCommunicationDemand.destination","title":"destination  <code>instance-attribute</code>","text":"<pre><code>destination: NodeGID\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.TemporaryCommunicationDemand.distribution","title":"distribution  <code>instance-attribute</code>","text":"<pre><code>distribution: Literal['uniform', 'poisson']\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.TemporaryCommunicationDemand.end_time","title":"end_time  <code>instance-attribute</code>","text":"<pre><code>end_time: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.TemporaryCommunicationDemand.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.TemporaryCommunicationDemand.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: NodeGID\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.TemporaryCommunicationDemand.start_time","title":"start_time  <code>instance-attribute</code>","text":"<pre><code>start_time: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.TemporaryCommunicationDemand.transmission_rate","title":"transmission_rate  <code>instance-attribute</code>","text":"<pre><code>transmission_rate: float\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.TemporaryCommunicationDemand.is_active","title":"is_active","text":"<pre><code>is_active(current_time: datetime64) -&gt; bool\n</code></pre> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>def is_active(\n    self,\n    current_time: np.datetime64,\n) -&gt; np.bool:\n    return self.start_time &lt;= current_time &lt; self.end_time\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.TemporaryCommunicationDemand.parse_demand_item","title":"parse_demand_item  <code>classmethod</code>","text":"<pre><code>parse_demand_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_demand_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    return cls(\n        id=item[\"id\"],\n        source=item[\"src_gid\"],\n        destination=item[\"dst_gid\"],\n        transmission_rate=item[\"transmission_rate_bps\"],\n        distribution=item[\"distribution\"],\n        start_time=np.datetime64(item[\"start_time\"].astimezone(tz=UTC).replace(tzinfo=None)),\n        end_time=np.datetime64(item[\"end_time\"].astimezone(tz=UTC).replace(tzinfo=None)),\n    )\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.load_demands_from_toml_file","title":"load_demands_from_toml_file","text":"<pre><code>load_demands_from_toml_file(\n    toml_file_path: str | Path,\n) -&gt; list[Demand[Hashable]]\n</code></pre> <p>Load demands from a TOML file.</p> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef load_demands_from_toml_file(toml_file_path: str | Path) -&gt; list[Demand[Hashable]]:\n    \"\"\"Load demands from a TOML file.\"\"\"\n    toml_file_path = Path(toml_file_path)\n    with toml_file_path.open(\"rb\") as f:\n        toml_data = tomllib.load(f)\n    return list(map(parse_demand_item, toml_data[\"demands\"]))\n</code></pre>"},{"location":"reference/cosmica/models/demand/#cosmica.models.demand.parse_demand_item","title":"parse_demand_item","text":"<pre><code>parse_demand_item(\n    item: Mapping[str, Any],\n) -&gt; Demand[Hashable]\n</code></pre> <p>Parse a demand item.</p> Source code in <code>src/cosmica/models/demand.py</code> <pre><code>@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_demand_item(item: Mapping[str, Any]) -&gt; Demand[Hashable]:\n    \"\"\"Parse a demand item.\"\"\"\n    demand_type = item[\"type\"]\n    return _DEMAND_TYPES[demand_type].parse_demand_item(item)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/","title":"gateway","text":""},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway","title":"cosmica.models.gateway","text":""},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Gateway', 'GatewayOGS']\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway","title":"Gateway  <code>dataclass</code>","text":"<pre><code>Gateway(\n    *,\n    id: T,\n    latitude: float,\n    longitude: float,\n    minimum_elevation: float,\n    altitude: float = 0.0,\n    n_terminals: int = 1\n)\n</code></pre> <p>               Bases: <code>Node[T]</code></p>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.altitude","title":"altitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>altitude: float = field(default=0.0, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.minimum_elevation","title":"minimum_elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minimum_elevation: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.n_terminals","title":"n_terminals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_terminals: int = field(default=1, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"GW\"\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.from_toml_file","title":"from_toml_file  <code>classmethod</code>","text":"<pre><code>from_toml_file(toml_file_path: Path | str) -&gt; list[Self]\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef from_toml_file(cls, toml_file_path: Path | str) -&gt; list[Self]:\n    toml_file_path = Path(toml_file_path)\n    with toml_file_path.open(\"rb\") as f:\n        toml_data = tomllib.load(f)\n    return list(map(cls.parse_gateway_item, toml_data[\"gateways\"]))\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.Gateway.parse_gateway_item","title":"parse_gateway_item  <code>classmethod</code>","text":"<pre><code>parse_gateway_item(item: MutableMapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_gateway_item(cls, item: MutableMapping[str, Any]) -&gt; Self:\n    item[\"latitude\"] = np.deg2rad(item.pop(\"lat_deg\"))\n    item[\"longitude\"] = np.deg2rad(item.pop(\"lon_deg\"))\n    item[\"minimum_elevation\"] = np.deg2rad(item.pop(\"min_el_deg\"))\n    return cls(**item)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS","title":"GatewayOGS  <code>dataclass</code>","text":"<pre><code>GatewayOGS(\n    *,\n    id: T,\n    latitude: float,\n    longitude: float,\n    minimum_elevation: float,\n    altitude: float = 0.0,\n    n_terminals: int = 1,\n    aperture_size: float = 1.0,\n    rytov_variance: float = 0.5\n)\n</code></pre> <p>               Bases: <code>Node[T]</code></p>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.altitude","title":"altitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>altitude: float = field(default=0.0, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.aperture_size","title":"aperture_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aperture_size: float = field(default=1.0, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.minimum_elevation","title":"minimum_elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minimum_elevation: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.n_terminals","title":"n_terminals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_terminals: int = field(default=1, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.rytov_variance","title":"rytov_variance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rytov_variance: float = field(default=0.5, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"GW_OGS\"\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.from_toml_file","title":"from_toml_file  <code>classmethod</code>","text":"<pre><code>from_toml_file(toml_file_path: Path | str) -&gt; list[Self]\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef from_toml_file(cls, toml_file_path: Path | str) -&gt; list[Self]:\n    toml_file_path = Path(toml_file_path)\n    with toml_file_path.open(\"rb\") as f:\n        toml_data = tomllib.load(f)\n    return list(map(cls.parse_gateway_item, toml_data[\"gateways\"]))\n</code></pre>"},{"location":"reference/cosmica/models/gateway/#cosmica.models.gateway.GatewayOGS.parse_gateway_item","title":"parse_gateway_item  <code>classmethod</code>","text":"<pre><code>parse_gateway_item(item: MutableMapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/gateway.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_gateway_item(cls, item: MutableMapping[str, Any]) -&gt; Self:\n    item[\"latitude\"] = np.deg2rad(item.pop(\"lat_deg\"))\n    item[\"longitude\"] = np.deg2rad(item.pop(\"lon_deg\"))\n    item[\"minimum_elevation\"] = np.deg2rad(item.pop(\"min_el_deg\"))\n    item[\"aperture_size\"] = item.pop(\"aperture_size_m\")\n    item[\"rytov_variance\"] = item.pop(\"rytov_variance\")\n\n    return cls(**item)\n</code></pre>"},{"location":"reference/cosmica/models/internet/","title":"internet","text":""},{"location":"reference/cosmica/models/internet/#cosmica.models.internet","title":"cosmica.models.internet","text":""},{"location":"reference/cosmica/models/internet/#cosmica.models.internet.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Internet']\n</code></pre>"},{"location":"reference/cosmica/models/internet/#cosmica.models.internet.Internet","title":"Internet  <code>dataclass</code>","text":"<pre><code>Internet(*, id: T | None = None)\n</code></pre> <p>               Bases: <code>Node[T | None]</code></p> <p>The Internet node.</p>"},{"location":"reference/cosmica/models/internet/#cosmica.models.internet.Internet.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/internet/#cosmica.models.internet.Internet.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: T | None = None\n</code></pre>"},{"location":"reference/cosmica/models/internet/#cosmica.models.internet.Internet.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/internet/#cosmica.models.internet.Internet.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/internet.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"Internet\"\n</code></pre>"},{"location":"reference/cosmica/models/node/","title":"node","text":""},{"location":"reference/cosmica/models/node/#cosmica.models.node","title":"cosmica.models.node","text":""},{"location":"reference/cosmica/models/node/#cosmica.models.node.NodeGID","title":"NodeGID  <code>module-attribute</code>","text":"<pre><code>NodeGID = NewType('NodeGID', str)\n</code></pre>"},{"location":"reference/cosmica/models/node/#cosmica.models.node.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Node', 'NodeGID']\n</code></pre>"},{"location":"reference/cosmica/models/node/#cosmica.models.node.Node","title":"Node  <code>dataclass</code>","text":"<pre><code>Node(*, id: T)\n</code></pre> <p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/models/node/#cosmica.models.node.Node.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/node/#cosmica.models.node.Node.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/node/#cosmica.models.node.Node.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/node/#cosmica.models.node.Node.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> <p>Class name as a string used for the key generation.</p> <p>Override this method if you want to use a different class name for the key generation.</p> Source code in <code>src/cosmica/models/node.py</code> <pre><code>@classmethod\ndef class_name(cls) -&gt; str:\n    \"\"\"Class name as a string used for the key generation.\n\n    Override this method if you want to use a different class name for the key generation.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"reference/cosmica/models/orbit/","title":"orbit","text":""},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit","title":"cosmica.models.orbit","text":""},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"CircularSatelliteOrbitModel\",\n    \"EllipticalSatelliteOrbitModel\",\n    \"GravityModel\",\n]\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.CircularSatelliteOrbitModel","title":"CircularSatelliteOrbitModel","text":"<p>               Bases: <code>SatelliteOrbitModel</code></p>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.CircularSatelliteOrbitModel.epoch","title":"epoch  <code>instance-attribute</code>","text":"<pre><code>epoch: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.CircularSatelliteOrbitModel.inclination","title":"inclination  <code>instance-attribute</code>","text":"<pre><code>inclination: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.CircularSatelliteOrbitModel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.CircularSatelliteOrbitModel.phase_at_epoch","title":"phase_at_epoch  <code>instance-attribute</code>","text":"<pre><code>phase_at_epoch: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.CircularSatelliteOrbitModel.raan","title":"raan  <code>instance-attribute</code>","text":"<pre><code>raan: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.CircularSatelliteOrbitModel.semi_major_axis","title":"semi_major_axis  <code>instance-attribute</code>","text":"<pre><code>semi_major_axis: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel","title":"EllipticalSatelliteOrbitModel","text":"<p>               Bases: <code>SatelliteOrbitModel</code></p>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.argpo","title":"argpo  <code>instance-attribute</code>","text":"<pre><code>argpo: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.drag_coeff","title":"drag_coeff  <code>instance-attribute</code>","text":"<pre><code>drag_coeff: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.eccentricity","title":"eccentricity  <code>instance-attribute</code>","text":"<pre><code>eccentricity: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.epoch","title":"epoch  <code>instance-attribute</code>","text":"<pre><code>epoch: datetime64\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.gravity_model","title":"gravity_model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gravity_model: GravityModel = WGS84\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.inclination","title":"inclination  <code>instance-attribute</code>","text":"<pre><code>inclination: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.phase_at_epoch","title":"phase_at_epoch  <code>instance-attribute</code>","text":"<pre><code>phase_at_epoch: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.raan","title":"raan  <code>instance-attribute</code>","text":"<pre><code>raan: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.satnum","title":"satnum  <code>instance-attribute</code>","text":"<pre><code>satnum: int\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.EllipticalSatelliteOrbitModel.semi_major_axis","title":"semi_major_axis  <code>instance-attribute</code>","text":"<pre><code>semi_major_axis: float\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.GravityModel","title":"GravityModel","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.GravityModel.WGS72","title":"WGS72  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WGS72 = WGS72\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.GravityModel.WGS72OLD","title":"WGS72OLD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WGS72OLD = WGS72OLD\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.GravityModel.WGS84","title":"WGS84  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WGS84 = WGS84\n</code></pre>"},{"location":"reference/cosmica/models/orbit/#cosmica.models.orbit.SatelliteOrbitModel","title":"SatelliteOrbitModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for a satellite orbit.</p>"},{"location":"reference/cosmica/models/satellite/","title":"satellite","text":""},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite","title":"cosmica.models.satellite","text":""},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"ConstellationSatellite\",\n    \"Satellite\",\n    \"SatelliteTerminal\",\n    \"UserSatellite\",\n]\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.ConstellationSatellite","title":"ConstellationSatellite  <code>dataclass</code>","text":"<pre><code>ConstellationSatellite(\n    *, id: T, orbit: SatelliteOrbitModel | None = None\n)\n</code></pre> <p>               Bases: <code>Satellite[T]</code></p>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.ConstellationSatellite.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.ConstellationSatellite.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.ConstellationSatellite.orbit","title":"orbit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>orbit: SatelliteOrbitModel | None = None\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.ConstellationSatellite.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.ConstellationSatellite.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/satellite.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"CSAT\"\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.Satellite","title":"Satellite  <code>dataclass</code>","text":"<pre><code>Satellite(*, id: T)\n</code></pre> <p>               Bases: <code>Node[T]</code>, <code>ABC</code></p>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.Satellite.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.Satellite.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.Satellite.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.Satellite.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> <p>Class name as a string used for the key generation.</p> <p>Override this method if you want to use a different class name for the key generation.</p> Source code in <code>src/cosmica/models/node.py</code> <pre><code>@classmethod\ndef class_name(cls) -&gt; str:\n    \"\"\"Class name as a string used for the key generation.\n\n    Override this method if you want to use a different class name for the key generation.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal","title":"SatelliteTerminal  <code>dataclass</code>","text":"<pre><code>SatelliteTerminal(\n    *,\n    id: T,\n    terminal_id: T,\n    azimuth_min: float,\n    azimuth_max: float,\n    elevation_min: float,\n    elevation_max: float,\n    angular_velocity_max: float\n)\n</code></pre> <p>               Bases: <code>Satellite[T]</code></p>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.angular_velocity_max","title":"angular_velocity_max  <code>instance-attribute</code>","text":"<pre><code>angular_velocity_max: float\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.azimuth_max","title":"azimuth_max  <code>instance-attribute</code>","text":"<pre><code>azimuth_max: float\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.azimuth_min","title":"azimuth_min  <code>instance-attribute</code>","text":"<pre><code>azimuth_min: float\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.elevation_max","title":"elevation_max  <code>instance-attribute</code>","text":"<pre><code>elevation_max: float\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.elevation_min","title":"elevation_min  <code>instance-attribute</code>","text":"<pre><code>elevation_min: float\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.terminal","title":"terminal  <code>property</code>","text":"<pre><code>terminal: OpticalCommunicationTerminal[T]\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.terminal_id","title":"terminal_id  <code>instance-attribute</code>","text":"<pre><code>terminal_id: T\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.SatelliteTerminal.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> <p>Class name as a string used for the key generation.</p> <p>Override this method if you want to use a different class name for the key generation.</p> Source code in <code>src/cosmica/models/node.py</code> <pre><code>@classmethod\ndef class_name(cls) -&gt; str:\n    \"\"\"Class name as a string used for the key generation.\n\n    Override this method if you want to use a different class name for the key generation.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.UserSatellite","title":"UserSatellite  <code>dataclass</code>","text":"<pre><code>UserSatellite(*, id: T)\n</code></pre> <p>               Bases: <code>Satellite[T]</code></p>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.UserSatellite.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.UserSatellite.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.UserSatellite.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/satellite/#cosmica.models.satellite.UserSatellite.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/satellite.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"USAT\"\n</code></pre>"},{"location":"reference/cosmica/models/scenario/","title":"scenario","text":""},{"location":"reference/cosmica/models/scenario/#cosmica.models.scenario","title":"cosmica.models.scenario","text":""},{"location":"reference/cosmica/models/scenario/#cosmica.models.scenario.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Scenario']\n</code></pre>"},{"location":"reference/cosmica/models/scenario/#cosmica.models.scenario.Scenario","title":"Scenario  <code>dataclass</code>","text":"<pre><code>Scenario(\n    *,\n    time: NDArray[datetime64],\n    gateways: list[Gateway] = list(),\n    users: list[User] = list(),\n    demands: list[Demand] = list()\n)\n</code></pre> <p>The simulation scenario.</p>"},{"location":"reference/cosmica/models/scenario/#cosmica.models.scenario.Scenario.demands","title":"demands  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>demands: list[Demand] = field(default_factory=list)\n</code></pre>"},{"location":"reference/cosmica/models/scenario/#cosmica.models.scenario.Scenario.gateways","title":"gateways  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gateways: list[Gateway] = field(default_factory=list)\n</code></pre>"},{"location":"reference/cosmica/models/scenario/#cosmica.models.scenario.Scenario.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: NDArray[datetime64]\n</code></pre>"},{"location":"reference/cosmica/models/scenario/#cosmica.models.scenario.Scenario.users","title":"users  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>users: list[User] = field(default_factory=list)\n</code></pre>"},{"location":"reference/cosmica/models/scenario/#cosmica.models.scenario.Scenario.build_topology","title":"build_topology","text":"<pre><code>build_topology() -&gt; None\n</code></pre> <p>Build the topology of the scenario.</p> Source code in <code>src/cosmica/models/scenario.py</code> <pre><code>def build_topology(self) -&gt; None:\n    \"\"\"Build the topology of the scenario.\"\"\"\n</code></pre>"},{"location":"reference/cosmica/models/terminal/","title":"terminal","text":""},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal","title":"cosmica.models.terminal","text":""},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"CommunicationTerminal\",\n    \"OpticalCommunicationTerminal\",\n    \"RFCommunicationTerminal\",\n    \"UserOpticalCommunicationTerminal\",\n]\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.CommunicationTerminal","title":"CommunicationTerminal  <code>dataclass</code>","text":"<pre><code>CommunicationTerminal(*, id: T)\n</code></pre> <p>               Bases: <code>Node[T]</code></p>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.CommunicationTerminal.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.CommunicationTerminal.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.CommunicationTerminal.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.CommunicationTerminal.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/terminal.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"CT\"\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.OpticalCommunicationTerminal","title":"OpticalCommunicationTerminal  <code>dataclass</code>","text":"<pre><code>OpticalCommunicationTerminal(\n    *,\n    id: T,\n    azimuth_min: float,\n    azimuth_max: float,\n    elevation_min: float,\n    elevation_max: float,\n    angular_velocity_max: float\n)\n</code></pre> <p>               Bases: <code>CommunicationTerminal[T]</code></p>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.OpticalCommunicationTerminal.angular_velocity_max","title":"angular_velocity_max  <code>instance-attribute</code>","text":"<pre><code>angular_velocity_max: float\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.OpticalCommunicationTerminal.azimuth_max","title":"azimuth_max  <code>instance-attribute</code>","text":"<pre><code>azimuth_max: float\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.OpticalCommunicationTerminal.azimuth_min","title":"azimuth_min  <code>instance-attribute</code>","text":"<pre><code>azimuth_min: float\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.OpticalCommunicationTerminal.elevation_max","title":"elevation_max  <code>instance-attribute</code>","text":"<pre><code>elevation_max: float\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.OpticalCommunicationTerminal.elevation_min","title":"elevation_min  <code>instance-attribute</code>","text":"<pre><code>elevation_min: float\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.OpticalCommunicationTerminal.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.OpticalCommunicationTerminal.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.OpticalCommunicationTerminal.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.OpticalCommunicationTerminal.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/terminal.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"OCT\"\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.RFCommunicationTerminal","title":"RFCommunicationTerminal  <code>dataclass</code>","text":"<pre><code>RFCommunicationTerminal(*, id: T)\n</code></pre> <p>               Bases: <code>CommunicationTerminal[T]</code></p>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.RFCommunicationTerminal.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.RFCommunicationTerminal.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.RFCommunicationTerminal.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.RFCommunicationTerminal.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/terminal.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"RFCT\"\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.UserOpticalCommunicationTerminal","title":"UserOpticalCommunicationTerminal  <code>dataclass</code>","text":"<pre><code>UserOpticalCommunicationTerminal(\n    *,\n    id: T,\n    azimuth_min: float,\n    azimuth_max: float,\n    elevation_min: float,\n    elevation_max: float,\n    angular_velocity_max: float\n)\n</code></pre> <p>               Bases: <code>OpticalCommunicationTerminal[T]</code></p>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.UserOpticalCommunicationTerminal.angular_velocity_max","title":"angular_velocity_max  <code>instance-attribute</code>","text":"<pre><code>angular_velocity_max: float\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.UserOpticalCommunicationTerminal.azimuth_max","title":"azimuth_max  <code>instance-attribute</code>","text":"<pre><code>azimuth_max: float\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.UserOpticalCommunicationTerminal.azimuth_min","title":"azimuth_min  <code>instance-attribute</code>","text":"<pre><code>azimuth_min: float\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.UserOpticalCommunicationTerminal.elevation_max","title":"elevation_max  <code>instance-attribute</code>","text":"<pre><code>elevation_max: float\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.UserOpticalCommunicationTerminal.elevation_min","title":"elevation_min  <code>instance-attribute</code>","text":"<pre><code>elevation_min: float\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.UserOpticalCommunicationTerminal.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.UserOpticalCommunicationTerminal.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.UserOpticalCommunicationTerminal.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/terminal/#cosmica.models.terminal.UserOpticalCommunicationTerminal.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/terminal.py</code> <pre><code>@classmethod\n@override\ndef class_name(cls) -&gt; str:\n    return \"UOCT\"\n</code></pre>"},{"location":"reference/cosmica/models/user/","title":"user","text":""},{"location":"reference/cosmica/models/user/#cosmica.models.user","title":"cosmica.models.user","text":""},{"location":"reference/cosmica/models/user/#cosmica.models.user.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"StationaryOnGroundUser\",\n    \"User\",\n    \"load_users_from_toml_file\",\n    \"parse_user_item\",\n]\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser","title":"StationaryOnGroundUser  <code>dataclass</code>","text":"<pre><code>StationaryOnGroundUser(\n    *,\n    id: T,\n    terminals: list[\n        CommunicationTerminal[Hashable]\n    ] = list(),\n    latitude: float,\n    longitude: float,\n    altitude: float = 0.0,\n    minimum_elevation: float\n)\n</code></pre> <p>               Bases: <code>User[T]</code></p> <p>Model for a stationary user on the ground.</p>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser.altitude","title":"altitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>altitude: float = field(default=0.0, compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser.minimum_elevation","title":"minimum_elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minimum_elevation: float = field(compare=False)\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser.terminals","title":"terminals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>terminals: list[CommunicationTerminal[Hashable]] = field(\n    default_factory=list, compare=False\n)\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> <p>Class name as a string used for the key generation.</p> <p>Override this method if you want to use a different class name for the key generation.</p> Source code in <code>src/cosmica/models/node.py</code> <pre><code>@classmethod\ndef class_name(cls) -&gt; str:\n    \"\"\"Class name as a string used for the key generation.\n\n    Override this method if you want to use a different class name for the key generation.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.StationaryOnGroundUser.parse_user_item","title":"parse_user_item  <code>classmethod</code>","text":"<pre><code>parse_user_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/cosmica/models/user.py</code> <pre><code>@classmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_user_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    return cls(\n        id=item[\"id\"],\n        latitude=np.deg2rad(item[\"lat_deg\"]),\n        longitude=np.deg2rad(item[\"lon_deg\"]),\n        altitude=item[\"alt_m\"],\n        minimum_elevation=np.deg2rad(item[\"min_el_deg\"]),\n    )\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.User","title":"User  <code>dataclass</code>","text":"<pre><code>User(\n    *,\n    id: T,\n    terminals: list[\n        CommunicationTerminal[Hashable]\n    ] = list()\n)\n</code></pre> <p>               Bases: <code>Node[T]</code>, <code>ABC</code></p> <p>Base model for a user.</p>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.User.global_id","title":"global_id  <code>property</code>","text":"<pre><code>global_id: NodeGID\n</code></pre> <p>The universally unique identifier of the node.</p>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.User.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: T\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.User.terminals","title":"terminals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>terminals: list[CommunicationTerminal[Hashable]] = field(\n    default_factory=list\n)\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.User.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/cosmica/models/node.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.global_id\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.User.class_name","title":"class_name  <code>classmethod</code>","text":"<pre><code>class_name() -&gt; str\n</code></pre> <p>Class name as a string used for the key generation.</p> <p>Override this method if you want to use a different class name for the key generation.</p> Source code in <code>src/cosmica/models/node.py</code> <pre><code>@classmethod\ndef class_name(cls) -&gt; str:\n    \"\"\"Class name as a string used for the key generation.\n\n    Override this method if you want to use a different class name for the key generation.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.User.parse_user_item","title":"parse_user_item  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>parse_user_item(item: Mapping[str, Any]) -&gt; Self\n</code></pre> <p>Parse a user item.</p> Source code in <code>src/cosmica/models/user.py</code> <pre><code>@classmethod\n@abstractmethod\n@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_user_item(cls, item: Mapping[str, Any]) -&gt; Self:\n    \"\"\"Parse a user item.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.load_users_from_toml_file","title":"load_users_from_toml_file","text":"<pre><code>load_users_from_toml_file(\n    toml_file_path: str | Path,\n) -&gt; list[User[Hashable]]\n</code></pre> <p>Load users from a TOML file.</p> Source code in <code>src/cosmica/models/user.py</code> <pre><code>@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef load_users_from_toml_file(toml_file_path: str | Path) -&gt; list[User[Hashable]]:\n    \"\"\"Load users from a TOML file.\"\"\"\n    toml_file_path = Path(toml_file_path)\n    with toml_file_path.open(\"rb\") as f:\n        toml_data = tomllib.load(f)\n    return list(map(parse_user_item, toml_data[\"users\"]))\n</code></pre>"},{"location":"reference/cosmica/models/user/#cosmica.models.user.parse_user_item","title":"parse_user_item","text":"<pre><code>parse_user_item(item: Mapping[str, Any]) -&gt; User[Hashable]\n</code></pre> <p>Parse a user item.</p> Source code in <code>src/cosmica/models/user.py</code> <pre><code>@deprecated(\"Construction of objects from TOML files is deprecated and will be removed in future versions.\")\ndef parse_user_item(item: Mapping[str, Any]) -&gt; User[Hashable]:\n    \"\"\"Parse a user item.\"\"\"\n    user_type = item[\"type\"]\n    return _USER_TYPES[user_type].parse_user_item(item)\n</code></pre>"},{"location":"reference/cosmica/scenario/","title":"scenario","text":""},{"location":"reference/cosmica/scenario/#cosmica.scenario","title":"cosmica.scenario","text":""},{"location":"reference/cosmica/scenario/maritime/","title":"maritime","text":""},{"location":"reference/cosmica/scenario/maritime/#cosmica.scenario.maritime","title":"cosmica.scenario.maritime","text":""},{"location":"reference/cosmica/scenario/maritime/#cosmica.scenario.maritime.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/scenario/maritime/#cosmica.scenario.maritime.get_ais_density_data","title":"get_ais_density_data","text":"<pre><code>get_ais_density_data() -&gt; NDArray[floating]\n</code></pre> <p>Get AIS density data.</p> RETURNS DESCRIPTION <code>NDArray[floating]</code> <p>AIS density data [seconds/m2] in Oct 2023 as a NumPy array with shape (180, 359). The rows are latitude (+90 deg to -90 deg) and the columns are longitude (-179.5 deg to +179.5 deg).</p> Source code in <code>src/cosmica/scenario/maritime.py</code> <pre><code>def get_ais_density_data() -&gt; Annotated[\n    npt.NDArray[np.floating],\n    Doc(\n        \"AIS density data [seconds/m2] in Oct 2023 as a NumPy array with shape (180, 359).\"\n        \" The rows are latitude (+90 deg to -90 deg) and the columns are longitude (-179.5 deg to +179.5 deg).\",\n    ),\n]:\n    \"\"\"Get AIS density data.\"\"\"\n    # Conversion [hours/km2] -&gt; [seconds/m2]\n    return _load_numpy_array_from_assets_dir(\"maritime_20231001_non-loitering.npy\") * 3600 / 1e6\n</code></pre>"},{"location":"reference/cosmica/scenario/maritime/#cosmica.scenario.maritime.sample_demand_locations","title":"sample_demand_locations","text":"<pre><code>sample_demand_locations(\n    n_samples: int, *, rng: Generator | None = None\n) -&gt; tuple[NDArray[floating], NDArray[floating]]\n</code></pre> <p>Sample maritime demand locations based on AIS density data.</p> <p>The probability of sampling a location is proportional to the AIS density at that location, with the correction for the area difference between the lower and higher latitudes.</p> PARAMETER DESCRIPTION <code>n_samples</code> <p>Number of demand locations to sample.</p> <p> TYPE: <code>int</code> </p> <code>rng</code> <p>NumPy random number generator. If None, use default.</p> <p> TYPE: <code>Generator | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[NDArray[floating], NDArray[floating]]</code> <p>Sampled demand locations as a tuple of (longitude, latitude) in radians, each with shape (n_samples,).</p> Source code in <code>src/cosmica/scenario/maritime.py</code> <pre><code>def sample_demand_locations(\n    n_samples: Annotated[int, Doc(\"Number of demand locations to sample.\")],\n    *,\n    rng: Annotated[np.random.Generator | None, Doc(\"NumPy random number generator. If None, use default.\")] = None,\n) -&gt; Annotated[\n    tuple[npt.NDArray[np.floating], npt.NDArray[np.floating]],\n    Doc(\"Sampled demand locations as a tuple of (longitude, latitude) in radians, each with shape (n_samples,).\"),\n]:\n    \"\"\"Sample maritime demand locations based on AIS density data.\n\n    The probability of sampling a location is proportional to the AIS density at that location,\n    with the correction for the area difference between the lower and higher latitudes.\n    \"\"\"\n    rng = rng if rng is not None else np.random.default_rng()\n\n    data = get_ais_density_data()\n    lon = np.deg2rad(np.arange(-179, 180))\n    lat = np.deg2rad(np.arange(89.5, -90.5, -1))\n    longitude, latitude = np.meshgrid(lon, lat)\n\n    d_lon = abs(float(lon[1] - lon[0]))\n    d_lat = abs(float(lat[1] - lat[0]))\n\n    area = EARTH_RADIUS**2 * np.cos(latitude) * d_lon * d_lat\n    volume = data * area\n\n    is_valid = ~np.isnan(volume)\n\n    probability = volume[is_valid].flatten() / np.nansum(volume)\n    assert np.isclose(np.nansum(probability), 1)\n\n    sample_indices = rng.choice(np.sum(is_valid), size=n_samples, replace=False, p=probability)\n\n    return longitude[is_valid].flatten()[sample_indices], latitude[is_valid].flatten()[sample_indices]\n</code></pre>"},{"location":"reference/cosmica/scenario/population/","title":"population","text":""},{"location":"reference/cosmica/scenario/population/#cosmica.scenario.population","title":"cosmica.scenario.population","text":""},{"location":"reference/cosmica/scenario/population/#cosmica.scenario.population.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/scenario/population/#cosmica.scenario.population.get_population_data","title":"get_population_data","text":"<pre><code>get_population_data() -&gt; NDArray[floating]\n</code></pre> <p>Get population data.</p> RETURNS DESCRIPTION <code>NDArray[floating]</code> <p>Global population count data with shape (180, 360). The rows are latitude (+90 deg to -90 deg) and the columns are longitude (-180 deg to +180 deg). The data is based on the Global Human Settlement Layer (GHSL) population grid data (GHS-POP) for 2025.</p> Source code in <code>src/cosmica/scenario/population.py</code> <pre><code>def get_population_data() -&gt; Annotated[\n    npt.NDArray[np.floating],\n    Doc(\n        \"Global population count data with shape (180, 360).\"\n        \" The rows are latitude (+90 deg to -90 deg) and the columns are longitude (-180 deg to +180 deg).\"\n        \" The data is based on the Global Human Settlement Layer (GHSL) population grid data (GHS-POP) for 2025.\",\n    ),\n]:\n    \"\"\"Get population data.\"\"\"\n    return _load_numpy_array_from_assets_dir(\"aggregated_population_data.npy\")\n</code></pre>"},{"location":"reference/cosmica/scenario/population/#cosmica.scenario.population.sample_demand_locations","title":"sample_demand_locations","text":"<pre><code>sample_demand_locations(\n    n_samples: int, *, rng: Generator | None = None\n) -&gt; tuple[NDArray[floating], NDArray[floating]]\n</code></pre> <p>Sample on-ground demand locations based on global population distribution data.</p> <p>The probability of sampling a location is proportional to the population count at that location.</p> PARAMETER DESCRIPTION <code>n_samples</code> <p>Number of demand locations to sample.</p> <p> TYPE: <code>int</code> </p> <code>rng</code> <p>NumPy random number generator. If None, use default.</p> <p> TYPE: <code>Generator | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[NDArray[floating], NDArray[floating]]</code> <p>Sampled demand locations as a tuple of (longitude, latitude) in radians, each with shape (n_samples,).</p> Source code in <code>src/cosmica/scenario/population.py</code> <pre><code>def sample_demand_locations(\n    n_samples: Annotated[int, Doc(\"Number of demand locations to sample.\")],\n    *,\n    rng: Annotated[np.random.Generator | None, Doc(\"NumPy random number generator. If None, use default.\")] = None,\n) -&gt; Annotated[\n    tuple[npt.NDArray[np.floating], npt.NDArray[np.floating]],\n    Doc(\"Sampled demand locations as a tuple of (longitude, latitude) in radians, each with shape (n_samples,).\"),\n]:\n    \"\"\"Sample on-ground demand locations based on global population distribution data.\n\n    The probability of sampling a location is proportional to the population count at that location.\n    \"\"\"\n    rng = rng if rng is not None else np.random.default_rng()\n\n    population = get_population_data()\n    lon = np.deg2rad(np.arange(-179.5, 180.5))\n    lat = np.flip(np.deg2rad(np.arange(-89.5, 90.5)))\n    longitude, latitude = np.meshgrid(lon, lat)\n\n    probability = population.flatten() / np.nansum(population)\n    assert np.isclose(np.nansum(probability), 1)\n\n    sample_indices = rng.choice(len(probability), size=n_samples, replace=False, p=probability)\n\n    return longitude.flatten()[sample_indices], latitude.flatten()[sample_indices]\n</code></pre>"},{"location":"reference/cosmica/topology/","title":"topology","text":""},{"location":"reference/cosmica/topology/#cosmica.topology","title":"cosmica.topology","text":""},{"location":"reference/cosmica/topology/#cosmica.topology.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"ConstellationTimeSeriesTopologyBuilder\",\n    \"ConstellationTopologyBuilder\",\n    \"ElevationBasedG2CTopologyBuilder\",\n    \"ElevationBasedG2CTopologyBuilder\",\n    \"GatewayToGatewayTopologyBuilder\",\n    \"GatewayToInternetTopologyBuilder\",\n    \"GroundToConstellationTopologyBuilder\",\n    \"HybridUS2CG2CTopologyBuilder\",\n    \"ManhattanTimeSeriesTopologyBuilder\",\n    \"ManhattanTopologyBuilder\",\n    \"ManualG2CTopologyBuilder\",\n    \"MaxConnectionTimeUS2CTopologyBuilder\",\n    \"MaxVisibilityHandOverG2CTopologyBuilder\",\n    \"UserSatelliteToConstellationTopologyBuilder\",\n]\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ConstellationTimeSeriesTopologyBuilder","title":"ConstellationTimeSeriesTopologyBuilder","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/topology/#cosmica.topology.ConstellationTimeSeriesTopologyBuilder.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(\n    *,\n    constellation: TConstellation,\n    dynamics_data: DynamicsData\n) -&gt; list[TGraph]\n</code></pre> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>@abstractmethod\ndef build(\n    self,\n    *,\n    constellation: TConstellation,\n    dynamics_data: DynamicsData,\n) -&gt; list[TGraph]: ...\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ConstellationTopologyBuilder","title":"ConstellationTopologyBuilder","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/topology/#cosmica.topology.ConstellationTopologyBuilder.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(*, constellation: TConstellation) -&gt; TGraph\n</code></pre> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>@abstractmethod\ndef build(\n    self,\n    *,\n    constellation: TConstellation,\n) -&gt; TGraph: ...\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ElevationBasedG2CTopologyBuilder","title":"ElevationBasedG2CTopologyBuilder","text":"<p>               Bases: <code>GroundToConstellationTopologyBuilder[SatelliteConstellation, Gateway | StationaryOnGroundUser, Graph]</code></p>"},{"location":"reference/cosmica/topology/#cosmica.topology.ElevationBasedG2CTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[\n        Gateway | StationaryOnGroundUser\n    ],\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> Source code in <code>src/cosmica/topology/ground_to_constellation.py</code> <pre><code>def build(\n    self,\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[Gateway | StationaryOnGroundUser],\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    logger.info(f\"Number of time steps: {len(dynamics_data.time)}\")\n    ground_nodes = list(ground_nodes)\n\n    n_satellites = len(dynamics_data.satellite_position_eci)\n    visibility = np.zeros((len(ground_nodes), n_satellites, len(dynamics_data.time)), dtype=np.bool_)\n    for (ground_node_idx, ground_node), (sat_idx, satellite) in product(\n        enumerate(ground_nodes),\n        enumerate(constellation.satellites),\n    ):\n        _, elevation, _ = ecef2aer(\n            x=dynamics_data.satellite_position_ecef[satellite][:, 0],\n            y=dynamics_data.satellite_position_ecef[satellite][:, 1],\n            z=dynamics_data.satellite_position_ecef[satellite][:, 2],\n            lat0=ground_node.latitude,\n            lon0=ground_node.longitude,\n            h0=ground_node.altitude,\n            deg=False,\n        )\n        visibility[ground_node_idx, sat_idx, :] = elevation &gt;= ground_node.minimum_elevation\n\n    def construct_graph(visibility: npt.NDArray[np.bool_]) -&gt; nx.Graph:\n        graph = nx.Graph()\n        graph.add_nodes_from(constellation.satellites)\n        graph.add_nodes_from(ground_nodes)\n\n        for (ground_node_idx, ground_node), (sat_idx, satellite) in product(\n            enumerate(ground_nodes),\n            enumerate(constellation.satellites),\n        ):\n            if visibility[ground_node_idx, sat_idx]:\n                graph.add_edge(ground_node, satellite)\n\n        return graph\n\n    return [construct_graph(visibility[:, :, time_idx]) for time_idx in range(len(dynamics_data.time))]\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.GatewayToGatewayTopologyBuilder","title":"GatewayToGatewayTopologyBuilder","text":""},{"location":"reference/cosmica/topology/#cosmica.topology.GatewayToGatewayTopologyBuilder.build","title":"build","text":"<pre><code>build(*, gateways: Collection[Gateway[Hashable]]) -&gt; Graph\n</code></pre> Source code in <code>src/cosmica/topology/gateway_to_gateway.py</code> <pre><code>def build(\n    self,\n    *,\n    gateways: Collection[Gateway[Hashable]],\n) -&gt; nx.Graph:\n    graph = nx.Graph()\n    gateway_list = list(gateways)\n    graph.add_nodes_from(gateway_list)\n\n    # \u3059\u3079\u3066\u306egateway\u540c\u58eb\u3092\u63a5\u7d9a\u3059\u308b(\u5b8c\u5168\u30b0\u30e9\u30d5)\n    for i, gateway1 in enumerate(gateway_list):\n        for gateway2 in gateway_list[i + 1 :]:\n            graph.add_edge(gateway1, gateway2)\n\n    return graph\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.GatewayToInternetTopologyBuilder","title":"GatewayToInternetTopologyBuilder","text":""},{"location":"reference/cosmica/topology/#cosmica.topology.GatewayToInternetTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *, gateways: Collection[Gateway], internet: Internet\n) -&gt; Graph\n</code></pre> Source code in <code>src/cosmica/topology/gateway_to_internet.py</code> <pre><code>def build(\n    self,\n    *,\n    gateways: Collection[Gateway],\n    internet: Internet,\n) -&gt; nx.Graph:\n    graph = nx.Graph()\n    graph.add_nodes_from(gateways)\n    graph.add_node(internet)\n    graph.add_edges_from((gateway, internet) for gateway in gateways)\n\n    return graph\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.GroundToConstellationTopologyBuilder","title":"GroundToConstellationTopologyBuilder","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/topology/#cosmica.topology.GroundToConstellationTopologyBuilder.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(\n    *,\n    constellation: TConstellation,\n    ground_nodes: Collection[TNode],\n    dynamics_data: DynamicsData\n) -&gt; list[TGraph]\n</code></pre> Source code in <code>src/cosmica/topology/ground_to_constellation.py</code> <pre><code>@abstractmethod\ndef build(\n    self,\n    *,\n    constellation: TConstellation,\n    ground_nodes: Collection[TNode],\n    dynamics_data: DynamicsData,\n) -&gt; list[TGraph]: ...\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.HybridUS2CG2CTopologyBuilder","title":"HybridUS2CG2CTopologyBuilder","text":"<pre><code>HybridUS2CG2CTopologyBuilder(\n    max_distance: float = float(\"inf\"),\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n)\n</code></pre> <p>Hybrid topology builder for user satellites and ground stations to constellation.</p> <p>This builder combines the functionality of MaxConnectionTimeUS2CTopologyBuilder and MaxVisibilityHandOverG2CTopologyBuilder. It prioritizes user satellite connections and then optimizes ground station connections based on maximum visibility duration.</p> <p>For user satellites, constraints include distance, sun exclusion angle, and relative angular velocity. For ground stations, constraints include elevation angle and sun exclusion angle.</p> Source code in <code>src/cosmica/topology/usersatellite_gateway_to_constellation.py</code> <pre><code>def __init__(\n    self,\n    max_distance: float = float(\"inf\"),\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n) -&gt; None:\n    self.max_distance = max_distance\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n    self.sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.HybridUS2CG2CTopologyBuilder.max_distance","title":"max_distance  <code>instance-attribute</code>","text":"<pre><code>max_distance = max_distance\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.HybridUS2CG2CTopologyBuilder.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.HybridUS2CG2CTopologyBuilder.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.HybridUS2CG2CTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: SatelliteConstellation,\n    user_satellites: Collection[UserSatellite],\n    ground_nodes: Collection[\n        Gateway | StationaryOnGroundUser\n    ],\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> <p>Build hybrid topology connecting user satellites and ground stations to constellation.</p> Source code in <code>src/cosmica/topology/usersatellite_gateway_to_constellation.py</code> <pre><code>def build(\n    self,\n    *,\n    constellation: SatelliteConstellation,\n    user_satellites: Collection[UserSatellite],\n    ground_nodes: Collection[Gateway | StationaryOnGroundUser],\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    \"\"\"Build hybrid topology connecting user satellites and ground stations to constellation.\"\"\"\n    logger.info(\n        f\"Building hybrid topology for {len(user_satellites)} user satellites and {len(ground_nodes)} ground nodes\",\n    )\n    logger.info(f\"Number of time steps: {len(dynamics_data.time)}\")\n\n    user_satellites = list(user_satellites)\n    ground_nodes = list(ground_nodes)\n    constellation_satellites = list(constellation.satellites)\n\n    n_time = len(dynamics_data.time)\n\n    # Calculate user satellite visibility\n    logger.info(\"Calculating user satellite visibility...\")\n    user_visibility = self._calculate_user_satellite_visibility(\n        user_satellites,\n        constellation_satellites,\n        dynamics_data,\n    )\n\n    # Calculate ground node visibility\n    logger.info(\"Calculating ground node visibility...\")\n    ground_visibility = self._calculate_ground_visibility(\n        ground_nodes,\n        constellation_satellites,\n        dynamics_data,\n    )\n\n    # Calculate remaining connection time for user satellites\n    user_remaining_connection_time = self._calculate_remaining_connection_time(user_visibility)\n\n    # Calculate remaining visibility time for ground nodes\n    ground_remaining_visibility_time = self._calculate_remaining_connection_time(ground_visibility)\n\n    # Initialize connection tracking\n    user_connections: dict[int, int] = {}  # user_idx -&gt; constellation_satellite_idx\n    ground_connections: dict[int, int] = {}  # ground_idx -&gt; constellation_satellite_idx\n\n    # Build topology for each time step\n    logger.info(\"Building topology graphs for each time step...\")\n    graphs = []\n    for time_idx in tqdm(range(n_time), desc=\"Building topology graphs\"):\n        graph = self._build_graph_at_time(\n            time_idx,\n            constellation_satellites,\n            user_satellites,\n            ground_nodes,\n            user_visibility,\n            ground_visibility,\n            user_remaining_connection_time,\n            ground_remaining_visibility_time,\n            user_connections,\n            ground_connections,\n        )\n        graphs.append(graph)\n\n    return graphs\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManhattanTimeSeriesTopologyBuilder","title":"ManhattanTimeSeriesTopologyBuilder","text":"<pre><code>ManhattanTimeSeriesTopologyBuilder(\n    *,\n    inter_plane_offset: int = 0,\n    last_to_first_plane_offset: int = 0,\n    max_latitude: float = deg2rad(90.0)\n)\n</code></pre> <p>               Bases: <code>ConstellationTimeSeriesTopologyBuilder[MultiOrbitalPlaneConstellation[CircularSatelliteOrbit], Graph]</code></p> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_plane_offset: int = 0,\n    last_to_first_plane_offset: int = 0,\n    max_latitude: float = np.deg2rad(90.0),\n) -&gt; None:\n    self.inter_plane_offset = inter_plane_offset\n    self.last_to_first_plane_offset = last_to_first_plane_offset\n    self.max_latitude = max_latitude\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManhattanTimeSeriesTopologyBuilder.inter_plane_offset","title":"inter_plane_offset  <code>instance-attribute</code>","text":"<pre><code>inter_plane_offset = inter_plane_offset\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManhattanTimeSeriesTopologyBuilder.last_to_first_plane_offset","title":"last_to_first_plane_offset  <code>instance-attribute</code>","text":"<pre><code>last_to_first_plane_offset = last_to_first_plane_offset\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManhattanTimeSeriesTopologyBuilder.max_latitude","title":"max_latitude  <code>instance-attribute</code>","text":"<pre><code>max_latitude = max_latitude\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManhattanTimeSeriesTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: MultiOrbitalPlaneConstellation,\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>def build(\n    self,\n    *,\n    constellation: MultiOrbitalPlaneConstellation,\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    def construct_graph(time_idx: int) -&gt; nx.Graph:\n        graph = nx.Graph()\n\n        # Add nodes\n        for satellite in constellation.satellites:\n            graph.add_node(satellite)\n\n        # Intra-plane edges\n        # Connect satellites to the two satellites in the same plane with the closest phase angle\n        for plane_id in constellation.plane_ids:\n            satellites_in_plane = sorted(\n                constellation.plane_id_to_satellites[plane_id],\n                key=lambda satellite: constellation.satellite_orbits[satellite].phase_at_epoch,\n            )\n            for plane_idx, satellite in enumerate(satellites_in_plane):\n                src, dst = satellite, satellites_in_plane[(plane_idx + 1) % len(satellites_in_plane)]\n                graph.add_edge(src, dst)\n\n        # Inter-plane edges\n        def _get_first_satellite(plane_id: int) -&gt; ConstellationSatellite:\n            return sorted(\n                constellation.plane_id_to_satellites[plane_id],\n                key=lambda satellite: satellite.id.satellite_id,\n            )[0]\n\n        # Sort planes by raan\n        plane_ids = sorted(\n            constellation.plane_ids,\n            key=lambda plane_id: constellation.satellite_orbits[_get_first_satellite(plane_id)].raan,\n        )\n        for plane_idx, plane_id in enumerate(plane_ids):\n            next_plane_id = plane_ids[(plane_idx + 1) % len(plane_ids)]\n            inter_plane_offset_ = self.inter_plane_offset\n            if plane_idx == len(plane_ids) - 1:\n                # Connect the last plane to the first plane\n                inter_plane_offset_ += self.last_to_first_plane_offset\n\n            satellites_in_plane = sorted(\n                constellation.plane_id_to_satellites[plane_id],\n                key=lambda satellite: satellite.id.satellite_id,\n            )\n            satellites_in_next_plane = sorted(\n                constellation.plane_id_to_satellites[next_plane_id],\n                key=lambda satellite: satellite.id.satellite_id,\n            )\n            assert len(satellites_in_plane) == len(satellites_in_next_plane), (\n                \"Number of satellites in each plane must be the same. \"\n                f\"plane_id={plane_id}, next_plane_id={next_plane_id}\"\n            )\n            for sat_idx, satellite in enumerate(satellites_in_plane):\n                src = satellite\n                dst = satellites_in_next_plane[(sat_idx + inter_plane_offset_) % len(satellites_in_plane)]\n\n                # Orbital intersection in the polar region\n                _, latitude_src = unit_vector_to_azimuth_elevation(\n                    normalize(dynamics_data.satellite_position_ecef[src][time_idx]),\n                )\n                _, latitude_dst = unit_vector_to_azimuth_elevation(\n                    normalize(dynamics_data.satellite_position_ecef[dst][time_idx]),\n                )\n                if abs(latitude_src) &gt; self.max_latitude and abs(latitude_dst) &gt; self.max_latitude:\n                    continue\n\n                graph.add_edge(src, dst)\n\n        # Ensure the constructed graph is returned for each time index\n        return graph\n\n    return [construct_graph(time_idx) for time_idx in range(len(dynamics_data.time))]\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManhattanTopologyBuilder","title":"ManhattanTopologyBuilder","text":"<pre><code>ManhattanTopologyBuilder(\n    *,\n    inter_plane_offset: int = 0,\n    last_to_first_plane_offset: int = 0\n)\n</code></pre> <p>               Bases: <code>ConstellationTopologyBuilder[MultiOrbitalPlaneConstellation[CircularSatelliteOrbit], Graph]</code></p> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_plane_offset: int = 0,\n    last_to_first_plane_offset: int = 0,\n) -&gt; None:\n    self.inter_plane_offset = inter_plane_offset\n    self.last_to_first_plane_offset = last_to_first_plane_offset\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManhattanTopologyBuilder.inter_plane_offset","title":"inter_plane_offset  <code>instance-attribute</code>","text":"<pre><code>inter_plane_offset = inter_plane_offset\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManhattanTopologyBuilder.last_to_first_plane_offset","title":"last_to_first_plane_offset  <code>instance-attribute</code>","text":"<pre><code>last_to_first_plane_offset = last_to_first_plane_offset\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManhattanTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *, constellation: MultiOrbitalPlaneConstellation\n) -&gt; Graph\n</code></pre> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>def build(\n    self,\n    *,\n    constellation: MultiOrbitalPlaneConstellation,\n) -&gt; nx.Graph:\n    graph = nx.Graph()\n\n    # Add nodes\n    for satellite in constellation.satellites:\n        graph.add_node(satellite)\n\n    # Intra-plane edges\n    # Connect satellites to the two satellites in the same plane with the closest phase angle\n    for plane_id in constellation.plane_ids:\n        satellites_in_plane = sorted(\n            constellation.plane_id_to_satellites[plane_id],\n            key=lambda satellite: constellation.satellite_orbits[satellite].phase_at_epoch,\n        )\n        for plane_idx, satellite in enumerate(satellites_in_plane):\n            src, dst = satellite, satellites_in_plane[(plane_idx + 1) % len(satellites_in_plane)]\n            graph.add_edge(src, dst)\n\n    # Inter-plane edges\n    def _get_first_satellite(plane_id: int) -&gt; ConstellationSatellite:\n        return sorted(\n            constellation.plane_id_to_satellites[plane_id],\n            key=lambda satellite: satellite.id.satellite_id,\n        )[0]\n\n    # Sort planes by raan\n    plane_ids = sorted(\n        constellation.plane_ids,\n        key=lambda plane_id: constellation.satellite_orbits[_get_first_satellite(plane_id)].raan,\n    )\n    for plane_idx, plane_id in enumerate(plane_ids):\n        next_plane_id = plane_ids[(plane_idx + 1) % len(plane_ids)]\n        inter_plane_offset_ = self.inter_plane_offset\n        if plane_idx == len(plane_ids) - 1:\n            # Connect the last plane to the first plane\n            inter_plane_offset_ += self.last_to_first_plane_offset\n\n        satellites_in_plane = sorted(\n            constellation.plane_id_to_satellites[plane_id],\n            key=lambda satellite: satellite.id.satellite_id,\n        )\n        satellites_in_next_plane = sorted(\n            constellation.plane_id_to_satellites[next_plane_id],\n            key=lambda satellite: satellite.id.satellite_id,\n        )\n        assert len(satellites_in_plane) == len(satellites_in_next_plane), (\n            \"Number of satellites in each plane must be the same. \"\n            f\"plane_id={plane_id}, next_plane_id={next_plane_id}\"\n        )\n        for sat_idx, satellite in enumerate(satellites_in_plane):\n            src = satellite\n            dst = satellites_in_next_plane[(sat_idx + inter_plane_offset_) % len(satellites_in_plane)]\n            graph.add_edge(src, dst)\n\n    return graph\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManualG2CTopologyBuilder","title":"ManualG2CTopologyBuilder","text":"<pre><code>ManualG2CTopologyBuilder(\n    custom_connections: dict[\n        Gateway | StationaryOnGroundUser,\n        ConstellationSatellite,\n    ],\n)\n</code></pre> <p>               Bases: <code>GroundToConstellationTopologyBuilder[SatelliteConstellation, Gateway | StationaryOnGroundUser, Graph]</code></p> Source code in <code>src/cosmica/topology/ground_to_constellation.py</code> <pre><code>def __init__(self, custom_connections: dict[Gateway | StationaryOnGroundUser, ConstellationSatellite]) -&gt; None:\n    self.custom_connections: dict[Gateway | StationaryOnGroundUser, ConstellationSatellite] = custom_connections\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManualG2CTopologyBuilder.custom_connections","title":"custom_connections  <code>instance-attribute</code>","text":"<pre><code>custom_connections: dict[\n    Gateway | StationaryOnGroundUser, ConstellationSatellite\n] = custom_connections\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.ManualG2CTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[\n        Gateway | StationaryOnGroundUser\n    ],\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> Source code in <code>src/cosmica/topology/ground_to_constellation.py</code> <pre><code>def build(\n    self,\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[Gateway | StationaryOnGroundUser],\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    logger.info(f\"Number of time steps: {len(dynamics_data.time)}\")\n    ground_nodes = list(ground_nodes)\n\n    def construct_graph() -&gt; nx.Graph:\n        graph = nx.Graph()\n        graph.add_nodes_from(constellation.satellites)\n        graph.add_nodes_from(ground_nodes)\n\n        for ground_node, satellite in self.custom_connections.items():\n            graph.add_edge(ground_node, satellite)\n\n        return graph\n\n    # dynamics_data.time \u306e\u9577\u3055\u306b\u5fdc\u3058\u305f\u30b0\u30e9\u30d5\u3092\u8fd4\u3059\n    return [construct_graph() for _ in range(len(dynamics_data.time))]\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.MaxConnectionTimeUS2CTopologyBuilder","title":"MaxConnectionTimeUS2CTopologyBuilder","text":"<pre><code>MaxConnectionTimeUS2CTopologyBuilder(\n    max_distance: float = float(\"inf\"),\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n)\n</code></pre> <p>               Bases: <code>UserSatelliteToConstellationTopologyBuilder[SatelliteConstellation, UserSatellite, Graph]</code></p> <p>Topology builder connecting user satellites to constellation with longest connection time.</p> <p>This builder calculates the visibility duration between user satellites and constellation satellites, then selects the constellation satellite that provides the longest continuous connection time for each user satellite. This minimizes handovers and provides stable connections.</p> Source code in <code>src/cosmica/topology/usersatellite_to_constellation.py</code> <pre><code>def __init__(\n    self,\n    max_distance: float = float(\"inf\"),\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n) -&gt; None:\n    self.max_distance = max_distance\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n    self.sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.MaxConnectionTimeUS2CTopologyBuilder.max_distance","title":"max_distance  <code>instance-attribute</code>","text":"<pre><code>max_distance = max_distance\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.MaxConnectionTimeUS2CTopologyBuilder.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.MaxConnectionTimeUS2CTopologyBuilder.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.MaxConnectionTimeUS2CTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: SatelliteConstellation,\n    user_satellites: Collection[UserSatellite],\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> Source code in <code>src/cosmica/topology/usersatellite_to_constellation.py</code> <pre><code>def build(  # noqa: C901, PLR0912, PLR0915\n    self,\n    *,\n    constellation: SatelliteConstellation,\n    user_satellites: Collection[UserSatellite],\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    logger.info(f\"Building user-to-constellation topology for {len(user_satellites)} user satellites\")\n    logger.info(f\"Number of time steps: {len(dynamics_data.time)}\")\n\n    user_satellites = list(user_satellites)\n    constellation_satellites = list(constellation.satellites)\n\n    n_time = len(dynamics_data.time)\n    n_users = len(user_satellites)\n    n_constellation = len(constellation_satellites)\n\n    # Calculate visibility based on distance, sun exclusion angle, and relative angular velocity constraints\n    visibility = np.zeros((n_users, n_constellation, n_time), dtype=np.bool_)\n\n    for (user_idx, user_sat), (const_idx, const_sat) in product(\n        enumerate(user_satellites),\n        enumerate(constellation_satellites),\n    ):\n        # Get positions and velocities for user and constellation satellites\n        user_pos_eci = dynamics_data.satellite_position_eci[user_sat]\n        const_pos_eci = dynamics_data.satellite_position_eci[const_sat]\n        user_vel_eci = dynamics_data.satellite_velocity_eci[user_sat]\n        const_vel_eci = dynamics_data.satellite_velocity_eci[const_sat]\n        user_att_ang_vel_eci = dynamics_data.satellite_attitude_angular_velocity_eci[user_sat]\n        const_att_ang_vel_eci = dynamics_data.satellite_attitude_angular_velocity_eci[const_sat]\n\n        # Calculate relative position and velocity vectors\n        relative_pos_eci = const_pos_eci - user_pos_eci\n        relative_vel_eci = const_vel_eci - user_vel_eci\n\n        # Calculate distances\n        distances = np.linalg.norm(relative_pos_eci, axis=1)\n\n        # Calculate relative angular velocities for each time step\n        relative_angular_velocities_list = []\n        for t in range(n_time):\n            distance = distances[t]\n            if distance &gt; 0:\n                # Calculate relative angular velocity due to translational motion\n                relative_angular_velocity_translational = (\n                    np.cross(relative_pos_eci[t], relative_vel_eci[t]) / distance**2\n                )\n\n                # Calculate relative angular velocities considering attitude angular velocities\n                rel_ang_vel_user = relative_angular_velocity_translational - user_att_ang_vel_eci[t]\n                rel_ang_vel_const = -relative_angular_velocity_translational - const_att_ang_vel_eci[t]\n\n                # Take maximum of the two relative angular velocities\n                max_rel_ang_vel = np.maximum(\n                    np.linalg.norm(rel_ang_vel_user),\n                    np.linalg.norm(rel_ang_vel_const),\n                )\n                relative_angular_velocities_list.append(float(max_rel_ang_vel))\n            else:\n                relative_angular_velocities_list.append(float(\"inf\"))\n\n        relative_angular_velocities = np.array(relative_angular_velocities_list)\n\n        # Calculate sun angles for each time step\n        sun_angles = np.array(\n            [angle_between(relative_pos_eci[t], dynamics_data.sun_direction_eci[t]) for t in range(n_time)],\n        )\n\n        # Check all constraints:\n        # 1. Distance constraint\n        distance_ok = distances &lt;= self.max_distance\n        # 2. Sun exclusion angle constraint (avoid pointing too close to sun)\n        sun_ok = (sun_angles &gt;= self.sun_exclusion_angle) &amp; (sun_angles &lt;= (np.pi - self.sun_exclusion_angle))\n        # 3. Relative angular velocity constraint\n        angular_velocity_ok = relative_angular_velocities &lt;= self.max_relative_angular_velocity\n\n        # Combined visibility\n        visibility[user_idx, const_idx, :] = distance_ok &amp; sun_ok &amp; angular_velocity_ok\n\n    # Calculate remaining connection time for each user-constellation pair\n    remaining_connection_time = np.zeros((n_users, n_constellation, n_time), dtype=np.int_)\n\n    # Traverse time backwards to calculate remaining visibility duration\n    for time_idx in reversed(range(n_time)):\n        if time_idx == n_time - 1:\n            # Last time step: 1 if visible, 0 otherwise\n            remaining_connection_time[:, :, time_idx] = visibility[:, :, time_idx].astype(int)\n        else:\n            # If visible at current time, add 1 to future remaining time\n            remaining_connection_time[:, :, time_idx] = np.where(\n                visibility[:, :, time_idx],\n                remaining_connection_time[:, :, time_idx + 1] + 1,\n                0,\n            )\n\n    # Select constellation satellite for each user satellite at each time\n    selected_constellation_idx = np.full(n_users, -1, dtype=np.int_)  # -1 means no connection\n    link_available = np.zeros((n_users, n_constellation, n_time), dtype=np.bool_)\n\n    def select_max_connection_satellite(user_idx: int, time_idx: int) -&gt; None:\n        \"\"\"Select the constellation satellite with maximum remaining connection time.\"\"\"\n        # Get remaining connection times for this user\n        user_remaining_times = remaining_connection_time[user_idx, :, time_idx].copy()\n\n        # Mask out satellites already connected to other users\n        for other_user_idx in range(n_users):\n            if other_user_idx != user_idx and selected_constellation_idx[other_user_idx] &gt;= 0:\n                user_remaining_times[selected_constellation_idx[other_user_idx]] = 0\n\n        # Select satellite with maximum remaining connection time\n        if user_remaining_times.max() &gt; 0:\n            selected_constellation_idx[user_idx] = int(np.argmax(user_remaining_times))\n        else:\n            selected_constellation_idx[user_idx] = -1\n\n    # Build topology for each time step\n    for time_idx in range(n_time):\n        # Reset selections for this time step\n        selected_constellation_idx.fill(-1)\n\n        # Process each user satellite\n        for user_idx in range(n_users):\n            if time_idx == 0:\n                # First time step: select satellite with longest total connection time\n                select_max_connection_satellite(user_idx, time_idx)\n            else:\n                # Check if previously connected satellite is still visible\n                prev_selected = np.where(link_available[user_idx, :, time_idx - 1])[0]\n                if len(prev_selected) &gt; 0:\n                    prev_sat_idx = prev_selected[0]\n                    # If still visible, maintain connection\n                    if visibility[user_idx, prev_sat_idx, time_idx]:\n                        selected_constellation_idx[user_idx] = prev_sat_idx\n                    else:\n                        # Previous satellite no longer visible, select new one\n                        select_max_connection_satellite(user_idx, time_idx)\n                else:\n                    # No previous connection, select new satellite\n                    select_max_connection_satellite(user_idx, time_idx)\n\n            # Mark the selected connection as available\n            if selected_constellation_idx[user_idx] &gt;= 0:\n                link_available[user_idx, selected_constellation_idx[user_idx], time_idx] = True\n\n    def construct_graph(link_available_at_time: npt.NDArray[np.bool_]) -&gt; nx.Graph:\n        \"\"\"Construct NetworkX graph from link availability matrix.\"\"\"\n        graph = nx.Graph()\n\n        # Add all nodes\n        graph.add_nodes_from(user_satellites)\n        graph.add_nodes_from(constellation_satellites)\n\n        # Add edges based on link availability\n        for user_idx, user_sat in enumerate(user_satellites):\n            for const_idx, const_sat in enumerate(constellation_satellites):\n                if link_available_at_time[user_idx, const_idx]:\n                    graph.add_edge(user_sat, const_sat)\n\n        return graph\n\n    # Return list of graphs, one for each time step\n    return [construct_graph(link_available[:, :, time_idx]) for time_idx in range(n_time)]\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.MaxVisibilityHandOverG2CTopologyBuilder","title":"MaxVisibilityHandOverG2CTopologyBuilder","text":"<p>               Bases: <code>GroundToConstellationTopologyBuilder[SatelliteConstellation, Gateway | StationaryOnGroundUser, Graph]</code></p>"},{"location":"reference/cosmica/topology/#cosmica.topology.MaxVisibilityHandOverG2CTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[\n        Gateway | StationaryOnGroundUser\n    ],\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> Source code in <code>src/cosmica/topology/ground_to_constellation.py</code> <pre><code>def build(  # noqa: C901\n    self,\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[Gateway | StationaryOnGroundUser],\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    logger.info(f\"Number of time steps: {len(dynamics_data.time)}\")\n    ground_nodes = list(ground_nodes)\n\n    n_time = len(dynamics_data.time)\n    n_gateways = len(ground_nodes)\n    n_satellites = len(dynamics_data.satellite_position_eci)\n    visibility = np.zeros((n_gateways, n_satellites, n_time), dtype=np.bool_)\n    for (ground_node_idx, ground_node), (sat_idx, satellite) in product(\n        enumerate(ground_nodes),\n        enumerate(constellation.satellites),\n    ):\n        _, elevation, _ = ecef2aer(\n            x=dynamics_data.satellite_position_ecef[satellite][:, 0],\n            y=dynamics_data.satellite_position_ecef[satellite][:, 1],\n            z=dynamics_data.satellite_position_ecef[satellite][:, 2],\n            lat0=ground_node.latitude,\n            lon0=ground_node.longitude,\n            h0=ground_node.altitude,\n            deg=False,\n        )\n        visibility[ground_node_idx, sat_idx, :] = elevation &gt;= ground_node.minimum_elevation\n\n    # \u6b8b\u63a5\u7d9a\u6642\u9593\u3092\u8a08\u7b97\n    left_visibility_time_step = np.zeros((n_gateways, n_satellites, n_time), dtype=np.int_)\n    for time_idx in reversed(range(n_time)):\n        left_visibility_time_step[:, :, time_idx] = (\n            np.where(\n                visibility[:, :, time_idx],\n                left_visibility_time_step[:, :, time_idx + 1] + 1,\n                0,\n            )\n            if time_idx != n_time - 1\n            else visibility[:, :, time_idx].astype(int)\n        )\n\n    # \u5730\u4e0a\u5c40\u306b\u5bfe\u3059\u308b\u901a\u4fe1\u3059\u308b\u885b\u661f\u306e\u9078\u629e\n    select_sat_idx = np.full(\n        n_gateways,\n        -1,\n        dtype=np.int_,\n    )  # -1: \u901a\u4fe1\u3057\u306a\u3044 TODO: -1\u3067\u306a\u304fNan\u3057\u305f\u3044\u304c, int\u578b\u3067\u306f\u30a8\u30e9\u30fc\u304c\u51fa\u308b\n    # connection_accumulation_time = np.zeros(n_gateways, dtype=np.float64)\n    link_available = np.zeros((n_gateways, n_satellites, n_time), dtype=np.bool_)\n\n    def select_max_visibility_satellite(\n        ground_node_idx: int,\n        time_idx: int,\n    ) -&gt; None:\n        # \u4ed6\u306e\u5730\u4e0a\u5c40\u3068\u901a\u4fe1\u3057\u3066\u3044\u308b\u885b\u661f\u306f\u9664\u304f\n        masked_left_visibility_time_step = np.copy(left_visibility_time_step[ground_node_idx, :, time_idx])\n        for sat_idx in select_sat_idx:\n            if sat_idx == -1:\n                continue\n            masked_left_visibility_time_step[sat_idx] = 0\n        # \u6b8b\u308a\u53ef\u8996\u6642\u9593\u304c\u6700\u5927\u306e\u885b\u661f\u3092\u9078\u629e\n        select_sat_idx[ground_node_idx] = np.argmax(masked_left_visibility_time_step)\n\n    for time_idx in range(n_time):\n        for ground_node_idx, _ground_node in enumerate(ground_nodes):\n            if time_idx == 0:\n                # \u3059\u3079\u3066\u306e\u885b\u661f\u306b\u5bfe\u3057\u3066\u53ef\u8996\u3067\u306a\u3044\n                if left_visibility_time_step[ground_node_idx, :, time_idx].sum == 0:\n                    select_sat_idx[ground_node_idx] = -1\n                    continue\n                # \u6b8b\u308a\u53ef\u8996\u6642\u9593\u304c\u6700\u5927\u306e\u885b\u661f\u3092\u9078\u629e\n                select_max_visibility_satellite(ground_node_idx, time_idx)\n            else:\n                # \u3059\u3079\u3066\u306e\u885b\u661f\u306b\u5bfe\u3057\u3066\u53ef\u8996\u3067\u306a\u3044\n                if left_visibility_time_step[ground_node_idx, :, time_idx].sum == 0:\n                    select_sat_idx[ground_node_idx] = -1\n                    continue\n                # \u524d\u306e\u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u3067\u63a5\u7d9a\u3057\u3066\u3044\u308b\u885b\u661f\u304c\u3044\u308b\n                if select_sat_idx[ground_node_idx] &gt;= 0:\n                    # \u73fe\u5728\u306e\u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u3082\u53ef\u8996 \u2192 \u540c\u3058\u885b\u661f\u306b\u63a5\u7d9a\n                    if left_visibility_time_step[ground_node_idx, select_sat_idx[ground_node_idx], time_idx] &gt; 0:\n                        # # \u7d2f\u7a4d\u9023\u7d9a\u53ef\u8996\u6642\u9593\u3092\u66f4\u65b0\n                        # connection_accumulation_time[ground_node_idx] += (\n                        #     dynamics_data.time[time_idx] - dynamics_data.time[time_idx - 1]\n                        # ) / np.timedelta64(1, \"s\")\n                        pass\n                    else:\n                        # \u6b8b\u308a\u53ef\u8996\u6642\u9593\u304c\u6700\u5927\u306e\u885b\u661f\u3092\u9078\u629e\n                        select_max_visibility_satellite(ground_node_idx, time_idx)\n                # \u524d\u306e\u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u3067\u63a5\u7d9a\u3057\u3066\u3044\u308b\u885b\u661f\u304c\u3044\u306a\u3044\n                else:\n                    # \u6b8b\u308a\u53ef\u8996\u6642\u9593\u304c\u6700\u5927\u306e\u885b\u661f\u3092\u9078\u629e\n                    select_max_visibility_satellite(ground_node_idx, time_idx)\n            link_available[ground_node_idx, select_sat_idx[ground_node_idx], time_idx] = True\n\n    def construct_graph(link_available: npt.NDArray[np.bool_]) -&gt; nx.Graph:\n        graph = nx.Graph()\n        graph.add_nodes_from(constellation.satellites)\n        graph.add_nodes_from(ground_nodes)\n\n        for (ground_node_idx, ground_node), (sat_idx, satellite) in product(\n            enumerate(ground_nodes),\n            enumerate(constellation.satellites),\n        ):\n            if link_available[ground_node_idx, sat_idx]:\n                graph.add_edge(ground_node, satellite)\n\n        return graph\n\n    return [construct_graph(link_available[:, :, time_idx]) for time_idx in range(len(dynamics_data.time))]\n</code></pre>"},{"location":"reference/cosmica/topology/#cosmica.topology.UserSatelliteToConstellationTopologyBuilder","title":"UserSatelliteToConstellationTopologyBuilder","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/topology/#cosmica.topology.UserSatelliteToConstellationTopologyBuilder.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(\n    *,\n    constellation: TConstellation,\n    user_satellites: Collection[TUserSatellite],\n    dynamics_data: DynamicsData\n) -&gt; list[TGraph]\n</code></pre> <p>Build time-varying topology connecting user satellites to constellation.</p> Source code in <code>src/cosmica/topology/usersatellite_to_constellation.py</code> <pre><code>@abstractmethod\ndef build(\n    self,\n    *,\n    constellation: TConstellation,\n    user_satellites: Collection[TUserSatellite],\n    dynamics_data: DynamicsData,\n) -&gt; list[TGraph]:\n    \"\"\"Build time-varying topology connecting user satellites to constellation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/cosmica/topology/gateway_to_gateway/","title":"gateway_to_gateway","text":""},{"location":"reference/cosmica/topology/gateway_to_gateway/#cosmica.topology.gateway_to_gateway","title":"cosmica.topology.gateway_to_gateway","text":""},{"location":"reference/cosmica/topology/gateway_to_gateway/#cosmica.topology.gateway_to_gateway.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['GatewayToGatewayTopologyBuilder']\n</code></pre>"},{"location":"reference/cosmica/topology/gateway_to_gateway/#cosmica.topology.gateway_to_gateway.GatewayToGatewayTopologyBuilder","title":"GatewayToGatewayTopologyBuilder","text":""},{"location":"reference/cosmica/topology/gateway_to_gateway/#cosmica.topology.gateway_to_gateway.GatewayToGatewayTopologyBuilder.build","title":"build","text":"<pre><code>build(*, gateways: Collection[Gateway[Hashable]]) -&gt; Graph\n</code></pre> Source code in <code>src/cosmica/topology/gateway_to_gateway.py</code> <pre><code>def build(\n    self,\n    *,\n    gateways: Collection[Gateway[Hashable]],\n) -&gt; nx.Graph:\n    graph = nx.Graph()\n    gateway_list = list(gateways)\n    graph.add_nodes_from(gateway_list)\n\n    # \u3059\u3079\u3066\u306egateway\u540c\u58eb\u3092\u63a5\u7d9a\u3059\u308b(\u5b8c\u5168\u30b0\u30e9\u30d5)\n    for i, gateway1 in enumerate(gateway_list):\n        for gateway2 in gateway_list[i + 1 :]:\n            graph.add_edge(gateway1, gateway2)\n\n    return graph\n</code></pre>"},{"location":"reference/cosmica/topology/gateway_to_internet/","title":"gateway_to_internet","text":""},{"location":"reference/cosmica/topology/gateway_to_internet/#cosmica.topology.gateway_to_internet","title":"cosmica.topology.gateway_to_internet","text":""},{"location":"reference/cosmica/topology/gateway_to_internet/#cosmica.topology.gateway_to_internet.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['GatewayToInternetTopologyBuilder']\n</code></pre>"},{"location":"reference/cosmica/topology/gateway_to_internet/#cosmica.topology.gateway_to_internet.GatewayToInternetTopologyBuilder","title":"GatewayToInternetTopologyBuilder","text":""},{"location":"reference/cosmica/topology/gateway_to_internet/#cosmica.topology.gateway_to_internet.GatewayToInternetTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *, gateways: Collection[Gateway], internet: Internet\n) -&gt; Graph\n</code></pre> Source code in <code>src/cosmica/topology/gateway_to_internet.py</code> <pre><code>def build(\n    self,\n    *,\n    gateways: Collection[Gateway],\n    internet: Internet,\n) -&gt; nx.Graph:\n    graph = nx.Graph()\n    graph.add_nodes_from(gateways)\n    graph.add_node(internet)\n    graph.add_edges_from((gateway, internet) for gateway in gateways)\n\n    return graph\n</code></pre>"},{"location":"reference/cosmica/topology/ground_to_constellation/","title":"ground_to_constellation","text":""},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation","title":"cosmica.topology.ground_to_constellation","text":""},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"ElevationBasedG2CTopologyBuilder\",\n    \"GroundToConstellationTopologyBuilder\",\n    \"ManualG2CTopologyBuilder\",\n]\n</code></pre>"},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.ElevationBasedG2CTopologyBuilder","title":"ElevationBasedG2CTopologyBuilder","text":"<p>               Bases: <code>GroundToConstellationTopologyBuilder[SatelliteConstellation, Gateway | StationaryOnGroundUser, Graph]</code></p>"},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.ElevationBasedG2CTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[\n        Gateway | StationaryOnGroundUser\n    ],\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> Source code in <code>src/cosmica/topology/ground_to_constellation.py</code> <pre><code>def build(\n    self,\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[Gateway | StationaryOnGroundUser],\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    logger.info(f\"Number of time steps: {len(dynamics_data.time)}\")\n    ground_nodes = list(ground_nodes)\n\n    n_satellites = len(dynamics_data.satellite_position_eci)\n    visibility = np.zeros((len(ground_nodes), n_satellites, len(dynamics_data.time)), dtype=np.bool_)\n    for (ground_node_idx, ground_node), (sat_idx, satellite) in product(\n        enumerate(ground_nodes),\n        enumerate(constellation.satellites),\n    ):\n        _, elevation, _ = ecef2aer(\n            x=dynamics_data.satellite_position_ecef[satellite][:, 0],\n            y=dynamics_data.satellite_position_ecef[satellite][:, 1],\n            z=dynamics_data.satellite_position_ecef[satellite][:, 2],\n            lat0=ground_node.latitude,\n            lon0=ground_node.longitude,\n            h0=ground_node.altitude,\n            deg=False,\n        )\n        visibility[ground_node_idx, sat_idx, :] = elevation &gt;= ground_node.minimum_elevation\n\n    def construct_graph(visibility: npt.NDArray[np.bool_]) -&gt; nx.Graph:\n        graph = nx.Graph()\n        graph.add_nodes_from(constellation.satellites)\n        graph.add_nodes_from(ground_nodes)\n\n        for (ground_node_idx, ground_node), (sat_idx, satellite) in product(\n            enumerate(ground_nodes),\n            enumerate(constellation.satellites),\n        ):\n            if visibility[ground_node_idx, sat_idx]:\n                graph.add_edge(ground_node, satellite)\n\n        return graph\n\n    return [construct_graph(visibility[:, :, time_idx]) for time_idx in range(len(dynamics_data.time))]\n</code></pre>"},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.GroundToConstellationTopologyBuilder","title":"GroundToConstellationTopologyBuilder","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.GroundToConstellationTopologyBuilder.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(\n    *,\n    constellation: TConstellation,\n    ground_nodes: Collection[TNode],\n    dynamics_data: DynamicsData\n) -&gt; list[TGraph]\n</code></pre> Source code in <code>src/cosmica/topology/ground_to_constellation.py</code> <pre><code>@abstractmethod\ndef build(\n    self,\n    *,\n    constellation: TConstellation,\n    ground_nodes: Collection[TNode],\n    dynamics_data: DynamicsData,\n) -&gt; list[TGraph]: ...\n</code></pre>"},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.ManualG2CTopologyBuilder","title":"ManualG2CTopologyBuilder","text":"<pre><code>ManualG2CTopologyBuilder(\n    custom_connections: dict[\n        Gateway | StationaryOnGroundUser,\n        ConstellationSatellite,\n    ],\n)\n</code></pre> <p>               Bases: <code>GroundToConstellationTopologyBuilder[SatelliteConstellation, Gateway | StationaryOnGroundUser, Graph]</code></p> Source code in <code>src/cosmica/topology/ground_to_constellation.py</code> <pre><code>def __init__(self, custom_connections: dict[Gateway | StationaryOnGroundUser, ConstellationSatellite]) -&gt; None:\n    self.custom_connections: dict[Gateway | StationaryOnGroundUser, ConstellationSatellite] = custom_connections\n</code></pre>"},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.ManualG2CTopologyBuilder.custom_connections","title":"custom_connections  <code>instance-attribute</code>","text":"<pre><code>custom_connections: dict[\n    Gateway | StationaryOnGroundUser, ConstellationSatellite\n] = custom_connections\n</code></pre>"},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.ManualG2CTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[\n        Gateway | StationaryOnGroundUser\n    ],\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> Source code in <code>src/cosmica/topology/ground_to_constellation.py</code> <pre><code>def build(\n    self,\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[Gateway | StationaryOnGroundUser],\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    logger.info(f\"Number of time steps: {len(dynamics_data.time)}\")\n    ground_nodes = list(ground_nodes)\n\n    def construct_graph() -&gt; nx.Graph:\n        graph = nx.Graph()\n        graph.add_nodes_from(constellation.satellites)\n        graph.add_nodes_from(ground_nodes)\n\n        for ground_node, satellite in self.custom_connections.items():\n            graph.add_edge(ground_node, satellite)\n\n        return graph\n\n    # dynamics_data.time \u306e\u9577\u3055\u306b\u5fdc\u3058\u305f\u30b0\u30e9\u30d5\u3092\u8fd4\u3059\n    return [construct_graph() for _ in range(len(dynamics_data.time))]\n</code></pre>"},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.MaxVisibilityHandOverG2CTopologyBuilder","title":"MaxVisibilityHandOverG2CTopologyBuilder","text":"<p>               Bases: <code>GroundToConstellationTopologyBuilder[SatelliteConstellation, Gateway | StationaryOnGroundUser, Graph]</code></p>"},{"location":"reference/cosmica/topology/ground_to_constellation/#cosmica.topology.ground_to_constellation.MaxVisibilityHandOverG2CTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[\n        Gateway | StationaryOnGroundUser\n    ],\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> Source code in <code>src/cosmica/topology/ground_to_constellation.py</code> <pre><code>def build(  # noqa: C901\n    self,\n    *,\n    constellation: SatelliteConstellation,\n    ground_nodes: Collection[Gateway | StationaryOnGroundUser],\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    logger.info(f\"Number of time steps: {len(dynamics_data.time)}\")\n    ground_nodes = list(ground_nodes)\n\n    n_time = len(dynamics_data.time)\n    n_gateways = len(ground_nodes)\n    n_satellites = len(dynamics_data.satellite_position_eci)\n    visibility = np.zeros((n_gateways, n_satellites, n_time), dtype=np.bool_)\n    for (ground_node_idx, ground_node), (sat_idx, satellite) in product(\n        enumerate(ground_nodes),\n        enumerate(constellation.satellites),\n    ):\n        _, elevation, _ = ecef2aer(\n            x=dynamics_data.satellite_position_ecef[satellite][:, 0],\n            y=dynamics_data.satellite_position_ecef[satellite][:, 1],\n            z=dynamics_data.satellite_position_ecef[satellite][:, 2],\n            lat0=ground_node.latitude,\n            lon0=ground_node.longitude,\n            h0=ground_node.altitude,\n            deg=False,\n        )\n        visibility[ground_node_idx, sat_idx, :] = elevation &gt;= ground_node.minimum_elevation\n\n    # \u6b8b\u63a5\u7d9a\u6642\u9593\u3092\u8a08\u7b97\n    left_visibility_time_step = np.zeros((n_gateways, n_satellites, n_time), dtype=np.int_)\n    for time_idx in reversed(range(n_time)):\n        left_visibility_time_step[:, :, time_idx] = (\n            np.where(\n                visibility[:, :, time_idx],\n                left_visibility_time_step[:, :, time_idx + 1] + 1,\n                0,\n            )\n            if time_idx != n_time - 1\n            else visibility[:, :, time_idx].astype(int)\n        )\n\n    # \u5730\u4e0a\u5c40\u306b\u5bfe\u3059\u308b\u901a\u4fe1\u3059\u308b\u885b\u661f\u306e\u9078\u629e\n    select_sat_idx = np.full(\n        n_gateways,\n        -1,\n        dtype=np.int_,\n    )  # -1: \u901a\u4fe1\u3057\u306a\u3044 TODO: -1\u3067\u306a\u304fNan\u3057\u305f\u3044\u304c, int\u578b\u3067\u306f\u30a8\u30e9\u30fc\u304c\u51fa\u308b\n    # connection_accumulation_time = np.zeros(n_gateways, dtype=np.float64)\n    link_available = np.zeros((n_gateways, n_satellites, n_time), dtype=np.bool_)\n\n    def select_max_visibility_satellite(\n        ground_node_idx: int,\n        time_idx: int,\n    ) -&gt; None:\n        # \u4ed6\u306e\u5730\u4e0a\u5c40\u3068\u901a\u4fe1\u3057\u3066\u3044\u308b\u885b\u661f\u306f\u9664\u304f\n        masked_left_visibility_time_step = np.copy(left_visibility_time_step[ground_node_idx, :, time_idx])\n        for sat_idx in select_sat_idx:\n            if sat_idx == -1:\n                continue\n            masked_left_visibility_time_step[sat_idx] = 0\n        # \u6b8b\u308a\u53ef\u8996\u6642\u9593\u304c\u6700\u5927\u306e\u885b\u661f\u3092\u9078\u629e\n        select_sat_idx[ground_node_idx] = np.argmax(masked_left_visibility_time_step)\n\n    for time_idx in range(n_time):\n        for ground_node_idx, _ground_node in enumerate(ground_nodes):\n            if time_idx == 0:\n                # \u3059\u3079\u3066\u306e\u885b\u661f\u306b\u5bfe\u3057\u3066\u53ef\u8996\u3067\u306a\u3044\n                if left_visibility_time_step[ground_node_idx, :, time_idx].sum == 0:\n                    select_sat_idx[ground_node_idx] = -1\n                    continue\n                # \u6b8b\u308a\u53ef\u8996\u6642\u9593\u304c\u6700\u5927\u306e\u885b\u661f\u3092\u9078\u629e\n                select_max_visibility_satellite(ground_node_idx, time_idx)\n            else:\n                # \u3059\u3079\u3066\u306e\u885b\u661f\u306b\u5bfe\u3057\u3066\u53ef\u8996\u3067\u306a\u3044\n                if left_visibility_time_step[ground_node_idx, :, time_idx].sum == 0:\n                    select_sat_idx[ground_node_idx] = -1\n                    continue\n                # \u524d\u306e\u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u3067\u63a5\u7d9a\u3057\u3066\u3044\u308b\u885b\u661f\u304c\u3044\u308b\n                if select_sat_idx[ground_node_idx] &gt;= 0:\n                    # \u73fe\u5728\u306e\u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u3082\u53ef\u8996 \u2192 \u540c\u3058\u885b\u661f\u306b\u63a5\u7d9a\n                    if left_visibility_time_step[ground_node_idx, select_sat_idx[ground_node_idx], time_idx] &gt; 0:\n                        # # \u7d2f\u7a4d\u9023\u7d9a\u53ef\u8996\u6642\u9593\u3092\u66f4\u65b0\n                        # connection_accumulation_time[ground_node_idx] += (\n                        #     dynamics_data.time[time_idx] - dynamics_data.time[time_idx - 1]\n                        # ) / np.timedelta64(1, \"s\")\n                        pass\n                    else:\n                        # \u6b8b\u308a\u53ef\u8996\u6642\u9593\u304c\u6700\u5927\u306e\u885b\u661f\u3092\u9078\u629e\n                        select_max_visibility_satellite(ground_node_idx, time_idx)\n                # \u524d\u306e\u30bf\u30a4\u30e0\u30b9\u30c6\u30c3\u30d7\u3067\u63a5\u7d9a\u3057\u3066\u3044\u308b\u885b\u661f\u304c\u3044\u306a\u3044\n                else:\n                    # \u6b8b\u308a\u53ef\u8996\u6642\u9593\u304c\u6700\u5927\u306e\u885b\u661f\u3092\u9078\u629e\n                    select_max_visibility_satellite(ground_node_idx, time_idx)\n            link_available[ground_node_idx, select_sat_idx[ground_node_idx], time_idx] = True\n\n    def construct_graph(link_available: npt.NDArray[np.bool_]) -&gt; nx.Graph:\n        graph = nx.Graph()\n        graph.add_nodes_from(constellation.satellites)\n        graph.add_nodes_from(ground_nodes)\n\n        for (ground_node_idx, ground_node), (sat_idx, satellite) in product(\n            enumerate(ground_nodes),\n            enumerate(constellation.satellites),\n        ):\n            if link_available[ground_node_idx, sat_idx]:\n                graph.add_edge(ground_node, satellite)\n\n        return graph\n\n    return [construct_graph(link_available[:, :, time_idx]) for time_idx in range(len(dynamics_data.time))]\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/","title":"intra_constellation","text":""},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation","title":"cosmica.topology.intra_constellation","text":""},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"ConstellationTimeSeriesTopologyBuilder\",\n    \"ConstellationTopologyBuilder\",\n    \"ManhattanTimeSeriesTopologyBuilder\",\n    \"ManhattanTopologyBuilder\",\n]\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ConstellationTimeSeriesTopologyBuilder","title":"ConstellationTimeSeriesTopologyBuilder","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ConstellationTimeSeriesTopologyBuilder.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(\n    *,\n    constellation: TConstellation,\n    dynamics_data: DynamicsData\n) -&gt; list[TGraph]\n</code></pre> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>@abstractmethod\ndef build(\n    self,\n    *,\n    constellation: TConstellation,\n    dynamics_data: DynamicsData,\n) -&gt; list[TGraph]: ...\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ConstellationTopologyBuilder","title":"ConstellationTopologyBuilder","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ConstellationTopologyBuilder.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(*, constellation: TConstellation) -&gt; TGraph\n</code></pre> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>@abstractmethod\ndef build(\n    self,\n    *,\n    constellation: TConstellation,\n) -&gt; TGraph: ...\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ManhattanTimeSeriesTopologyBuilder","title":"ManhattanTimeSeriesTopologyBuilder","text":"<pre><code>ManhattanTimeSeriesTopologyBuilder(\n    *,\n    inter_plane_offset: int = 0,\n    last_to_first_plane_offset: int = 0,\n    max_latitude: float = deg2rad(90.0)\n)\n</code></pre> <p>               Bases: <code>ConstellationTimeSeriesTopologyBuilder[MultiOrbitalPlaneConstellation[CircularSatelliteOrbit], Graph]</code></p> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_plane_offset: int = 0,\n    last_to_first_plane_offset: int = 0,\n    max_latitude: float = np.deg2rad(90.0),\n) -&gt; None:\n    self.inter_plane_offset = inter_plane_offset\n    self.last_to_first_plane_offset = last_to_first_plane_offset\n    self.max_latitude = max_latitude\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ManhattanTimeSeriesTopologyBuilder.inter_plane_offset","title":"inter_plane_offset  <code>instance-attribute</code>","text":"<pre><code>inter_plane_offset = inter_plane_offset\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ManhattanTimeSeriesTopologyBuilder.last_to_first_plane_offset","title":"last_to_first_plane_offset  <code>instance-attribute</code>","text":"<pre><code>last_to_first_plane_offset = last_to_first_plane_offset\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ManhattanTimeSeriesTopologyBuilder.max_latitude","title":"max_latitude  <code>instance-attribute</code>","text":"<pre><code>max_latitude = max_latitude\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ManhattanTimeSeriesTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: MultiOrbitalPlaneConstellation,\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>def build(\n    self,\n    *,\n    constellation: MultiOrbitalPlaneConstellation,\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    def construct_graph(time_idx: int) -&gt; nx.Graph:\n        graph = nx.Graph()\n\n        # Add nodes\n        for satellite in constellation.satellites:\n            graph.add_node(satellite)\n\n        # Intra-plane edges\n        # Connect satellites to the two satellites in the same plane with the closest phase angle\n        for plane_id in constellation.plane_ids:\n            satellites_in_plane = sorted(\n                constellation.plane_id_to_satellites[plane_id],\n                key=lambda satellite: constellation.satellite_orbits[satellite].phase_at_epoch,\n            )\n            for plane_idx, satellite in enumerate(satellites_in_plane):\n                src, dst = satellite, satellites_in_plane[(plane_idx + 1) % len(satellites_in_plane)]\n                graph.add_edge(src, dst)\n\n        # Inter-plane edges\n        def _get_first_satellite(plane_id: int) -&gt; ConstellationSatellite:\n            return sorted(\n                constellation.plane_id_to_satellites[plane_id],\n                key=lambda satellite: satellite.id.satellite_id,\n            )[0]\n\n        # Sort planes by raan\n        plane_ids = sorted(\n            constellation.plane_ids,\n            key=lambda plane_id: constellation.satellite_orbits[_get_first_satellite(plane_id)].raan,\n        )\n        for plane_idx, plane_id in enumerate(plane_ids):\n            next_plane_id = plane_ids[(plane_idx + 1) % len(plane_ids)]\n            inter_plane_offset_ = self.inter_plane_offset\n            if plane_idx == len(plane_ids) - 1:\n                # Connect the last plane to the first plane\n                inter_plane_offset_ += self.last_to_first_plane_offset\n\n            satellites_in_plane = sorted(\n                constellation.plane_id_to_satellites[plane_id],\n                key=lambda satellite: satellite.id.satellite_id,\n            )\n            satellites_in_next_plane = sorted(\n                constellation.plane_id_to_satellites[next_plane_id],\n                key=lambda satellite: satellite.id.satellite_id,\n            )\n            assert len(satellites_in_plane) == len(satellites_in_next_plane), (\n                \"Number of satellites in each plane must be the same. \"\n                f\"plane_id={plane_id}, next_plane_id={next_plane_id}\"\n            )\n            for sat_idx, satellite in enumerate(satellites_in_plane):\n                src = satellite\n                dst = satellites_in_next_plane[(sat_idx + inter_plane_offset_) % len(satellites_in_plane)]\n\n                # Orbital intersection in the polar region\n                _, latitude_src = unit_vector_to_azimuth_elevation(\n                    normalize(dynamics_data.satellite_position_ecef[src][time_idx]),\n                )\n                _, latitude_dst = unit_vector_to_azimuth_elevation(\n                    normalize(dynamics_data.satellite_position_ecef[dst][time_idx]),\n                )\n                if abs(latitude_src) &gt; self.max_latitude and abs(latitude_dst) &gt; self.max_latitude:\n                    continue\n\n                graph.add_edge(src, dst)\n\n        # Ensure the constructed graph is returned for each time index\n        return graph\n\n    return [construct_graph(time_idx) for time_idx in range(len(dynamics_data.time))]\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ManhattanTopologyBuilder","title":"ManhattanTopologyBuilder","text":"<pre><code>ManhattanTopologyBuilder(\n    *,\n    inter_plane_offset: int = 0,\n    last_to_first_plane_offset: int = 0\n)\n</code></pre> <p>               Bases: <code>ConstellationTopologyBuilder[MultiOrbitalPlaneConstellation[CircularSatelliteOrbit], Graph]</code></p> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>def __init__(\n    self,\n    *,\n    inter_plane_offset: int = 0,\n    last_to_first_plane_offset: int = 0,\n) -&gt; None:\n    self.inter_plane_offset = inter_plane_offset\n    self.last_to_first_plane_offset = last_to_first_plane_offset\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ManhattanTopologyBuilder.inter_plane_offset","title":"inter_plane_offset  <code>instance-attribute</code>","text":"<pre><code>inter_plane_offset = inter_plane_offset\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ManhattanTopologyBuilder.last_to_first_plane_offset","title":"last_to_first_plane_offset  <code>instance-attribute</code>","text":"<pre><code>last_to_first_plane_offset = last_to_first_plane_offset\n</code></pre>"},{"location":"reference/cosmica/topology/intra_constellation/#cosmica.topology.intra_constellation.ManhattanTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *, constellation: MultiOrbitalPlaneConstellation\n) -&gt; Graph\n</code></pre> Source code in <code>src/cosmica/topology/intra_constellation.py</code> <pre><code>def build(\n    self,\n    *,\n    constellation: MultiOrbitalPlaneConstellation,\n) -&gt; nx.Graph:\n    graph = nx.Graph()\n\n    # Add nodes\n    for satellite in constellation.satellites:\n        graph.add_node(satellite)\n\n    # Intra-plane edges\n    # Connect satellites to the two satellites in the same plane with the closest phase angle\n    for plane_id in constellation.plane_ids:\n        satellites_in_plane = sorted(\n            constellation.plane_id_to_satellites[plane_id],\n            key=lambda satellite: constellation.satellite_orbits[satellite].phase_at_epoch,\n        )\n        for plane_idx, satellite in enumerate(satellites_in_plane):\n            src, dst = satellite, satellites_in_plane[(plane_idx + 1) % len(satellites_in_plane)]\n            graph.add_edge(src, dst)\n\n    # Inter-plane edges\n    def _get_first_satellite(plane_id: int) -&gt; ConstellationSatellite:\n        return sorted(\n            constellation.plane_id_to_satellites[plane_id],\n            key=lambda satellite: satellite.id.satellite_id,\n        )[0]\n\n    # Sort planes by raan\n    plane_ids = sorted(\n        constellation.plane_ids,\n        key=lambda plane_id: constellation.satellite_orbits[_get_first_satellite(plane_id)].raan,\n    )\n    for plane_idx, plane_id in enumerate(plane_ids):\n        next_plane_id = plane_ids[(plane_idx + 1) % len(plane_ids)]\n        inter_plane_offset_ = self.inter_plane_offset\n        if plane_idx == len(plane_ids) - 1:\n            # Connect the last plane to the first plane\n            inter_plane_offset_ += self.last_to_first_plane_offset\n\n        satellites_in_plane = sorted(\n            constellation.plane_id_to_satellites[plane_id],\n            key=lambda satellite: satellite.id.satellite_id,\n        )\n        satellites_in_next_plane = sorted(\n            constellation.plane_id_to_satellites[next_plane_id],\n            key=lambda satellite: satellite.id.satellite_id,\n        )\n        assert len(satellites_in_plane) == len(satellites_in_next_plane), (\n            \"Number of satellites in each plane must be the same. \"\n            f\"plane_id={plane_id}, next_plane_id={next_plane_id}\"\n        )\n        for sat_idx, satellite in enumerate(satellites_in_plane):\n            src = satellite\n            dst = satellites_in_next_plane[(sat_idx + inter_plane_offset_) % len(satellites_in_plane)]\n            graph.add_edge(src, dst)\n\n    return graph\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_gateway_to_constellation/","title":"usersatellite_gateway_to_constellation","text":""},{"location":"reference/cosmica/topology/usersatellite_gateway_to_constellation/#cosmica.topology.usersatellite_gateway_to_constellation","title":"cosmica.topology.usersatellite_gateway_to_constellation","text":""},{"location":"reference/cosmica/topology/usersatellite_gateway_to_constellation/#cosmica.topology.usersatellite_gateway_to_constellation.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['HybridUS2CG2CTopologyBuilder']\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_gateway_to_constellation/#cosmica.topology.usersatellite_gateway_to_constellation.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_gateway_to_constellation/#cosmica.topology.usersatellite_gateway_to_constellation.HybridUS2CG2CTopologyBuilder","title":"HybridUS2CG2CTopologyBuilder","text":"<pre><code>HybridUS2CG2CTopologyBuilder(\n    max_distance: float = float(\"inf\"),\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n)\n</code></pre> <p>Hybrid topology builder for user satellites and ground stations to constellation.</p> <p>This builder combines the functionality of MaxConnectionTimeUS2CTopologyBuilder and MaxVisibilityHandOverG2CTopologyBuilder. It prioritizes user satellite connections and then optimizes ground station connections based on maximum visibility duration.</p> <p>For user satellites, constraints include distance, sun exclusion angle, and relative angular velocity. For ground stations, constraints include elevation angle and sun exclusion angle.</p> Source code in <code>src/cosmica/topology/usersatellite_gateway_to_constellation.py</code> <pre><code>def __init__(\n    self,\n    max_distance: float = float(\"inf\"),\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n) -&gt; None:\n    self.max_distance = max_distance\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n    self.sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_gateway_to_constellation/#cosmica.topology.usersatellite_gateway_to_constellation.HybridUS2CG2CTopologyBuilder.max_distance","title":"max_distance  <code>instance-attribute</code>","text":"<pre><code>max_distance = max_distance\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_gateway_to_constellation/#cosmica.topology.usersatellite_gateway_to_constellation.HybridUS2CG2CTopologyBuilder.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_gateway_to_constellation/#cosmica.topology.usersatellite_gateway_to_constellation.HybridUS2CG2CTopologyBuilder.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_gateway_to_constellation/#cosmica.topology.usersatellite_gateway_to_constellation.HybridUS2CG2CTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: SatelliteConstellation,\n    user_satellites: Collection[UserSatellite],\n    ground_nodes: Collection[\n        Gateway | StationaryOnGroundUser\n    ],\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> <p>Build hybrid topology connecting user satellites and ground stations to constellation.</p> Source code in <code>src/cosmica/topology/usersatellite_gateway_to_constellation.py</code> <pre><code>def build(\n    self,\n    *,\n    constellation: SatelliteConstellation,\n    user_satellites: Collection[UserSatellite],\n    ground_nodes: Collection[Gateway | StationaryOnGroundUser],\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    \"\"\"Build hybrid topology connecting user satellites and ground stations to constellation.\"\"\"\n    logger.info(\n        f\"Building hybrid topology for {len(user_satellites)} user satellites and {len(ground_nodes)} ground nodes\",\n    )\n    logger.info(f\"Number of time steps: {len(dynamics_data.time)}\")\n\n    user_satellites = list(user_satellites)\n    ground_nodes = list(ground_nodes)\n    constellation_satellites = list(constellation.satellites)\n\n    n_time = len(dynamics_data.time)\n\n    # Calculate user satellite visibility\n    logger.info(\"Calculating user satellite visibility...\")\n    user_visibility = self._calculate_user_satellite_visibility(\n        user_satellites,\n        constellation_satellites,\n        dynamics_data,\n    )\n\n    # Calculate ground node visibility\n    logger.info(\"Calculating ground node visibility...\")\n    ground_visibility = self._calculate_ground_visibility(\n        ground_nodes,\n        constellation_satellites,\n        dynamics_data,\n    )\n\n    # Calculate remaining connection time for user satellites\n    user_remaining_connection_time = self._calculate_remaining_connection_time(user_visibility)\n\n    # Calculate remaining visibility time for ground nodes\n    ground_remaining_visibility_time = self._calculate_remaining_connection_time(ground_visibility)\n\n    # Initialize connection tracking\n    user_connections: dict[int, int] = {}  # user_idx -&gt; constellation_satellite_idx\n    ground_connections: dict[int, int] = {}  # ground_idx -&gt; constellation_satellite_idx\n\n    # Build topology for each time step\n    logger.info(\"Building topology graphs for each time step...\")\n    graphs = []\n    for time_idx in tqdm(range(n_time), desc=\"Building topology graphs\"):\n        graph = self._build_graph_at_time(\n            time_idx,\n            constellation_satellites,\n            user_satellites,\n            ground_nodes,\n            user_visibility,\n            ground_visibility,\n            user_remaining_connection_time,\n            ground_remaining_visibility_time,\n            user_connections,\n            ground_connections,\n        )\n        graphs.append(graph)\n\n    return graphs\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_to_constellation/","title":"usersatellite_to_constellation","text":""},{"location":"reference/cosmica/topology/usersatellite_to_constellation/#cosmica.topology.usersatellite_to_constellation","title":"cosmica.topology.usersatellite_to_constellation","text":""},{"location":"reference/cosmica/topology/usersatellite_to_constellation/#cosmica.topology.usersatellite_to_constellation.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"MaxConnectionTimeUS2CTopologyBuilder\",\n    \"UserSatelliteToConstellationTopologyBuilder\",\n]\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_to_constellation/#cosmica.topology.usersatellite_to_constellation.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_to_constellation/#cosmica.topology.usersatellite_to_constellation.MaxConnectionTimeUS2CTopologyBuilder","title":"MaxConnectionTimeUS2CTopologyBuilder","text":"<pre><code>MaxConnectionTimeUS2CTopologyBuilder(\n    max_distance: float = float(\"inf\"),\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n)\n</code></pre> <p>               Bases: <code>UserSatelliteToConstellationTopologyBuilder[SatelliteConstellation, UserSatellite, Graph]</code></p> <p>Topology builder connecting user satellites to constellation with longest connection time.</p> <p>This builder calculates the visibility duration between user satellites and constellation satellites, then selects the constellation satellite that provides the longest continuous connection time for each user satellite. This minimizes handovers and provides stable connections.</p> Source code in <code>src/cosmica/topology/usersatellite_to_constellation.py</code> <pre><code>def __init__(\n    self,\n    max_distance: float = float(\"inf\"),\n    max_relative_angular_velocity: float = float(\"inf\"),\n    sun_exclusion_angle: float = 0.0,\n) -&gt; None:\n    self.max_distance = max_distance\n    self.max_relative_angular_velocity = max_relative_angular_velocity\n    self.sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_to_constellation/#cosmica.topology.usersatellite_to_constellation.MaxConnectionTimeUS2CTopologyBuilder.max_distance","title":"max_distance  <code>instance-attribute</code>","text":"<pre><code>max_distance = max_distance\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_to_constellation/#cosmica.topology.usersatellite_to_constellation.MaxConnectionTimeUS2CTopologyBuilder.max_relative_angular_velocity","title":"max_relative_angular_velocity  <code>instance-attribute</code>","text":"<pre><code>max_relative_angular_velocity = (\n    max_relative_angular_velocity\n)\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_to_constellation/#cosmica.topology.usersatellite_to_constellation.MaxConnectionTimeUS2CTopologyBuilder.sun_exclusion_angle","title":"sun_exclusion_angle  <code>instance-attribute</code>","text":"<pre><code>sun_exclusion_angle = sun_exclusion_angle\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_to_constellation/#cosmica.topology.usersatellite_to_constellation.MaxConnectionTimeUS2CTopologyBuilder.build","title":"build","text":"<pre><code>build(\n    *,\n    constellation: SatelliteConstellation,\n    user_satellites: Collection[UserSatellite],\n    dynamics_data: DynamicsData\n) -&gt; list[Graph]\n</code></pre> Source code in <code>src/cosmica/topology/usersatellite_to_constellation.py</code> <pre><code>def build(  # noqa: C901, PLR0912, PLR0915\n    self,\n    *,\n    constellation: SatelliteConstellation,\n    user_satellites: Collection[UserSatellite],\n    dynamics_data: DynamicsData,\n) -&gt; list[nx.Graph]:\n    logger.info(f\"Building user-to-constellation topology for {len(user_satellites)} user satellites\")\n    logger.info(f\"Number of time steps: {len(dynamics_data.time)}\")\n\n    user_satellites = list(user_satellites)\n    constellation_satellites = list(constellation.satellites)\n\n    n_time = len(dynamics_data.time)\n    n_users = len(user_satellites)\n    n_constellation = len(constellation_satellites)\n\n    # Calculate visibility based on distance, sun exclusion angle, and relative angular velocity constraints\n    visibility = np.zeros((n_users, n_constellation, n_time), dtype=np.bool_)\n\n    for (user_idx, user_sat), (const_idx, const_sat) in product(\n        enumerate(user_satellites),\n        enumerate(constellation_satellites),\n    ):\n        # Get positions and velocities for user and constellation satellites\n        user_pos_eci = dynamics_data.satellite_position_eci[user_sat]\n        const_pos_eci = dynamics_data.satellite_position_eci[const_sat]\n        user_vel_eci = dynamics_data.satellite_velocity_eci[user_sat]\n        const_vel_eci = dynamics_data.satellite_velocity_eci[const_sat]\n        user_att_ang_vel_eci = dynamics_data.satellite_attitude_angular_velocity_eci[user_sat]\n        const_att_ang_vel_eci = dynamics_data.satellite_attitude_angular_velocity_eci[const_sat]\n\n        # Calculate relative position and velocity vectors\n        relative_pos_eci = const_pos_eci - user_pos_eci\n        relative_vel_eci = const_vel_eci - user_vel_eci\n\n        # Calculate distances\n        distances = np.linalg.norm(relative_pos_eci, axis=1)\n\n        # Calculate relative angular velocities for each time step\n        relative_angular_velocities_list = []\n        for t in range(n_time):\n            distance = distances[t]\n            if distance &gt; 0:\n                # Calculate relative angular velocity due to translational motion\n                relative_angular_velocity_translational = (\n                    np.cross(relative_pos_eci[t], relative_vel_eci[t]) / distance**2\n                )\n\n                # Calculate relative angular velocities considering attitude angular velocities\n                rel_ang_vel_user = relative_angular_velocity_translational - user_att_ang_vel_eci[t]\n                rel_ang_vel_const = -relative_angular_velocity_translational - const_att_ang_vel_eci[t]\n\n                # Take maximum of the two relative angular velocities\n                max_rel_ang_vel = np.maximum(\n                    np.linalg.norm(rel_ang_vel_user),\n                    np.linalg.norm(rel_ang_vel_const),\n                )\n                relative_angular_velocities_list.append(float(max_rel_ang_vel))\n            else:\n                relative_angular_velocities_list.append(float(\"inf\"))\n\n        relative_angular_velocities = np.array(relative_angular_velocities_list)\n\n        # Calculate sun angles for each time step\n        sun_angles = np.array(\n            [angle_between(relative_pos_eci[t], dynamics_data.sun_direction_eci[t]) for t in range(n_time)],\n        )\n\n        # Check all constraints:\n        # 1. Distance constraint\n        distance_ok = distances &lt;= self.max_distance\n        # 2. Sun exclusion angle constraint (avoid pointing too close to sun)\n        sun_ok = (sun_angles &gt;= self.sun_exclusion_angle) &amp; (sun_angles &lt;= (np.pi - self.sun_exclusion_angle))\n        # 3. Relative angular velocity constraint\n        angular_velocity_ok = relative_angular_velocities &lt;= self.max_relative_angular_velocity\n\n        # Combined visibility\n        visibility[user_idx, const_idx, :] = distance_ok &amp; sun_ok &amp; angular_velocity_ok\n\n    # Calculate remaining connection time for each user-constellation pair\n    remaining_connection_time = np.zeros((n_users, n_constellation, n_time), dtype=np.int_)\n\n    # Traverse time backwards to calculate remaining visibility duration\n    for time_idx in reversed(range(n_time)):\n        if time_idx == n_time - 1:\n            # Last time step: 1 if visible, 0 otherwise\n            remaining_connection_time[:, :, time_idx] = visibility[:, :, time_idx].astype(int)\n        else:\n            # If visible at current time, add 1 to future remaining time\n            remaining_connection_time[:, :, time_idx] = np.where(\n                visibility[:, :, time_idx],\n                remaining_connection_time[:, :, time_idx + 1] + 1,\n                0,\n            )\n\n    # Select constellation satellite for each user satellite at each time\n    selected_constellation_idx = np.full(n_users, -1, dtype=np.int_)  # -1 means no connection\n    link_available = np.zeros((n_users, n_constellation, n_time), dtype=np.bool_)\n\n    def select_max_connection_satellite(user_idx: int, time_idx: int) -&gt; None:\n        \"\"\"Select the constellation satellite with maximum remaining connection time.\"\"\"\n        # Get remaining connection times for this user\n        user_remaining_times = remaining_connection_time[user_idx, :, time_idx].copy()\n\n        # Mask out satellites already connected to other users\n        for other_user_idx in range(n_users):\n            if other_user_idx != user_idx and selected_constellation_idx[other_user_idx] &gt;= 0:\n                user_remaining_times[selected_constellation_idx[other_user_idx]] = 0\n\n        # Select satellite with maximum remaining connection time\n        if user_remaining_times.max() &gt; 0:\n            selected_constellation_idx[user_idx] = int(np.argmax(user_remaining_times))\n        else:\n            selected_constellation_idx[user_idx] = -1\n\n    # Build topology for each time step\n    for time_idx in range(n_time):\n        # Reset selections for this time step\n        selected_constellation_idx.fill(-1)\n\n        # Process each user satellite\n        for user_idx in range(n_users):\n            if time_idx == 0:\n                # First time step: select satellite with longest total connection time\n                select_max_connection_satellite(user_idx, time_idx)\n            else:\n                # Check if previously connected satellite is still visible\n                prev_selected = np.where(link_available[user_idx, :, time_idx - 1])[0]\n                if len(prev_selected) &gt; 0:\n                    prev_sat_idx = prev_selected[0]\n                    # If still visible, maintain connection\n                    if visibility[user_idx, prev_sat_idx, time_idx]:\n                        selected_constellation_idx[user_idx] = prev_sat_idx\n                    else:\n                        # Previous satellite no longer visible, select new one\n                        select_max_connection_satellite(user_idx, time_idx)\n                else:\n                    # No previous connection, select new satellite\n                    select_max_connection_satellite(user_idx, time_idx)\n\n            # Mark the selected connection as available\n            if selected_constellation_idx[user_idx] &gt;= 0:\n                link_available[user_idx, selected_constellation_idx[user_idx], time_idx] = True\n\n    def construct_graph(link_available_at_time: npt.NDArray[np.bool_]) -&gt; nx.Graph:\n        \"\"\"Construct NetworkX graph from link availability matrix.\"\"\"\n        graph = nx.Graph()\n\n        # Add all nodes\n        graph.add_nodes_from(user_satellites)\n        graph.add_nodes_from(constellation_satellites)\n\n        # Add edges based on link availability\n        for user_idx, user_sat in enumerate(user_satellites):\n            for const_idx, const_sat in enumerate(constellation_satellites):\n                if link_available_at_time[user_idx, const_idx]:\n                    graph.add_edge(user_sat, const_sat)\n\n        return graph\n\n    # Return list of graphs, one for each time step\n    return [construct_graph(link_available[:, :, time_idx]) for time_idx in range(n_time)]\n</code></pre>"},{"location":"reference/cosmica/topology/usersatellite_to_constellation/#cosmica.topology.usersatellite_to_constellation.UserSatelliteToConstellationTopologyBuilder","title":"UserSatelliteToConstellationTopologyBuilder","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/cosmica/topology/usersatellite_to_constellation/#cosmica.topology.usersatellite_to_constellation.UserSatelliteToConstellationTopologyBuilder.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(\n    *,\n    constellation: TConstellation,\n    user_satellites: Collection[TUserSatellite],\n    dynamics_data: DynamicsData\n) -&gt; list[TGraph]\n</code></pre> <p>Build time-varying topology connecting user satellites to constellation.</p> Source code in <code>src/cosmica/topology/usersatellite_to_constellation.py</code> <pre><code>@abstractmethod\ndef build(\n    self,\n    *,\n    constellation: TConstellation,\n    user_satellites: Collection[TUserSatellite],\n    dynamics_data: DynamicsData,\n) -&gt; list[TGraph]:\n    \"\"\"Build time-varying topology connecting user satellites to constellation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/cosmica/utils/","title":"utils","text":""},{"location":"reference/cosmica/utils/#cosmica.utils","title":"cosmica.utils","text":""},{"location":"reference/cosmica/utils/constants/","title":"constants","text":""},{"location":"reference/cosmica/utils/constants/#cosmica.utils.constants","title":"cosmica.utils.constants","text":""},{"location":"reference/cosmica/utils/constants/#cosmica.utils.constants.BOLTZ_CONST","title":"BOLTZ_CONST  <code>module-attribute</code>","text":"<pre><code>BOLTZ_CONST: Final[float] = 1.380649e-23\n</code></pre>"},{"location":"reference/cosmica/utils/constants/#cosmica.utils.constants.EARTH_MU","title":"EARTH_MU  <code>module-attribute</code>","text":"<pre><code>EARTH_MU: Final[float] = 398600500000000.0\n</code></pre>"},{"location":"reference/cosmica/utils/constants/#cosmica.utils.constants.EARTH_RADIUS","title":"EARTH_RADIUS  <code>module-attribute</code>","text":"<pre><code>EARTH_RADIUS: Final[float] = 6378137.0\n</code></pre>"},{"location":"reference/cosmica/utils/constants/#cosmica.utils.constants.EARTH_ROTATION_RATE","title":"EARTH_ROTATION_RATE  <code>module-attribute</code>","text":"<pre><code>EARTH_ROTATION_RATE: Final[float] = 2 * pi / 86164.0905\n</code></pre>"},{"location":"reference/cosmica/utils/constants/#cosmica.utils.constants.SPEED_OF_LIGHT","title":"SPEED_OF_LIGHT  <code>module-attribute</code>","text":"<pre><code>SPEED_OF_LIGHT: Final[float] = 299792458.0\n</code></pre>"},{"location":"reference/cosmica/utils/constants/#cosmica.utils.constants.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"BOLTZ_CONST\",\n    \"EARTH_MU\",\n    \"EARTH_RADIUS\",\n    \"EARTH_ROTATION_RATE\",\n]\n</code></pre>"},{"location":"reference/cosmica/utils/coordinates/","title":"coordinates","text":""},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates","title":"cosmica.utils.coordinates","text":""},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"calc_dcm_eci2ecef\",\n    \"ecef2aer\",\n    \"geodetic2ecef\",\n    \"greenwichsrt\",\n    \"juliandate\",\n]\n</code></pre>"},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates.calc_dcm_eci2ecef","title":"calc_dcm_eci2ecef","text":"<pre><code>calc_dcm_eci2ecef(\n    time: datetime64 | NDArray[datetime64],\n) -&gt; NDArray[float64]\n</code></pre> <p>Calculate the direction cosine matrix from ECI to ECEF.</p> <p>Input is UTC time. If the input is a single time, the output is a 3x3 matrix. If the input is an array of times, the output is a Nx3x3 array.</p> Source code in <code>src/cosmica/utils/coordinates.py</code> <pre><code>def calc_dcm_eci2ecef(time: np.datetime64 | npt.NDArray[np.datetime64]) -&gt; npt.NDArray[np.float64]:\n    \"\"\"Calculate the direction cosine matrix from ECI to ECEF.\n\n    Input is UTC time.\n    If the input is a single time, the output is a 3x3 matrix.\n    If the input is an array of times, the output is a Nx3x3 array.\n    \"\"\"\n    gst = greenwichsrt(time)\n    if isinstance(gst, float):\n        return np.array(\n            [\n                [np.cos(gst), np.sin(gst), 0],\n                [-np.sin(gst), np.cos(gst), 0],\n                [0, 0, 1],\n            ],\n        )\n    else:\n        return np.stack(\n            [\n                np.stack(\n                    [\n                        np.cos(gst),\n                        np.sin(gst),\n                        np.zeros_like(gst),\n                    ],\n                    axis=-1,\n                ),\n                np.stack(\n                    [\n                        -np.sin(gst),\n                        np.cos(gst),\n                        np.zeros_like(gst),\n                    ],\n                    axis=-1,\n                ),\n                np.stack(\n                    [\n                        np.zeros_like(gst),\n                        np.zeros_like(gst),\n                        np.ones_like(gst),\n                    ],\n                    axis=-1,\n                ),\n            ],\n            axis=-2,\n        )\n</code></pre>"},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates.ecef2aer","title":"ecef2aer","text":"<pre><code>ecef2aer(\n    x,\n    y,\n    z,\n    lat0,\n    lon0,\n    h0,\n    ell: Ellipsoid | None = None,\n    deg: bool = True,\n) -&gt; tuple\n</code></pre> <p>compute azimuth, elevation and slant range from an Observer to a Point with ECEF coordinates.</p> <p>ECEF input location is with units of meters</p>"},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates.ecef2aer--parameters","title":"Parameters","text":"float <p>ECEF x coordinate (meters)</p> <p>y : float     ECEF y coordinate (meters) z : float     ECEF z coordinate (meters) lat0 : float     Observer geodetic latitude lon0 : float     Observer geodetic longitude h0 : float      observer altitude above geodetic ellipsoid (meters) ell : Ellipsoid, optional     reference ellipsoid deg : bool, optional     degrees input/output  (False: radians in/out)</p>"},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates.ecef2aer--returns","title":"Returns","text":"<p>az : float      azimuth to target el : float      elevation to target srange : float      slant range [meters]</p> Source code in <code>.venv/lib/python3.13/site-packages/pymap3d/aer.py</code> <pre><code>def ecef2aer(\n    x,\n    y,\n    z,\n    lat0,\n    lon0,\n    h0,\n    ell: Ellipsoid | None = None,\n    deg: bool = True,\n) -&gt; tuple:\n    \"\"\"\n    compute azimuth, elevation and slant range from an Observer to a Point with ECEF coordinates.\n\n    ECEF input location is with units of meters\n\n    Parameters\n    ----------\n\n    x : float\n        ECEF x coordinate (meters)\n    y : float\n        ECEF y coordinate (meters)\n    z : float\n        ECEF z coordinate (meters)\n    lat0 : float\n        Observer geodetic latitude\n    lon0 : float\n        Observer geodetic longitude\n    h0 : float\n         observer altitude above geodetic ellipsoid (meters)\n    ell : Ellipsoid, optional\n        reference ellipsoid\n    deg : bool, optional\n        degrees input/output  (False: radians in/out)\n\n    Returns\n    -------\n    az : float\n         azimuth to target\n    el : float\n         elevation to target\n    srange : float\n         slant range [meters]\n    \"\"\"\n\n    xEast, yNorth, zUp = ecef2enu(x, y, z, lat0, lon0, h0, ell, deg=deg)\n\n    return enu2aer(xEast, yNorth, zUp, deg=deg)\n</code></pre>"},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates.geodetic2ecef","title":"geodetic2ecef","text":"<pre><code>geodetic2ecef(\n    lat,\n    lon,\n    alt,\n    ell: Ellipsoid | None = None,\n    deg: bool = True,\n) -&gt; tuple\n</code></pre> <p>point transformation from Geodetic of specified ellipsoid (default WGS-84) to ECEF</p>"},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates.geodetic2ecef--parameters","title":"Parameters","text":"<p>lat        target geodetic latitude lon        target geodetic longitude alt      target altitude above geodetic ellipsoid (meters) ell : Ellipsoid, optional       reference ellipsoid deg : bool, optional       degrees input/output  (False: radians in/out)</p>"},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates.geodetic2ecef--returns","title":"Returns","text":"<p>ECEF (Earth centered, Earth fixed)  x,y,z</p> <p>x     target x ECEF coordinate (meters) y     target y ECEF coordinate (meters) z     target z ECEF coordinate (meters)</p> Source code in <code>.venv/lib/python3.13/site-packages/pymap3d/ecef.py</code> <pre><code>def geodetic2ecef(\n    lat,\n    lon,\n    alt,\n    ell: Ellipsoid | None = None,\n    deg: bool = True,\n) -&gt; tuple:\n    \"\"\"\n    point transformation from Geodetic of specified ellipsoid (default WGS-84) to ECEF\n\n    Parameters\n    ----------\n\n    lat\n           target geodetic latitude\n    lon\n           target geodetic longitude\n    alt\n         target altitude above geodetic ellipsoid (meters)\n    ell : Ellipsoid, optional\n          reference ellipsoid\n    deg : bool, optional\n          degrees input/output  (False: radians in/out)\n\n\n    Returns\n    -------\n\n    ECEF (Earth centered, Earth fixed)  x,y,z\n\n    x\n        target x ECEF coordinate (meters)\n    y\n        target y ECEF coordinate (meters)\n    z\n        target z ECEF coordinate (meters)\n    \"\"\"\n\n    if deg:\n        lat = radians(lat)\n        lon = radians(lon)\n\n    if ell is None:\n        ell = Ellipsoid.from_name(\"wgs84\")\n\n    # radius of curvature of the prime vertical section\n    N = ell.semimajor_axis**2 / hypot(ell.semimajor_axis * cos(lat), ell.semiminor_axis * sin(lat))\n    # Compute cartesian (geocentric) coordinates given (curvilinear) geodetic coordinates.\n    x = (N + alt) * cos(lat) * cos(lon)\n    y = (N + alt) * cos(lat) * sin(lon)\n    z = (N * (ell.semiminor_axis / ell.semimajor_axis) ** 2 + alt) * sin(lat)\n\n    return x, y, z\n</code></pre>"},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates.greenwichsrt","title":"greenwichsrt","text":"<pre><code>greenwichsrt(time: datetime64) -&gt; float\n</code></pre><pre><code>greenwichsrt(time: NDArray[datetime64]) -&gt; NDArray[float64]\n</code></pre> <pre><code>greenwichsrt(time)\n</code></pre> Source code in <code>src/cosmica/utils/coordinates.py</code> <pre><code>def greenwichsrt(time):\n    return _greenwichsrt(juliandate(time))\n</code></pre>"},{"location":"reference/cosmica/utils/coordinates/#cosmica.utils.coordinates.juliandate","title":"juliandate","text":"<pre><code>juliandate(time: datetime64) -&gt; float\n</code></pre><pre><code>juliandate(time: NDArray[datetime64]) -&gt; NDArray[float64]\n</code></pre> <pre><code>juliandate(time)\n</code></pre> Source code in <code>src/cosmica/utils/coordinates.py</code> <pre><code>def juliandate(time):\n    return pd.to_datetime(time).to_julian_date()\n</code></pre>"},{"location":"reference/cosmica/utils/gauss_beam/","title":"gauss_beam","text":""},{"location":"reference/cosmica/utils/gauss_beam/#cosmica.utils.gauss_beam","title":"cosmica.utils.gauss_beam","text":""},{"location":"reference/cosmica/utils/gauss_beam/#cosmica.utils.gauss_beam.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['calc_gauss_beam_radius', 'calc_gauss_rx_power']\n</code></pre>"},{"location":"reference/cosmica/utils/gauss_beam/#cosmica.utils.gauss_beam.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/utils/gauss_beam/#cosmica.utils.gauss_beam.calc_gauss_beam_radius","title":"calc_gauss_beam_radius","text":"<pre><code>calc_gauss_beam_radius(\n    w0: float, wvl: float, z: float\n) -&gt; float\n</code></pre> PARAMETER DESCRIPTION <code>w0</code> <p>Float value with the beam waist radius in meters.</p> <p> TYPE: <code>float</code> </p> <code>wvl</code> <p>Float value with the beam wavelength in meters.</p> <p> TYPE: <code>float</code> </p> <code>z</code> <p>Float value with the distance 'z' from the source.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/cosmica/utils/gauss_beam.py</code> <pre><code>def calc_gauss_beam_radius(\n    w0: Annotated[float, Doc(\"Float value with the beam waist radius in meters.\")],\n    wvl: Annotated[float, Doc(\"Float value with the beam wavelength in meters.\")],\n    z: Annotated[float, Doc(\"Float value with the distance 'z' from the source.\")],\n) -&gt; float:\n    return w0 * np.sqrt(1 + (z * wvl / (np.pi * w0**2)))\n</code></pre>"},{"location":"reference/cosmica/utils/gauss_beam/#cosmica.utils.gauss_beam.calc_gauss_rx_power","title":"calc_gauss_rx_power","text":"<pre><code>calc_gauss_rx_power(\n    power_tx: float,\n    aperture: float,\n    distance: float,\n    wavelength: float = 1550 * 1e-09,\n    beam_waist: float = 0.04,\n) -&gt; float\n</code></pre> PARAMETER DESCRIPTION <code>power_tx</code> <p>Float value with transmitted power in Watts.</p> <p> TYPE: <code>float</code> </p> <code>aperture</code> <p>Float value with receiving aperture diameter in meters.</p> <p> TYPE: <code>float</code> </p> <code>distance</code> <p>Float value with the link distance in meters.</p> <p> TYPE: <code>float</code> </p> <code>wavelength</code> <p>Float value with the wavelength of the beam in meters.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1550 * 1e-09</code> </p> <code>beam_waist</code> <p>Float value with the beam waist radius in meters.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.04</code> </p> Source code in <code>src/cosmica/utils/gauss_beam.py</code> <pre><code>def calc_gauss_rx_power(\n    power_tx: Annotated[float, Doc(\"Float value with transmitted power in Watts.\")],\n    aperture: Annotated[float, Doc(\"Float value with receiving aperture diameter in meters.\")],\n    distance: Annotated[float, Doc(\"Float value with the link distance in meters.\")],\n    wavelength: Annotated[float, Doc(\"Float value with the wavelength of the beam in meters.\")] = 1550 * 1e-9,\n    beam_waist: Annotated[float, Doc(\"Float value with the beam waist radius in meters.\")] = 0.04,\n) -&gt; float:\n    return power_tx * (np.exp(-(aperture**2) / 2 / calc_gauss_beam_radius(beam_waist, wavelength, distance) ** 2) - 1)\n</code></pre>"},{"location":"reference/cosmica/utils/vector/","title":"vector","text":""},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector","title":"cosmica.utils.vector","text":""},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"angle_between\",\n    \"as_column_vector\",\n    \"azimuth_elevation_to_unit_vector\",\n    \"decompose_wrt_reference_vector\",\n    \"generate_normal_vectors\",\n    \"is_column_vector\",\n    \"is_satellite_in_eclipse\",\n    \"normalize\",\n    \"perturb_vector\",\n    \"project_vector\",\n    \"rowwise_innerdot\",\n    \"rowwise_matmul\",\n    \"unit_vector_to_azimuth_elevation\",\n]\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.angle_between","title":"angle_between","text":"<pre><code>angle_between(\n    x1: NDArray[floating[S]] | NDArray[integer[S]],\n    x2: NDArray[floating[T]] | NDArray[integer[T]],\n) -&gt; NDArray[floating[S | T | _64Bit]]\n</code></pre> <p>Return the angle in radians between vectors x1 and x2.</p> <p>Ref: https://stackoverflow.com/questions/2827393/angles-between-two-n-dimensional-vectors-in-python/13849249#13849249.</p> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def angle_between[S: npt.NBitBase, T: npt.NBitBase](\n    x1: npt.NDArray[np.floating[S]] | npt.NDArray[np.integer[S]],\n    x2: npt.NDArray[np.floating[T]] | npt.NDArray[np.integer[T]],\n) -&gt; npt.NDArray[np.floating[S | T | _64Bit]]:\n    \"\"\"Return the angle in radians between vectors x1 and x2.\n\n    Ref: https://stackoverflow.com/questions/2827393/angles-between-two-n-dimensional-vectors-in-python/13849249#13849249.\n    \"\"\"\n    x1_unit = normalize(x1, axis=-1)\n    x2_unit = normalize(x2, axis=-1)\n\n    return np.arccos(np.clip(rowwise_innerdot(x1_unit, x2_unit), -1.0, 1.0))\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.as_column_vector","title":"as_column_vector","text":"<pre><code>as_column_vector(\n    v: NDArray[NumberType],\n) -&gt; NDArray[NumberType]\n</code></pre> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def as_column_vector[NumberType: np.number](v: npt.NDArray[NumberType]) -&gt; npt.NDArray[NumberType]:\n    if is_column_vector(v):  # v is already a column vector.\n        return v\n    else:\n        return v[..., np.newaxis]\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.azimuth_elevation_to_unit_vector","title":"azimuth_elevation_to_unit_vector","text":"<pre><code>azimuth_elevation_to_unit_vector(\n    az: float, el: float\n) -&gt; NDArray[floating]\n</code></pre> PARAMETER DESCRIPTION <code>az</code> <p>Float value with azimuth angle in radians</p> <p> TYPE: <code>float</code> </p> <code>el</code> <p>Float value with elevation angle in radians</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>NDArray[floating]</code> <p>Numpy array with unitary x,y,z directions</p> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def azimuth_elevation_to_unit_vector(\n    az: Annotated[float, Doc(\"Float value with azimuth angle in radians\")],\n    el: Annotated[float, Doc(\"Float value with elevation angle in radians\")],\n) -&gt; Annotated[\n    npt.NDArray[np.floating],\n    Doc(\"Numpy array with unitary x,y,z directions\"),\n]:\n    z = np.sin(el)\n    y = np.cos(el) * np.sin(az)\n    x = np.cos(el) * np.cos(az)\n    return np.array([x, y, z])\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.closest_point_to_origin_on_line","title":"closest_point_to_origin_on_line","text":"<pre><code>closest_point_to_origin_on_line(\n    r1: NDArray[floating],\n    r2: NDArray[floating],\n    *,\n    extend_at_r1: bool = True,\n    extend_at_r2: bool = True\n) -&gt; NDArray[floating]\n</code></pre> <p>Compute the point on the line segment between r1 and r2 that is closest to the origin.</p> PARAMETER DESCRIPTION <code>r1</code> <p>Numpy arrays representing the position vectors of the first point.</p> <p> TYPE: <code>NDArray[floating]</code> </p> <code>r2</code> <p>Numpy arrays representing the position vectors of the second point.</p> <p> TYPE: <code>NDArray[floating]</code> </p> <code>extend_at_r1</code> <p>If True, extend the line segment at r1. Otherwise, do not extend the line segment at r1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>extend_at_r2</code> <p>If True, extend the line segment at r2. Otherwise, do not extend the line segment at r2.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>NDArray[floating]</code> <p>Numpy array representing the position vector of the point on the line segment closest to the origin.</p> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def closest_point_to_origin_on_line(\n    r1: Annotated[npt.NDArray[np.floating], Doc(\"Numpy arrays representing the position vectors of the first point.\")],\n    r2: Annotated[npt.NDArray[np.floating], Doc(\"Numpy arrays representing the position vectors of the second point.\")],\n    *,\n    extend_at_r1: Annotated[\n        bool,\n        Doc(\"If True, extend the line segment at r1. Otherwise, do not extend the line segment at r1.\"),\n    ] = True,\n    extend_at_r2: Annotated[\n        bool,\n        Doc(\"If True, extend the line segment at r2. Otherwise, do not extend the line segment at r2.\"),\n    ] = True,\n) -&gt; Annotated[\n    npt.NDArray[np.floating],\n    Doc(\"Numpy array representing the position vector of the point on the line segment closest to the origin.\"),\n]:\n    \"\"\"Compute the point on the line segment between r1 and r2 that is closest to the origin.\"\"\"\n    # Compute t\n    numerator = rowwise_innerdot(r2 - r1, r1, keepdims=True)\n    denominator = rowwise_innerdot(r2 - r1, r2 - r1, keepdims=True)\n    t = -numerator / denominator\n\n    t = np.where(extend_at_r1, t, np.clip(t, 0.0, None))\n    t = np.where(extend_at_r2, t, np.clip(t, None, 1.0))\n\n    # Compute r*\n    return r1 + t * (r2 - r1)\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.decompose_wrt_reference_vector","title":"decompose_wrt_reference_vector","text":"<pre><code>decompose_wrt_reference_vector(\n    vec: NDArray[floating[S]], ref: NDArray[floating[T]]\n) -&gt; tuple[\n    NDArray[floating[S | T]], NDArray[floating[S | T]]\n]\n</code></pre> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def decompose_wrt_reference_vector[S: npt.NBitBase, T: npt.NBitBase](\n    vec: npt.NDArray[np.floating[S]],\n    ref: npt.NDArray[np.floating[T]],\n) -&gt; tuple[npt.NDArray[np.floating[S | T]], npt.NDArray[np.floating[S | T]]]:\n    ref = normalize(ref, axis=-1)\n\n    parallel_element = np.sum(vec * ref, axis=-1)\n    normal_element = np.sqrt(np.sum(vec**2, axis=-1) - parallel_element**2)\n\n    return parallel_element, normal_element\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.generate_normal_vectors","title":"generate_normal_vectors","text":"<pre><code>generate_normal_vectors(\n    vec: NDArray[floating],\n    seed_vec: NDArray[floating] | None = None,\n    seed_vec_backup: NDArray[floating] | None = None,\n    backup_threshold: float = 0.017,\n) -&gt; tuple[NDArray[floating], NDArray[floating]]\n</code></pre> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def generate_normal_vectors(\n    vec: npt.NDArray[np.floating],\n    seed_vec: npt.NDArray[np.floating] | None = None,\n    seed_vec_backup: npt.NDArray[np.floating] | None = None,\n    backup_threshold: float = 0.017,  # [rad] approx 1 degree.\n) -&gt; tuple[npt.NDArray[np.floating], npt.NDArray[np.floating]]:\n    seed_vec = np.array([1.0, 0.0, 0.0]) if seed_vec is None else seed_vec\n    seed_vec_backup = np.array([0.0, 1.0, 0.0]) if seed_vec_backup is None else seed_vec_backup\n    assert vec.shape == seed_vec.shape == seed_vec_backup.shape == (3,)\n    if angle_between(vec, seed_vec) &lt;= backup_threshold:\n        seed_vec = seed_vec_backup\n\n    e1 = normalize(np.cross(seed_vec, vec))\n    e2 = normalize(np.cross(vec, e1))\n    return e1, e2\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.is_column_vector","title":"is_column_vector","text":"<pre><code>is_column_vector(v: NDArray[number]) -&gt; bool\n</code></pre> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def is_column_vector(v: npt.NDArray[np.number]) -&gt; bool:\n    return v.shape[-1] == 1 and v.ndim &gt; 1\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.is_satellite_in_eclipse","title":"is_satellite_in_eclipse","text":"<pre><code>is_satellite_in_eclipse(\n    satellite_position_eci: NDArray[floating],\n    sun_direction_eci: NDArray[floating],\n) -&gt; bool\n</code></pre> <p>Check if a single satellite is in Earth's shadow (eclipse).</p> PARAMETER DESCRIPTION <code>satellite_position_eci</code> <p>Position of satellite in ECI frame. Shape: (3,)</p> <p> TYPE: <code>NDArray[floating]</code> </p> <code>sun_direction_eci</code> <p>Sun direction vector in ECI frame. Shape: (3,)</p> <p> TYPE: <code>NDArray[floating]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the satellite is in Earth's eclipse</p> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def is_satellite_in_eclipse(\n    satellite_position_eci: npt.NDArray[np.floating],\n    sun_direction_eci: npt.NDArray[np.floating],\n) -&gt; bool:\n    \"\"\"Check if a single satellite is in Earth's shadow (eclipse).\n\n    Args:\n        satellite_position_eci: Position of satellite in ECI frame. Shape: (3,)\n        sun_direction_eci: Sun direction vector in ECI frame. Shape: (3,)\n\n    Returns:\n        True if the satellite is in Earth's eclipse\n\n    \"\"\"\n    # Vector from satellite to sun (opposite of sun direction)\n    sat_to_sun = -normalize(sun_direction_eci) * np.linalg.norm(satellite_position_eci) * 2\n\n    # Check if the line from satellite to sun intersects with Earth\n    # Using the minimum distance from Earth center to the line\n    sat_pos_norm = np.linalg.norm(satellite_position_eci)\n    if sat_pos_norm == 0:\n        return False\n\n    # Project Earth center (origin) onto the line from satellite to sun\n    sat_to_sun_unit = normalize(sat_to_sun)\n    proj_length = np.dot(-satellite_position_eci, sat_to_sun_unit)\n\n    # If projection is behind the satellite or beyond the sun, no eclipse\n    sun_distance = np.linalg.norm(sat_to_sun)\n    if proj_length &lt; 0 or proj_length &gt; sun_distance:\n        return False\n\n    # Find the closest point on the line to Earth center\n    closest_point = satellite_position_eci + proj_length * sat_to_sun_unit\n    distance_to_earth_center = np.linalg.norm(closest_point)\n\n    # If this distance is less than Earth radius, there's an eclipse\n    return bool(distance_to_earth_center &lt; EARTH_RADIUS)\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.normalize","title":"normalize","text":"<pre><code>normalize(\n    x: NDArray[integer[S]],\n    ord: float | Literal[\"fro\", \"nuc\"] | None = None,\n    axis: int | None = None,\n) -&gt; NDArray[floating[S]]\n</code></pre><pre><code>normalize(\n    x: NDArray[floating[S]],\n    ord: float | Literal[\"fro\", \"nuc\"] | None = None,\n    axis: int | None = None,\n) -&gt; NDArray[floating[S]]\n</code></pre> <pre><code>normalize(x, ord=None, axis=None)\n</code></pre> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def normalize[S: npt.NBitBase](\n    x,\n    ord=None,  # noqa: A002\n    axis=None,\n):\n    norm = LA.norm(x, ord=ord, axis=axis, keepdims=True)\n    return np.where(norm == 0.0, x, x / norm)\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.perturb_vector","title":"perturb_vector","text":"<pre><code>perturb_vector(\n    vec: NDArray[floating],\n    phase_angle: float,\n    alignment_angle: float,\n    seed_vec: NDArray[floating] | None = None,\n    seed_vec_backup: NDArray[floating] | None = None,\n) -&gt; NDArray[floating]\n</code></pre> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def perturb_vector(\n    vec: npt.NDArray[np.floating],\n    phase_angle: float,  # [rad]\n    alignment_angle: float,  # [rad]\n    seed_vec: npt.NDArray[np.floating] | None = None,\n    seed_vec_backup: npt.NDArray[np.floating] | None = None,\n) -&gt; npt.NDArray[np.floating]:\n    if LA.norm(vec) == 0.0:\n        return np.zeros_like(vec, dtype=np.float64)\n\n    e1, e2 = generate_normal_vectors(vec, seed_vec, seed_vec_backup)\n    norm = LA.norm(vec)\n    e3 = vec / norm\n\n    direction = (\n        math.cos(phase_angle) * math.sin(alignment_angle) * e1\n        + math.sin(phase_angle) * math.sin(alignment_angle) * e2\n        + math.cos(alignment_angle) * e3\n    )\n    return direction * norm\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.project_vector","title":"project_vector","text":"<pre><code>project_vector(\n    vec: NDArray[NumberType], onto: NDArray[NumberType]\n) -&gt; NDArray[floating]\n</code></pre> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def project_vector[NumberType: np.number](\n    vec: npt.NDArray[NumberType],  # (n_data, dim) or (dim,)\n    onto: npt.NDArray[NumberType],  # (n_data, dim) or (dim,)\n) -&gt; npt.NDArray[np.floating]:  # (n_data, dim) or (dim,)\n    # Make sure vec and onto both have shape (n_data, dim)\n    if vec.ndim == 1 and onto.ndim == 1:\n        n_data = 1\n        assert vec.shape[-1] == onto.shape[-1]\n        dim = vec.shape[-1]\n        returned_shape = vec.shape\n    elif vec.ndim == 1 and onto.ndim == 2:\n        n_data = onto.shape[-2]\n        assert vec.shape[-1] == onto.shape[-1]\n        dim = vec.shape[-1]\n        returned_shape = onto.shape\n    elif vec.ndim == 2 and onto.ndim == 1:\n        n_data = vec.shape[-2]\n        assert vec.shape[-1] == onto.shape[-1]\n        dim = vec.shape[-1]\n        returned_shape = vec.shape\n    elif vec.ndim == 2 and onto.ndim == 2:\n        assert vec.shape == onto.shape\n        n_data, dim = vec.shape\n        returned_shape = vec.shape\n    else:\n        msg = \"vec should be either 2- or 1-dimensional vector.\"\n        raise ValueError(msg)\n    vec = np.broadcast_to(vec, (n_data, dim))\n    onto = np.broadcast_to(onto, (n_data, dim))\n\n    projected_vec = np.sum(vec * onto, axis=-1, keepdims=True) / np.sum(onto * onto, axis=-1, keepdims=True) * onto\n    return projected_vec.reshape(returned_shape)\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.rowwise_innerdot","title":"rowwise_innerdot","text":"<pre><code>rowwise_innerdot(\n    x1: NDArray[NumberType],\n    x2: NDArray[NumberType],\n    *,\n    keepdims: bool = False\n) -&gt; NDArray[NumberType]\n</code></pre> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def rowwise_innerdot[NumberType: np.number](\n    x1: npt.NDArray[NumberType],\n    x2: npt.NDArray[NumberType],\n    *,\n    keepdims: bool = False,\n) -&gt; npt.NDArray[NumberType]:\n    return np.sum(x1 * x2, axis=-1, keepdims=keepdims)\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.rowwise_matmul","title":"rowwise_matmul","text":"<pre><code>rowwise_matmul(x1: NDArray, x2: NDArray) -&gt; Any\n</code></pre> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def rowwise_matmul(x1: npt.NDArray, x2: npt.NDArray) -&gt; Any:\n    return x2 @ x1.T\n</code></pre>"},{"location":"reference/cosmica/utils/vector/#cosmica.utils.vector.unit_vector_to_azimuth_elevation","title":"unit_vector_to_azimuth_elevation","text":"<pre><code>unit_vector_to_azimuth_elevation(\n    u: NDArray[floating],\n) -&gt; tuple[float, float]\n</code></pre> PARAMETER DESCRIPTION <code>u</code> <p>Numpy array of floats with the coordinates of a unit vector in three dimensions</p> <p> TYPE: <code>NDArray[floating]</code> </p> RETURNS DESCRIPTION <code>tuple[float, float]</code> <p>Tuple with two floats. The first one represents the corresponding azimuth value in radians, and the second the elevation value in radians</p> Source code in <code>src/cosmica/utils/vector.py</code> <pre><code>def unit_vector_to_azimuth_elevation(\n    u: Annotated[\n        npt.NDArray[np.floating],\n        Doc(\"Numpy array of floats with the coordinates of a unit vector in three dimensions\"),\n    ],\n) -&gt; Annotated[\n    tuple[float, float],\n    Doc(\n        \"Tuple with two floats. The first one represents the corresponding azimuth value in radians, and the second the elevation value in radians\",  # noqa: E501\n    ),\n]:\n    assert u.shape[0] == 3\n\n    el = np.arcsin(u[2])\n    az = np.arctan2(u[1], u[0])\n\n    return (az, el)\n</code></pre>"},{"location":"reference/cosmica/visualization/","title":"visualization","text":""},{"location":"reference/cosmica/visualization/#cosmica.visualization","title":"cosmica.visualization","text":""},{"location":"reference/cosmica/visualization/equirectangular/","title":"equirectangular","text":""},{"location":"reference/cosmica/visualization/equirectangular/#cosmica.visualization.equirectangular","title":"cosmica.visualization.equirectangular","text":""},{"location":"reference/cosmica/visualization/equirectangular/#cosmica.visualization.equirectangular.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"draw_countries\",\n    \"draw_coverage_area\",\n    \"draw_lat_lon_grid\",\n    \"draw_snapshot\",\n    \"draw_snapshot_movie\",\n    \"draw_urban_areas\",\n]\n</code></pre>"},{"location":"reference/cosmica/visualization/equirectangular/#cosmica.visualization.equirectangular.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/visualization/equirectangular/#cosmica.visualization.equirectangular.draw_countries","title":"draw_countries","text":"<pre><code>draw_countries(\n    *,\n    ax: Axes,\n    zorder: int = 0,\n    ocean_color: ColorType = \"#caecfc\",\n    countries_color: ColorType = \"#fdfbe6\"\n) -&gt; Axes\n</code></pre> Source code in <code>src/cosmica/visualization/equirectangular.py</code> <pre><code>def draw_countries(\n    *,\n    ax: Axes,\n    zorder: int = 0,\n    ocean_color: ColorType = \"#caecfc\",\n    countries_color: ColorType = \"#fdfbe6\",\n) -&gt; Axes:\n    ax.set_facecolor(ocean_color)\n    df_countries = _load_shapefile_from_assets_dir(\"ne_50m_admin_0_countries_lakes.shp\")\n    df_countries.plot(ax=ax, color=countries_color, edgecolor=\"grey\", linewidth=0.5, zorder=zorder)\n    ax.grid(color=\"black\", alpha=0.2)\n    return ax\n</code></pre>"},{"location":"reference/cosmica/visualization/equirectangular/#cosmica.visualization.equirectangular.draw_coverage_area","title":"draw_coverage_area","text":"<pre><code>draw_coverage_area(\n    *,\n    dynamics_data: DynamicsData[ConstellationSatellite[T]],\n    ax: Axes,\n    min_elevation: float,\n    face_color: str = \"red\",\n    face_alpha: float = 0.25,\n    draw_edges: bool = True,\n    edge_color: str = \"red\",\n    edge_alpha: float = 1.0,\n    edge_linewidth: float | None = None,\n    edge_linestyle: str | None = None\n) -&gt; Axes\n</code></pre> <p>Draw the coverage area of the satellites in the constellation.</p> <p>Note that this function is not optimized for performance, and may take a few minutes to complete.</p> PARAMETER DESCRIPTION <code>dynamics_data</code> <p>Dynamics data with no time dimension.</p> <p> TYPE: <code>DynamicsData[ConstellationSatellite[T]]</code> </p> <code>ax</code> <p>Matplotlib axes.</p> <p> TYPE: <code>Axes</code> </p> <code>min_elevation</code> <p>Minimum elevation angle in radians.</p> <p> TYPE: <code>float</code> </p> <code>face_color</code> <p>Color of the coverage area. Used as the <code>colors</code> parameter of <code>contourf</code> function.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'red'</code> </p> <code>face_alpha</code> <p>Transparency of the coverage area. Used as the <code>alpha</code> parameter of <code>contourf</code> function.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.25</code> </p> <code>draw_edges</code> <p>Whether to draw the edges of the coverage area</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>edge_color</code> <p>Color of the coverage area edge. Used as the <code>colors</code> parameter of <code>contour</code> function.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'red'</code> </p> <code>edge_alpha</code> <p>Transparency of the coverage area edge. Used as the <code>alpha</code> parameter of <code>contour</code> function.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>edge_linewidth</code> <p>Width of the coverage area edge. Used as the <code>linewidths</code> parameter of <code>contour</code> function.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>edge_linestyle</code> <p>Style of the coverage area edge. Used as the <code>linestyles</code> parameter of <code>contour</code> function.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Axes</code> <p>Matplotlib axes.</p> Source code in <code>src/cosmica/visualization/equirectangular.py</code> <pre><code>def draw_coverage_area[T](\n    *,\n    dynamics_data: Annotated[\n        DynamicsData[ConstellationSatellite[T]],\n        Doc(\"Dynamics data with no time dimension.\"),\n    ],\n    ax: Annotated[Axes, Doc(\"Matplotlib axes.\")],\n    min_elevation: Annotated[float, Doc(\"Minimum elevation angle in radians.\")],\n    face_color: Annotated[\n        str,\n        Doc(\"Color of the coverage area. Used as the `colors` parameter of `contourf` function.\"),\n    ] = \"red\",\n    face_alpha: Annotated[\n        float,\n        Doc(\"Transparency of the coverage area. Used as the `alpha` parameter of `contourf` function.\"),\n    ] = 0.25,\n    draw_edges: Annotated[bool, Doc(\"Whether to draw the edges of the coverage area\")] = True,\n    edge_color: Annotated[\n        str,\n        Doc(\"Color of the coverage area edge. Used as the `colors` parameter of `contour` function.\"),\n    ] = \"red\",\n    edge_alpha: Annotated[\n        float,\n        Doc(\"Transparency of the coverage area edge. Used as the `alpha` parameter of `contour` function.\"),\n    ] = 1.0,\n    edge_linewidth: Annotated[\n        float | None,\n        Doc(\"Width of the coverage area edge. Used as the `linewidths` parameter of `contour` function.\"),\n    ] = None,\n    edge_linestyle: Annotated[\n        str | None,\n        Doc(\"Style of the coverage area edge. Used as the `linestyles` parameter of `contour` function.\"),\n    ] = None,\n) -&gt; Annotated[Axes, Doc(\"Matplotlib axes.\")]:\n    \"\"\"Draw the coverage area of the satellites in the constellation.\n\n    Note that this function is not optimized for performance, and may take a few minutes to complete.\n    \"\"\"\n    latitudes = np.radians(np.linspace(-90, 90, 180))\n    longitudes = np.radians(np.linspace(-180, 180, 360))\n    lat_grid, lon_grid = np.meshgrid(latitudes, longitudes)\n\n    elevation_angles = {}\n    for sat, pos_ecef in dynamics_data.satellite_position_ecef.items():\n        elevation_angles[sat] = np.zeros_like(lat_grid)\n        for i in range(len(latitudes)):\n            for j in range(len(longitudes)):\n                _azimuth, elevation, _srange = ecef2aer(\n                    x=pos_ecef[0],\n                    y=pos_ecef[1],\n                    z=pos_ecef[2],\n                    lat0=latitudes[i],\n                    lon0=longitudes[j],\n                    h0=0,\n                    deg=False,\n                )\n                elevation_angles[sat][j, i] = elevation\n\n    for elevation in elevation_angles.values():\n        cs = ax.contourf(\n            np.degrees(lon_grid),\n            np.degrees(lat_grid),\n            np.degrees(elevation),\n            levels=[np.degrees(min_elevation), np.inf],\n            colors=face_color,\n            alpha=face_alpha,\n        )\n\n        if draw_edges:\n            ax.contour(\n                cs,\n                levels=cs.levels,\n                colors=edge_color,\n                alpha=edge_alpha,\n                linewidths=edge_linewidth,\n                linestyles=edge_linestyle,\n            )\n\n    return ax\n</code></pre>"},{"location":"reference/cosmica/visualization/equirectangular/#cosmica.visualization.equirectangular.draw_lat_lon_grid","title":"draw_lat_lon_grid","text":"<pre><code>draw_lat_lon_grid(*, ax: Axes) -&gt; Axes\n</code></pre> Source code in <code>src/cosmica/visualization/equirectangular.py</code> <pre><code>def draw_lat_lon_grid(*, ax: Axes) -&gt; Axes:\n    ax.set_ylabel(\"Latitude\")\n    ax.set_yticks(np.arange(-90, 90 + 1, 30))\n    ax.set_yticklabels([f\"{ytick}\u00b0\" for ytick in np.arange(-90, 90 + 1, 30)])\n    ax.set_xlabel(\"Longitude\")\n    ax.set_xticks(np.arange(-180, 180 + 1, 30))\n    ax.set_xticklabels([f\"{xtick}\u00b0\" for xtick in np.arange(-180, 180 + 1, 30)])\n\n    ax.set_ylim(-90, 90)\n    ax.set_xlim(-180, 180)\n\n    ax.set_aspect(\"equal\")\n\n    return ax\n</code></pre>"},{"location":"reference/cosmica/visualization/equirectangular/#cosmica.visualization.equirectangular.draw_snapshot","title":"draw_snapshot","text":"<pre><code>draw_snapshot(\n    *,\n    graph: Graph,\n    dynamics_data: DynamicsData[Any],\n    ax: Axes,\n    with_labels: bool = False,\n    focus_edges_list: (\n        list[set[tuple[Node, Node]]] | None\n    ) = None,\n    focus_edges_label_list: list[str] | None = None\n) -&gt; Axes\n</code></pre> Source code in <code>src/cosmica/visualization/equirectangular.py</code> <pre><code>def draw_snapshot(  # noqa: C901, PLR0915\n    *,\n    graph: nx.Graph,\n    dynamics_data: DynamicsData[Any],\n    ax: Axes,\n    with_labels: bool = False,\n    focus_edges_list: list[set[tuple[Node, Node]]] | None = None,\n    focus_edges_label_list: list[str] | None = None,\n) -&gt; Axes:\n    # None \u306e\u3068\u304d\u306e\u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u8a2d\u5b9a\n    if focus_edges_list is None:\n        focus_edges_list = []\n    if focus_edges_label_list is None:\n        # focus_edges \u3068\u540c\u3058\u6570\u3060\u3051\u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u30e9\u30d9\u30eb\u3092\u4f5c\u6210\u3059\u308b\n        focus_edges_label_list = [f\"Focus edges {i}\" for i in range(len(focus_edges_list))]\n\n    if len(focus_edges_list) != len(focus_edges_label_list):\n        msg = \"focus_edges \u3068 focus_edges_label \u306e\u8981\u7d20\u6570\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\"\n        raise ValueError(msg)\n\n    constellation_satellites_to_draw = {node for node in graph.nodes if isinstance(node, ConstellationSatellite)}\n    pos_constellation = {\n        satellite: np.degrees(\n            np.asarray(ecef2geodetic(*dynamics_data.satellite_position_ecef[satellite], deg=False))[(1, 0),],\n        )\n        for satellite in constellation_satellites_to_draw\n    }\n\n    user_satellites_to_draw = {node for node in graph.nodes if isinstance(node, UserSatellite)}\n    pos_user_satellites = {\n        satellite: np.degrees(\n            np.asarray(ecef2geodetic(*dynamics_data.satellite_position_ecef[satellite], deg=False))[(1, 0),],\n        )\n        for satellite in user_satellites_to_draw\n    }\n\n    gateways = {node for node in graph.nodes if isinstance(node, Gateway)}\n    pos_gateways = {gateway: np.degrees(np.array([gateway.longitude, gateway.latitude])) for gateway in gateways}\n\n    on_ground_users = {node for node in graph.nodes if isinstance(node, StationaryOnGroundUser)}\n    pos_ogu = {\n        on_ground_user: np.degrees(np.array([on_ground_user.longitude, on_ground_user.latitude]))\n        for on_ground_user in on_ground_users\n    }\n\n    internets = {node for node in graph.nodes if isinstance(node, Internet)}\n    pos_internets = {internet: [np.nan, np.nan] for internet in internets}\n\n    pos = pos_constellation | pos_user_satellites | pos_gateways | pos_ogu | pos_internets\n    nodes_to_draw: set[Node] = constellation_satellites_to_draw | user_satellites_to_draw | gateways | on_ground_users\n\n    with preserve_tick_params(ax):\n        # Draw nodes\n        # Draw constellation satellites\n        nx.draw_networkx_nodes(\n            graph,\n            pos=pos,\n            ax=ax,\n            nodelist=set(pos_constellation),\n            node_size=100,\n            node_color=\"tab:blue\",\n            node_shape=\"s\",\n            alpha=0.7,\n            label=\"Constellation satellite\",\n        )\n        # Draw user satellites\n        nx.draw_networkx_nodes(\n            graph,\n            pos=pos,\n            ax=ax,\n            nodelist=set(pos_user_satellites),\n            node_size=120,\n            node_color=\"tab:purple\",\n            node_shape=\"D\",\n            alpha=0.7,\n            label=\"User satellite\",\n        )\n        # Draw gateways\n        nx.draw_networkx_nodes(\n            graph,\n            pos,\n            nodelist=gateways,\n            node_shape=\"^\",\n            node_color=\"tab:orange\",\n            node_size=150,\n            alpha=0.7,\n            label=\"Gateway\",\n            ax=ax,\n        )\n        # Draw on-ground users\n        nx.draw_networkx_nodes(\n            graph,\n            pos,\n            nodelist=on_ground_users,\n            node_shape=\"o\",\n            node_color=\"tab:green\",\n            node_size=150,\n            alpha=0.7,\n            label=\"On-ground user\",\n            ax=ax,\n        )\n        if with_labels:\n            # Draw labels of constellation\n            nx.draw_networkx_labels(\n                graph,\n                pos,\n                labels={node: str(node).split(\"-\")[-1] for node in set(pos_constellation)},\n                font_size=5,\n                font_color=\"black\",\n                font_family=\"sans-serif\",\n                font_weight=\"normal\",\n                alpha=0.8,\n                ax=ax,\n            )\n            # Draw labels of user satellites\n            nx.draw_networkx_labels(\n                graph,\n                pos,\n                labels={node: str(node).split(\"-\")[-1] for node in set(pos_user_satellites)},\n                font_size=5,\n                font_color=\"purple\",\n                font_family=\"sans-serif\",\n                font_weight=\"normal\",\n                alpha=0.8,\n                ax=ax,\n            )\n            # Draw labels of gateways\n            nx.draw_networkx_labels(\n                graph,\n                pos,\n                labels={node: str(node).split(\"-\")[-1] for node in gateways},\n                font_size=7,\n                font_color=\"blue\",\n                font_family=\"sans-serif\",\n                font_weight=\"normal\",\n                alpha=0.8,\n                ax=ax,\n            )\n\n        # Draw edges\n        graph_pos_corrected = copy.deepcopy(graph)\n\n        focus_edges_corrected_list = [focus_edges.copy() for focus_edges in focus_edges_list]\n\n        # Re-draw the edges with the correct direction around the globe\n        for u, v in graph.edges():\n            if not (u in nodes_to_draw and v in nodes_to_draw):\n                continue\n            if abs(pos[u][0] - pos[v][0]) &gt; 180:\n                graph_pos_corrected.remove_edge(u, v)\n                u_to_east = pos[u][0] &lt; pos[v][0]\n\n                dummy_u = _dummy_class_creator(type(u)).from_real(u)  # type: ignore[attr-defined,arg-type]\n                pos[dummy_u] = pos[u].copy()\n                pos[dummy_u][0] = pos[dummy_u][0] + 360 if u_to_east else pos[dummy_u][0] - 360\n\n                dummy_v = _dummy_class_creator(type(v)).from_real(v)  # type: ignore[attr-defined,arg-type]\n                pos[dummy_v] = pos[v].copy()\n                pos[dummy_v][0] = pos[dummy_v][0] + 360 if not u_to_east else pos[dummy_v][0] - 360\n\n                graph_pos_corrected.add_edge(u, dummy_v)\n                graph_pos_corrected.add_edge(dummy_u, v)\n\n                for focus_edges, focus_edges_corrected in zip(\n                    focus_edges_list,\n                    focus_edges_corrected_list,\n                    strict=False,\n                ):\n                    for edge in focus_edges:\n                        if (u, v) == edge or (u, v) == edge[::-1]:\n                            focus_edges_corrected.remove(edge)\n                            focus_edges_corrected.add((u, dummy_v))\n                            focus_edges_corrected.add((dummy_u, v))\n\n        intra_plane_edges = {\n            (u, v)\n            for u, v in graph_pos_corrected.edges()\n            if isinstance(u, ConstellationSatellite)\n            and isinstance(v, ConstellationSatellite)\n            and u.id.plane_id == v.id.plane_id\n        }\n        inter_plane_edges = {\n            (u, v)\n            for u, v in graph_pos_corrected.edges()\n            if isinstance(u, ConstellationSatellite)\n            and isinstance(v, ConstellationSatellite)\n            and u.id.plane_id != v.id.plane_id\n        }\n        constellation_gateway_edges = {\n            (u, v)\n            for u, v in graph_pos_corrected.edges()\n            if (isinstance(u, ConstellationSatellite) and isinstance(v, Gateway))\n            or (isinstance(u, Gateway) and isinstance(v, ConstellationSatellite))\n        }\n        constellation_usersatellite_edges = {\n            (u, v)\n            for u, v in graph_pos_corrected.edges()\n            if (isinstance(u, ConstellationSatellite) and isinstance(v, UserSatellite))\n            or (isinstance(u, UserSatellite) and isinstance(v, ConstellationSatellite))\n        }\n        inter_gateways_edges = {\n            (u, v) for u, v in graph_pos_corrected.edges() if isinstance(u, Gateway) and isinstance(v, Gateway)\n        }\n        other_edges_to_draw = (\n            {(u, v) for u, v in graph_pos_corrected.edges() if u in nodes_to_draw and v in nodes_to_draw}\n            - intra_plane_edges\n            - inter_plane_edges\n            - constellation_gateway_edges\n            - constellation_usersatellite_edges\n            - inter_gateways_edges\n        )\n\n        # Draw intra-plane edges\n        h1 = nx.draw_networkx_edges(\n            graph_pos_corrected,\n            pos,\n            edgelist=intra_plane_edges,\n            width=1,\n            edge_color=\"tab:purple\",\n            ax=ax,\n            arrows=True,\n            alpha=0.7,\n            arrowstyle=\"&lt;|-|&gt;\",\n            label=\"Intra-plane links\",\n        )\n        _add_legend_to_edges(h1, \"Intra-plane links\", ax=ax)\n\n        # Draw inter-plane edges\n        h2 = nx.draw_networkx_edges(\n            graph_pos_corrected,\n            pos,\n            edgelist=inter_plane_edges,\n            width=1,\n            edge_color=\"tab:green\",\n            ax=ax,\n            arrows=True,\n            alpha=0.7,\n            arrowstyle=\"&lt;|-|&gt;\",\n            label=\"Inter-plane links\",\n        )\n        _add_legend_to_edges(h2, \"Inter-plane links\", ax=ax)\n\n        # Draw constellation-gateway edges\n        h3 = nx.draw_networkx_edges(\n            graph_pos_corrected,\n            pos,\n            edgelist=constellation_gateway_edges,\n            width=1,\n            edge_color=\"tab:brown\",\n            ax=ax,\n            arrows=True,\n            alpha=0.7,\n            arrowstyle=\"&lt;|-|&gt;\",\n            label=\"Feeder links\",\n        )\n        _add_legend_to_edges(h3, \"Feeder links\", ax=ax)\n\n        # Draw constellation-usersatellite edges\n        h4 = nx.draw_networkx_edges(\n            graph_pos_corrected,\n            pos,\n            edgelist=constellation_usersatellite_edges,\n            width=1,\n            edge_color=\"tab:cyan\",\n            ax=ax,\n            arrows=True,\n            alpha=0.7,\n            arrowstyle=\"&lt;|-|&gt;\",\n            label=\"Service links\",\n        )\n        _add_legend_to_edges(h4, \"Service links\", ax=ax)\n\n        # Draw inter-gateways edges\n        h5 = nx.draw_networkx_edges(\n            graph_pos_corrected,\n            pos,\n            edgelist=inter_gateways_edges,\n            width=1,\n            edge_color=\"tab:olive\",\n            ax=ax,\n            arrows=True,\n            alpha=0.7,\n            arrowstyle=\"&lt;|-|&gt;\",\n            label=\"Gateway links\",\n        )\n        _add_legend_to_edges(h5, \"Gateway links\", ax=ax)\n\n        # Draw other edges\n        h6 = nx.draw_networkx_edges(\n            graph_pos_corrected,\n            pos,\n            edgelist=other_edges_to_draw,\n            width=1,\n            edge_color=\"tab:gray\",\n            ax=ax,\n            arrows=True,\n            alpha=0.7,\n            arrowstyle=\"&lt;|-|&gt;\",\n            label=\"Other links\",\n        )\n        _add_legend_to_edges(h6, \"Other links\", ax=ax)\n\n        for focus_edges_corrected, focus_edges_label in zip(\n            focus_edges_corrected_list,\n            focus_edges_label_list,\n            strict=False,\n        ):\n            if not focus_edges_corrected:\n                continue  # \u7a7a\u96c6\u5408\u306a\u3089\u30b9\u30ad\u30c3\u30d7\n            h7 = nx.draw_networkx_edges(\n                graph_pos_corrected,\n                pos,\n                edgelist=focus_edges_corrected,\n                width=3,\n                edge_color=\"tab:red\",\n                ax=ax,\n                arrows=True,\n                alpha=0.7,\n                arrowstyle=\"-\",\n                label=focus_edges_label,\n            )\n            _add_legend_to_edges(h7, focus_edges_label, ax=ax)\n\n    return ax\n</code></pre>"},{"location":"reference/cosmica/visualization/equirectangular/#cosmica.visualization.equirectangular.draw_snapshot_movie","title":"draw_snapshot_movie","text":"<pre><code>draw_snapshot_movie(\n    *,\n    graph: list[Graph],\n    time_array: NDArray,\n    dynamics_data: DynamicsData,\n    time_index_for_plot: NDArray,\n    fig: Figure,\n    ax: Axes,\n    interval_ms: int = 100\n) -&gt; FuncAnimation\n</code></pre> <p>Draw a snapshot of the network graph for a movie.</p> Source code in <code>src/cosmica/visualization/equirectangular.py</code> <pre><code>def draw_snapshot_movie(\n    *,\n    graph: list[nx.Graph],\n    time_array: npt.NDArray,\n    dynamics_data: DynamicsData,\n    time_index_for_plot: npt.NDArray,\n    fig: Figure,\n    ax: Axes,\n    interval_ms: int = 100,\n) -&gt; FuncAnimation:\n    \"\"\"Draw a snapshot of the network graph for a movie.\"\"\"\n\n    def update(frame: int):  # noqa: ANN202\n        ax.clear()\n\n        time_index = time_index_for_plot[frame]\n\n        title = f\"Time: {np.datetime_as_string(time_array[time_index], unit='ms').split('T')[1]}\"\n        ax.set_title(title)\n\n        draw_lat_lon_grid(ax=ax)\n        draw_countries(ax=ax)\n        draw_snapshot(\n            graph=graph[time_index],\n            dynamics_data=dynamics_data[time_index],\n            ax=ax,\n            with_labels=False,\n        )\n        ax.legend(loc=\"lower left\")\n\n    return FuncAnimation(fig, update, frames=len(time_index_for_plot), interval=interval_ms)\n</code></pre>"},{"location":"reference/cosmica/visualization/equirectangular/#cosmica.visualization.equirectangular.draw_urban_areas","title":"draw_urban_areas","text":"<pre><code>draw_urban_areas(*, ax: Axes, zorder: int = 1) -&gt; Axes\n</code></pre> Source code in <code>src/cosmica/visualization/equirectangular.py</code> <pre><code>def draw_urban_areas(*, ax: Axes, zorder: int = 1) -&gt; Axes:\n    df_urban_areas = _load_shapefile_from_assets_dir(\"ne_50m_urban_areas.shp\")\n    df_urban_areas.plot(ax=ax, color=\"red\", zorder=zorder)\n    return ax\n</code></pre>"},{"location":"reference/cosmica/visualization/utils/","title":"utils","text":""},{"location":"reference/cosmica/visualization/utils/#cosmica.visualization.utils","title":"cosmica.visualization.utils","text":""},{"location":"reference/cosmica/visualization/utils/#cosmica.visualization.utils.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['preserve_tick_params']\n</code></pre>"},{"location":"reference/cosmica/visualization/utils/#cosmica.visualization.utils.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/cosmica/visualization/utils/#cosmica.visualization.utils.preserve_tick_params","title":"preserve_tick_params","text":"<pre><code>preserve_tick_params(\n    ax: Axes,\n) -&gt; Generator[None, Any, None]\n</code></pre> Source code in <code>src/cosmica/visualization/utils.py</code> <pre><code>@contextmanager\ndef preserve_tick_params(ax: Axes) -&gt; Generator[None, Any, None]:\n    params = _save_tick_params(ax)\n    try:\n        yield\n    finally:\n        _restore_tick_params(params, ax)\n</code></pre>"}]}